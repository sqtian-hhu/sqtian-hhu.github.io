<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信小程序总结</title>
      <link href="/2021/08/08/ji-chu-zheng-li/wei-xin-xiao-cheng-xu-zong-jie/"/>
      <url>/2021/08/08/ji-chu-zheng-li/wei-xin-xiao-cheng-xu-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="微信短视频分享小程序"><a href="#微信短视频分享小程序" class="headerlink" title="微信短视频分享小程序"></a>微信短视频分享小程序</h2><h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><ol><li>这个项目后端是一个多模块maven聚合工程，所谓多模块聚合首先创建一个maven工程，他的pom文件主要导入的是各层通用的一些依赖，然后controller，service，dao这些层是各自新建的子工程，通过pom配置层级依赖关系。主要就是想将各个模块分开来，项目结构更加清楚。开发过程方便管理。</li><li>然后是表的构建，项目主要有users表，包含id，username，password，头像路径，粉丝数，被点赞数，被收藏数这些字段。还有videos表，包含id，作者id，视频描述，视频保存路径，视频时长，配的bgmid，创建时间，被点赞数，被收藏数这些字段，还有comments表记录评论，bgm表记录背景音乐信息等。</li><li>持久层基于mybatis框架连接数据库，连接池配置了阿里的Druid连接池。另外这边使用了一个mybatis-generatorConfig的逆向生成插件，自动把数据库里的表给我映射成了对象。</li><li>小程序的第一个功能是注册和登录。前端把表格信息传过来后，首先判断用户名和密码不能为空，然后调用service层方法判断用户名是否已经存在，另外还要用MD5Utils把前端传过来的密码加密一下，最后就是正常的把用户信息存到对应数据库表里。</li><li>登陆功能的实现也类似，controller调用service查一下数据库里有没有，有的话密码是否匹配。这边用了一下redis缓存数据库，登陆成功之后会把userId和Token存在redis里，这里存的token就是用UUID类随机生成的一段码，下次登陆会查询redis数据库，比再去查询mysql快一点。</li><li>登录进来后，可以上传头像，发表作品，这两个功能都是通过IO流实现的，首先前端将文件上传成功后，后端拿MultiPartFile类接收，先是开IO流把文件存到服务器磁盘上，然后会更新数据库里存的相对路径。发表作品在上传头像功能的基础上，首先需要判断是否配了bgm，有bgm的话会利用ProcessBuilder类执行cmd命令，调用ffmpeg将视频和bgm合成起来，此外还会利用ffmpeg截取一帧图片做封面。</li><li>小程序主页展示所有作品，这个功能后端会利用PageHelper类分页返回实现一个分页展示的效果。</li><li>最后还有点赞收藏关注评论这些功能主要就是按部就班地改数据库信息就成。</li></ol><h3 id="后台管理网站"><a href="#后台管理网站" class="headerlink" title="后台管理网站"></a>后台管理网站</h3><ol><li>用SSM框架写了一个后台管理网站，主要就是处理举报信息，禁播违规视频，管理bgm这些功能。管理bgm这边用到了zookeeper的一个监听功能，我在后台网站上传了bgm或者删除某个bgm后，小程序部署的服务器会监听到bgm库的改变，也会对数据库做相应的改变</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 项目整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础整理</title>
      <link href="/2021/08/08/ji-chu-zheng-li/ji-chu-zheng-li/"/>
      <url>/2021/08/08/ji-chu-zheng-li/ji-chu-zheng-li/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://raw.githubusercontent.com/sqtian-hhu/images/main/images/friends/5.jpg" alt="冲冲冲"></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>面向对象是相对于面向过程来讲的，举个例子来说，我想要做一件事，面向过程就是我去了解怎么做这件事，然后自己来做。面向对象就是找到一个会做这件事的人来替我做事。所谓面向对象，就是把相关数据和方法组织成一个整体来看待，从更高的层次来系统建模。</p><h3 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h3><p>封装继承多态</p><p>封装：把对象的属性和方法包装起来，只通过约定好的接口来访问。</p><p>java中主要通过private来实现封装，用private修饰属性或方法，然后通过geter，seter方法来访问，这样可以在seter方法中加入一些逻辑判断，保证属性的合理性。</p><p>继承： 新的类吸收已有类的属性和方法，并且可以扩展新的功能。java中的类是单继承的，可以通过实现接口来实现多继承</p><p>多态：指的是一个对象可以有多种状态。实现相同的类型调用相同的方法可以得到不同的结果。什么意思呢，举个例子就是学校里有全体在校人员，<br>学生类，老师类都继承自在校人员类，每个学生既是学生类也是在校人员类，我想要让在校人员都完成一件事，并不关心传入的是学生还是老师，此时传入参数类型就是在校人员类，可以通过isinstanceof方法来判断，然后实现不同德操作。</p><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>private 只能同一个类里访问<br>(default) 同一个包里可以访问<br>protected 如果不是在同一个包里,只有子类可以访问<br>public    全都可以访问</p><h3 id="String是基础类型吗"><a href="#String是基础类型吗" class="headerlink" title="String是基础类型吗"></a>String是基础类型吗</h3><p>八个基本数据类型: byte,short,int,long,float,double,char,boolean.</p><p>String是引用类型</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><pre><code>Integer f1 = 100,f2=100,f3==150,f4=150;sout(f1==f2); //truesout(f3==f4); //false</code></pre><p>用Integer接收int，会自动装箱。Integer源码里，有一个-128<del>127的缓存池，当int在这个范围里时，valueOf方法会直接返回缓存里已经创建好的Integer对象，==对于基本类型是比较值，对于对象是比较地址，由于-128</del>127内的数装箱得到的是同一个Integer对象，所以f1==f2为true；而对于超过这个范围的数，valueOf方法会返回一个新创建的Integer对象，f3和f4不是同一个对象，所以是false。</p><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h3><p>&amp;：</p><p>按位与：二进制按位与运算</p><p>逻辑与：if(a==0 &amp; a++&gt;0) 左边不管true或false，右边的判断都回执行</p><p>&amp;&amp;：<br>短路与：左边如果是false，右边就不会执行了</p><h3 id="构造器是否可以被重写"><a href="#构造器是否可以被重写" class="headerlink" title="构造器是否可以被重写"></a>构造器是否可以被重写</h3><p>构造器不能被继承，因此不能被重写。但可以重载。</p><h3 id="String是否可以被继承"><a href="#String是否可以被继承" class="headerlink" title="String是否可以被继承"></a>String是否可以被继承</h3><p>String类是final类型，所以不能被继承</p><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载：在同一个类中，同名的方法如果有不同的参数列表（参数类型，参数个数，参数顺序）视为重载，不同的返回类型不构成重载。</p><p>重写：发生在父子关系的类中，子类重写父类的方法，参数列表一致，返回类型必须相同或者是父类方法返回类型的子类</p><h3 id="抽象类的接口的区别"><a href="#抽象类的接口的区别" class="headerlink" title="抽象类的接口的区别"></a>抽象类的接口的区别</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 呈呈专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2021/08/06/git/"/>
      <url>/2021/08/06/git/</url>
      
        <content type="html"><![CDATA[<h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>ssh-keygen -t rsa -C “<a href="mailto:sqtian_hhu@163.com" target="_blank" rel="noopener">sqtian_hhu@163.com</a>“</p><p>github添加公钥</p><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p>设置用户签名<br>git config –global user.name 用户名<br>git config –global user.email 邮箱</p><p>git init</p><p>设置别名<br>git remote add 别名 链接<br>查看已添加的远程库别名和地址<br>git remote -v</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>查看状态<br>git status<br>工作区添加到暂存区<br>git add [-A]<br>暂存区提交到本地库<br>git commit -m “描述”<br>提交到远程库<br>git push 库名 分支名</p><p>从远程库克隆/更新<br>git clone </p><p>git pull </p><p>跨组<br>git fork<br>fork到本组远程库在拉到本地库<br>创建新的分支<br>git branch 分支名<br>查看分支<br>git branch -v</p><p>切换分支<br>git checkout 分支名</p><p>把指定分支合并到当前分支上<br>git merge 指定分支</p><p>查看log<br>git log<br>git reflog</p><p>版本回溯<br>git reset –hard 版本号</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣剑指</title>
      <link href="/2021/06/14/li-kou/li-kou-jian-zhi/"/>
      <url>/2021/06/14/li-kou/li-kou-jian-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="leetcode-剑指offer"><a href="#leetcode-剑指offer" class="headerlink" title="leetcode 剑指offer"></a>leetcode 剑指offer</h3><h2 id="01-数组中重复的数字"><a href="#01-数组中重复的数字" class="headerlink" title="01.数组中重复的数字"></a>01.数组中重复的数字</h2><p>利用count数组存0~n-1出现的次数, 当其&gt;1时说明是重复元素</p><p>class Solution {<br>    public int findRepeatNumber(int[] nums){<br>        int[] count = new int[nums.length];<br>        for(int n:nums){<br>            count[n]++;<br>            if(count[n]&gt;1) return n;<br>        }</p><pre><code>    return -1;}</code></pre><p>}</p><h2 id="02-二维数组中的查找"><a href="#02-二维数组中的查找" class="headerlink" title="02.二维数组中的查找"></a>02.二维数组中的查找</h2><p>查找是否包含该数, 从右上角开始搜索</p><p>class Solution {<br>    public boolean findNumberIn2DArray(int[][] matrix, int target) {<br>        // 判空<br>        if(matrix==null||matrix.length==0||matrix[0].length==0) return false;</p><pre><code>    int m = 0;    int n = matrix[0].length-1;    while(m&lt;matrix.length&amp;&amp;n&gt;=0){        // 如果==, 返回        if(matrix[m][n]==target){            return true;        }        // 如果&lt;target, 说明第m行都比target小        else if(matrix[m][n]&lt;target){            m++;        }        // 如果&gt;target, 说明第n列都比target大        else{            n--;        }    }    return false;}</code></pre><p>}</p><h2 id="03-替换空格"><a href="#03-替换空格" class="headerlink" title="03.替换空格"></a>03.替换空格</h2><p>we are -&gt; we%20are</p><p>class Solution {<br>    public String replaceSpace(String s) {<br>        // 判空<br>        if(s==null||s.length()==0) return s;<br>        // 转成char数组<br>        char[] ch = s.toCharArray();<br>        char[] res = new char[3*ch.length];<br>        int index=0;<br>        for(int i=0;i&lt;ch.length;i++){<br>            if(ch[i]==’ ‘) {<br>                res[index++]=’%’;<br>                res[index++]=’2’;<br>                res[index++]=’0’;<br>            }<br>            else{<br>                res[index++]=ch[i];<br>            }<br>        }<br>        return new String(res,0,index);<br>    }<br>}</p><h2 id="04-从尾到头打印链表"><a href="#04-从尾到头打印链表" class="headerlink" title="04.从尾到头打印链表"></a>04.从尾到头打印链表</h2><p>1,3,2 -&gt; 2,3,1</p><p>class Solution {<br>    public int[] reversePrint(ListNode head) {<br>        int len = 0;<br>        ListNode cur = head;<br>        // 先求出链表长度<br>        while(cur!=null){<br>            len++;<br>            cur = cur.next;<br>        }<br>        // 从后往前装入数组<br>        int[] res = new int[len];<br>        cur = head;<br>        while(cur!=null){<br>            res[–len] = cur.val;<br>            cur = cur.next;<br>        }<br>        return res;<br>    }<br>}</p><h2 id="05-重建二叉树"><a href="#05-重建二叉树" class="headerlink" title="05.重建二叉树"></a>05.重建二叉树</h2><p>给出前序,中序, 重建树<br>递归, 按照前序顺序重建节点 dfs(pre,in,null)<br>递归终止条件: 按前序已建立好所有节点,或者到了中序的截断点</p><p>class Solution {<br>    // 前序<br>    int preindex;<br>    // 中序<br>    int inindex;<br>    public TreeNode buildTree(int[] preorder, int[] inorder) {<br>        preindex = 0;<br>        inindex = 0;<br>        return dfs(preorder,inorder,null);<br>    }<br>    // pre:前序 in:中序 finish:分段截断点<br>    // 功能：重建finish节点前的所有节点<br>    TreeNode dfs(int[] pre,int[] in,TreeNode finish){<br>        // 递归终止条件<br>        // 如果按照前序遍历已经重建好了所有节点，或者到了中序里的截断点<br>        if(preindex==pre.length||(finish!=null&amp;&amp;finish.val==in[inindex])) return null;</p><pre><code>    // 重建根节点: 前序遍历    TreeNode r = new TreeNode(pre[preindex]);    preindex++;    // 左 递归 中序遍历r之前的节点    r.left = dfs(pre,in,r);    inindex++;    // 右    r.right = dfs(pre,in,finish);    return r;}</code></pre><p>}</p><h2 id="06-用两个栈实现队列"><a href="#06-用两个栈实现队列" class="headerlink" title="06.用两个栈实现队列"></a>06.用两个栈实现队列</h2><p>添加时A直接存入, 删除时B中有元素则从B中弹出, 没有则将A中的全部元素弹入B中, 再弹出B顶</p><p>class CQueue {<br>    Stack<integer> A;<br>    Stack<integer> B;</integer></integer></p><pre><code>public CQueue() {    A = new Stack&lt;&gt;();    B = new Stack&lt;&gt;();}public void appendTail(int value) {    // 添加时直接添加    A.push(value);}public int deleteHead() {    // 删除时倒到B中删除，B作为一个缓冲区使用    // 如果B中此时有值，直接从B中返回    if(!B.isEmpty()) return B.pop();    else{        while(!A.isEmpty()){            B.push(A.pop());        }        if(!B.isEmpty()) return B.pop();    }    return -1;}</code></pre><p>}</p><h2 id="07-斐波那契数列"><a href="#07-斐波那契数列" class="headerlink" title="07.斐波那契数列"></a>07.斐波那契数列</h2><p>F(0)=0;F(1)=1<br>F(n)=F(n-1)+F(n-2)</p><p>class Solution {<br>    public int fib(int n) {<br>        int a = 0;<br>        int b = 1;</p><pre><code>    for(int i=0;i&lt;n;i++){        int temp = a%1000000007;        a = b%1000000007;        b = temp+a;    }    return a%1000000007;}</code></pre><p>}</p><p>变题: 青蛙跳台阶,矩形覆盖<br>F(0)=1;F(1)=1<br>F(n)=F(n-1)+F(n-2)</p><p>class Solution {<br>    public int numWays(int n) {<br>        int a = 1;<br>        int b = 1;</p><pre><code>    for(int i=0;i&lt;n;i++){        int t = a%1000000007;        a = b%1000000007;        b = a+t;    }    return a%1000000007;}</code></pre><p>}</p><p>变态跳台阶<br>一次跳1~n级, 跳上n级多少种方法</p><p>每个台阶跳或不跳, 最后一个必跳 =&gt;求2^(n-1)</p><h2 id="08-旋转数组的最小数字"><a href="#08-旋转数组的最小数字" class="headerlink" title="08.旋转数组的最小数字"></a>08.旋转数组的最小数字</h2><p>找临界点: 二分</p><p>class Solution {<br>    public int minArray(int[] numbers) {<br>        //找临界点：二分<br>        //1. 没有翻转的情况<br>        int l=0,r=numbers.length-1;<br>        if(numbers[0]&lt;numbers[r]) return numbers[0];<br>        //2. 3451222的情况<br>        while(r&gt;0&amp;&amp;numbers[r]==numbers[r-1]) r–;</p><pre><code>    //二分    int p = numbers[0];    int mid = 0;    while(l&lt;r){        mid = l+(r-l)/2;        if(numbers[mid]&gt;=p) l=mid+1;        if(numbers[mid]&lt;p) r =mid;    }    return numbers[r];}</code></pre><p>}</p><h2 id="09-矩阵中的路径"><a href="#09-矩阵中的路径" class="headerlink" title="09.矩阵中的路径"></a>09.矩阵中的路径</h2><p>深度优先二维搜索 dfs(board,word,i,j,0)</p><p>class Solution {<br>    int m;<br>    int n;<br>    public boolean exist(char[][] board, String word) {<br>        //深度优先<br>        if(board==null||board.length==0||board[0].length==0) return false;<br>        m=board.length;<br>        n=board[0].length;<br>        for(int i=0;i&lt;m;i++){<br>            for(int j=0;j&lt;n;j++){<br>                if(dfs(board,word,i,j,0)) return true;<br>            }<br>        }<br>        return false;<br>    }<br>    //b:字母矩阵 word:单词 i,j 起点 s:单词检索索引<br>    boolean dfs(char[][] b,String word,int i,int j,int s){<br>        //递归终止条件</p><pre><code>    //越界或者不等 返回false    if(i&lt;0||i&gt;=m||j&lt;0||j&gt;=n||b[i][j]!=word.charAt(s)) return false;    //如果上面没有返回false且word全走完了 返回true    if(s==word.length()-1) return true;    char temp = b[i][j];    //利用'*'代替visited标记    b[i][j] = '*';    //搜索上下左右    boolean res = dfs(b,word,i+1,j,s+1)||dfs(b,word,i-1,j,s+1)||dfs(b,word,i,j+1,s+1)||dfs(b,word,i,j-1,s+1);    //回溯    b[i][j] = temp;    return res;}</code></pre><p>}</p><h2 id="10-机器人运动范围"><a href="#10-机器人运动范围" class="headerlink" title="10.机器人运动范围"></a>10.机器人运动范围</h2><p>dfs(x,y,xh,yh)</p><p>class Solution {<br>    //visited记录已经访问的位置<br>    boolean[][] visited;<br>    int target;<br>    int M;<br>    int N;<br>    public int movingCount(int m, int n, int k) {<br>        //深度优先<br>        M=m;<br>        N=n;<br>        target = k;<br>        visited = new boolean[M][N];<br>        //传入起点, x的位和xh,y的位和yh<br>        return dfs(0,0,0,0);<br>    }<br>    //x,y 起点 xh:x位和 yh:y位和<br>    int dfs(int x,int y,int xh,int yh){<br>        //终止条件:越界||已访问||超过规定k<br>        if(x&lt;0||x&gt;=M||y&lt;0||y&gt;=N||visited[x][y]||(xh+yh)&gt;target) return 0;<br>        visited[x][y] = true;<br>        //19-&gt;20 和小了8<br>        //18-&gt;19 和大了1<br>        return 1+ dfs(x+1,y,(x+1)%10==0?xh-8:xh+1,yh)+dfs(x,y+1,xh,(y+1)%10==0?yh-8:yh+1);<br>    }<br>}</p><h2 id="11-剪绳子"><a href="#11-剪绳子" class="headerlink" title="11.剪绳子"></a>11.剪绳子</h2><p>动态规划</p><p>class Solution {<br>    public int cuttingRope(int n) {<br>        //动态规划<br>        //dp[i]=max(dp[i],dp[i-j]<em>j,(i-j)</em>j)<br>        if(n&lt;1) return 0;<br>        //1. 初始化dp<br>        int[] dp = new int[n+1];<br>        dp[1] = 1;<br>        //2. 遍历更新<br>        for(int i=2;i&lt;=n;i++){<br>            for(int j=1;j&lt;i;j++){<br>                dp[i] = Math.max(Math.max(dp[i-j]<em>j,(i-j)</em>j),dp[i]);<br>            }<br>        }<br>        return dp[n];<br>    }<br>}</p><h2 id="12-剪绳子-取模"><a href="#12-剪绳子-取模" class="headerlink" title="12.剪绳子(取模)"></a>12.剪绳子(取模)</h2><p>贪心</p><p>class Solution {<br>    public int cuttingRope(int n) {<br>        //需要取模的话就不能用动态规划了<br>        //贪心算法<br>        //尽可能地取3，最后余数可能是0，1，2<br>        //0：结果即为所有三相乘<br>        //1：取出一个三，2<em>2&gt;3</em>1<br>        //2: 所有三相乘再*2<br>        if(n&lt;1) return 0;<br>        if(n==1) return 1;<br>        if(n==2) return 1;<br>        if(n==3) return 2;</p><pre><code>    int e=1000000007;    //res一定要用long类型,不然大数会出错    long res = 1;       if(n%3==2) {        n-=2;        res=2;    }    else if(n%3==1){        n-=4;        res = 4;    }    while(n&gt;0){        res*=3;        res = res%e;        n-=3;    }    return (int)res%e;}</code></pre><p>}</p><h2 id="13-二进制中1的个数"><a href="#13-二进制中1的个数" class="headerlink" title="13.二进制中1的个数"></a>13.二进制中1的个数</h2><p>0001011 =&gt; 3<br>利用n&amp;(n-1)每次消去一个1</p><p>public class Solution {<br>    // you need to treat n as an unsigned value<br>    public int hammingWeight(int n) {<br>        //n&amp;(n-1)<br>        int count = 0;<br>        while(n!=0){<br>            n = n&amp;(n-1);<br>            count++;<br>        }<br>        return count;<br>    }<br>}</p><h2 id="14-数值的整数次方"><a href="#14-数值的整数次方" class="headerlink" title="14.数值的整数次方"></a>14.数值的整数次方</h2><p>快速幂写法 x^p</p><p>class Solution {<br>    public double myPow(double x, int n) {<br>        //快速幂写法<br>        if(n==0&amp;&amp;x==0) return -1;<br>        else if(n==0) return 1;<br>        else if(x==0) return 0;<br>        //用long接收，防止越界<br>        long p = n;</p><pre><code>    if(p&lt;0){        x = 1/x;        p = -p;    }        double res = 1.0;    while(p&gt;0){        if((p&amp;1)==1) res*=x;        x *=x;        p &gt;&gt;=1;    }    return res;}</code></pre><p>}</p><h2 id="15-打印从1到最大的n位数"><a href="#15-打印从1到最大的n位数" class="headerlink" title="15.打印从1到最大的n位数"></a>15.打印从1到最大的n位数</h2><p>1,2,3…</p><p>class Solution {<br>    public int[] printNumbers(int n) {<br>        //打印1~10^n-1<br>        //快速幂求上界<br>        long p = n;<br>        int x = 10;<br>        int r = 1;<br>        while(p!=0){<br>            if((p&amp;1)==1) r*=x;<br>            x *=x;<br>            p &gt;&gt;=1;<br>        }<br>        //打印<br>        int[] res = new int[r-1];<br>        for(int i=0;i&lt;r-1;i++){<br>            res[i] = i+1;<br>        }<br>        return res;<br>    }<br>}</p><h2 id="16-删除链表的节点"><a href="#16-删除链表的节点" class="headerlink" title="16.删除链表的节点"></a>16.删除链表的节点</h2><p>class Solution {<br>    public ListNode deleteNode(ListNode head, int val) {<br>        if(head==null) return null;<br>        //先搜索再删除<br>        //dummy 哨兵节点<br>        ListNode dummy = new ListNode(0);<br>        dummy.next = head;<br>        //双指针移动<br>        ListNode pre = dummy;<br>        while(head!=null){<br>            if(head.val==val){<br>                pre.next = head.next;<br>            }<br>            pre = pre.next;<br>            head = head.next;<br>        }<br>        return dummy.next;<br>    }<br>}</p><h2 id="17-正则式匹配"><a href="#17-正则式匹配" class="headerlink" title="17.正则式匹配"></a>17.正则式匹配</h2><p>动态规划</p><p>class Solution {<br>    public boolean isMatch(String s, String p) {<br>        //动态规划<br>        //dp[i][j]: 表示s的前i个和p的前j个相匹配，即0<del>i-1和0</del>j-1匹配<br>        int m = s.length();<br>        int n = p.length();<br>        boolean[][] dp = new boolean[m+1][n+1];</p><pre><code>    for(int i=0;i&lt;=m;i++){        for(int j=0;j&lt;=n;j++){            //初始化 dp[0][0]=true,其余dp[i][0]=false;            if(j==0){                dp[i][0] = (i==0);            }else{                //如果不是*                if(p.charAt(j-1)!='*'){                    //如果s[i-1]和p[i-1]相匹配，则前i个与前j个匹配情况同上一个相同                    if(i&gt;0&amp;&amp;(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.')){                        dp[i][j] = dp[i-1][j-1];                    }                }                //如果是'*'                else{                    //'*'若取零,则前ij个的匹配情况就和前i j-2个的匹配相同                    if(j&gt;=2){                        dp[i][j] |= dp[i][j-2];                    }                    //'*'不取零,就要看前i j-1个是否相匹配                    //s[i-1]和p[j-2]比较，相等则匹配情况与前i-1 j个相同，i继续往后匹配                    if(j&gt;=2&amp;&amp;i&gt;0&amp;&amp;(s.charAt(i-1)==p.charAt(j-2)||p.charAt(j-2)=='.')){                        dp[i][j] |= dp[i-1][j];                    }                }            }        }    }    return dp[m][n];}</code></pre><p>}</p><h2 id="18-表示数值的字符串"><a href="#18-表示数值的字符串" class="headerlink" title="18.表示数值的字符串"></a>18.表示数值的字符串</h2><p>class Solution {<br>    public boolean isNumber(String s) {<br>        char[] ch = s.trim().toCharArray();<br>        if(ch==null||ch.length==0) return false;<br>        //设置标志位记录前面是否出现过该元素<br>        boolean e = false;<br>        boolean dot = false;<br>        boolean num = false;</p><pre><code>    for(int i=0;i&lt;ch.length;i++){        if(ch[i]&gt;='0'&amp;&amp;ch[i]&lt;='9'){            num=true;        }        else if(ch[i]=='e'||ch[i]=='E'){            //如果是e, e前面一定有数字,不能有e,且e之后一定得有数字            if(!num||e) return false;            e = true;            //重置num,便于判断后面有没有数字            num = false;        }        else if(ch[i]=='.'){            //.前面不能有e,不能有.            if(dot||e) return false;            dot=true;        }        else if(ch[i]=='+'||ch[i]=='-'){            //符号出现在第一位或者e后面一位,否则不对            if(i!=0&amp;&amp;ch[i-1]!='e'&amp;&amp;ch[i-1]!='E') return false;        }        else{            return false;        }    }    return num;}</code></pre><p>}</p><h2 id="19-调整数组顺序使奇数位于偶数前面"><a href="#19-调整数组顺序使奇数位于偶数前面" class="headerlink" title="19.调整数组顺序使奇数位于偶数前面"></a>19.调整数组顺序使奇数位于偶数前面</h2><p>解1:暴力搜索,可以不改变相对顺序<br>解2:快排,但相对顺序可能发生改变</p><p>class Solution {<br>    public int[] exchange(int[] nums) {<br>        //快排<br>        if(nums==null||nums.length==0) return nums;<br>        int l = 0,r = nums.length-1;</p><pre><code>    while(l&lt;r){        //r从右往左找奇数        while(l&lt;r&amp;&amp;nums[r]%2==0) r--;        //l从左往右找偶数        while(l&lt;r&amp;&amp;nums[l]%2==1) l++;        if(l&lt;r){            int temp = nums[l];            nums[l] = nums[r];            nums[r] = temp;        }    }    return nums;}</code></pre><p>}</p><h2 id="20-链表中倒数第k个节点"><a href="#20-链表中倒数第k个节点" class="headerlink" title="20.链表中倒数第k个节点"></a>20.链表中倒数第k个节点</h2><p>class Solution {<br>    public ListNode getKthFromEnd(ListNode head, int k) {<br>        //双指针<br>        //快指针先跑k个节点，然后两个一起跑<br>        //当快指针到底时，慢指针就停在解上<br>        ListNode fast = head;<br>        for(int i=0;i&lt;k;i++){<br>            if(fast==null) return null;<br>            fast = fast.next;<br>        }<br>        ListNode slow = head;<br>        while(fast!=null){<br>            slow=slow.next;<br>            fast=fast.next;<br>        }<br>        return slow;</p><pre><code>}</code></pre><p>}</p><h2 id="21-反转链表"><a href="#21-反转链表" class="headerlink" title="21.反转链表"></a>21.反转链表</h2><p>pre,cur,next一起后移</p><p>class Solution {<br>    public ListNode reverseList(ListNode head) {<br>        ListNode pre = null;<br>        ListNode next = null;<br>        while(head!=null){<br>            next = head.next;<br>            head.next = pre;<br>            pre = head;<br>            head = next;<br>        }</p><pre><code>    return pre;}</code></pre><p>}</p><h2 id="22-合并两个排序的链表"><a href="#22-合并两个排序的链表" class="headerlink" title="22.合并两个排序的链表"></a>22.合并两个排序的链表</h2><p>归并排序改写</p><p>class Solution {<br>    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {<br>        //参考归并排序最后的合并阶段<br>        ListNode dummy = new ListNode(0);<br>        ListNode res = dummy;<br>        while(l1!=null&amp;&amp;l2!=null){<br>            if(l1.val&lt;l2.val){<br>                res.next=l1;<br>                l1=l1.next;<br>            }else{<br>                res.next=l2;<br>                l2=l2.next;<br>            }<br>            res=res.next;<br>        }<br>        //多出来的部分直接接在res后面<br>        if(l1!=null){<br>            res.next=l1;<br>        }<br>        if(l2!=null){<br>            res.next=l2;<br>        }</p><pre><code>    return dummy.next;}</code></pre><p>}</p><h2 id="23-树的子结构"><a href="#23-树的子结构" class="headerlink" title="23.树的子结构"></a>23.树的子结构</h2><p>class Solution {<br>    public boolean isSubStructure(TreeNode A, TreeNode B) {<br>        if(B==null||A==null) return false;</p><pre><code>    //递归找到值相等的根,进入递归方法判断是否结构相同    if(A.val==B.val){        if(sub(A,B)) return true;    }    return isSubStructure(A.left,B)||isSubStructure(A.right,B);}boolean sub(TreeNode r1,TreeNode r2){    //如果r2到了最后都顺利 说明匹配正确    if(r2==null) return true;    //如果r1空了还没匹配出结果或者值不一样，返回false    if(r1==null||r1.val!=r2.val) return false;    //递归 要求左右结构都相同    return sub(r1.left,r2.left)&amp;&amp;sub(r1.right,r2.right);}</code></pre><p>}</p><h2 id="24-二叉树的镜像"><a href="#24-二叉树的镜像" class="headerlink" title="24.二叉树的镜像"></a>24.二叉树的镜像</h2><p>递归 左=右 右=左</p><p>class Solution {<br>    public TreeNode mirrorTree(TreeNode root) {<br>        if(root==null) return null;<br>        TreeNode temp = root.left;<br>        root.left = mirrorTree(root.right);<br>        root.right = mirrorTree(temp);<br>        return root;<br>    }<br>}</p><h2 id="25-对称的二叉树"><a href="#25-对称的二叉树" class="headerlink" title="25.对称的二叉树"></a>25.对称的二叉树</h2><p>递归 判断节点是否相同<br>A.左=B.右  A.右=B.左</p><p>class Solution {<br>    public boolean isSymmetric(TreeNode root) {<br>        if(root==null) return true;<br>        //递归<br>        //判断左右是否对称<br>        return dfs(root.left,root.right);<br>    }</p><pre><code>boolean dfs(TreeNode A,TreeNode B){    if(A==null&amp;&amp;B==null) return true;    if(A==null||B==null||A.val!=B.val) return false;    //左等于右 右等于左    return dfs(A.left,B.right)&amp;&amp;dfs(A.right,B.left);}</code></pre><p>}</p><h2 id="26-顺时针打印矩阵"><a href="#26-顺时针打印矩阵" class="headerlink" title="26.顺时针打印矩阵"></a>26.顺时针打印矩阵</h2><p>设置标志位,每次打印完判断是否继续</p><p>class Solution {<br>    public int[] spiralOrder(int[][] matrix) {<br>        if(matrix==null||matrix.length==0||matrix[0].length==0) return new int[0];<br>        int m = matrix.length;<br>        int n = matrix[0].length;<br>        int[] res = new int[m*n];<br>        int index=0;<br>        //设置四个标志位<br>        int up=0,down=matrix.length-1;<br>        int left=0,right=matrix[0].length-1;<br>        while(left&lt;=right&amp;&amp;up&lt;=down){<br>            //先从左往右<br>            for(int i=left;i&lt;=right;i++){<br>                res[index++]=matrix[up][i];<br>            }<br>            //判断是否继续从上往下<br>            if(++up&gt;down) break;</p><pre><code>        //从上而下        for(int i=up;i&lt;=down;i++){            res[index++]=matrix[i][right];        }        if(--right&lt;left) break;        //从右往左        for(int i=right;i&gt;=left;i--){            res[index++]=matrix[down][i];        }        if(--down&lt;up) break;        //从下往上        for(int i=down;i&gt;=up;i--){            res[index++]=matrix[i][left];        }        if(++left&gt;right) break;    }    return res;}</code></pre><p>}</p><h2 id="27-包含min函数的栈"><a href="#27-包含min函数的栈" class="headerlink" title="27.包含min函数的栈"></a>27.包含min函数的栈</h2><p>class MinStack {</p><pre><code>//利用两个堆栈//一个正常存，一个存当前最小元素/** initialize your data structure here. */Stack&lt;Integer&gt; A;Stack&lt;Integer&gt; B;public MinStack() {    A=new Stack&lt;&gt;();    B=new Stack&lt;&gt;();}public void push(int x) {    //如果B空或者B当前peek不是最小值，把x加到B中    if(B.isEmpty()||B.peek()&gt;=x) B.push(x);    A.push(x);}public void pop() {    //如果B不空且A当前弹出的就是最小值，则B也要弹出    if(!B.isEmpty()&amp;&amp;B.peek().equals(A.peek())) B.pop();    A.pop();}public int top() {    return A.peek();}public int min() {    return B.peek();}</code></pre><p>}</p><h2 id="28-栈的压入、弹出序列"><a href="#28-栈的压入、弹出序列" class="headerlink" title="28.栈的压入、弹出序列"></a>28.栈的压入、弹出序列</h2><p>class Solution {<br>    public boolean validateStackSequences(int[] pushed, int[] popped) {<br>        //用LinkedList模拟实现<br>        LinkedList<integer> q = new LinkedList&lt;&gt;();<br>        int index=0;<br>        for(int p:pushed){<br>            //模拟入栈<br>            q.add(p);<br>            //模拟出栈<br>            //如果popped还有且当前栈顶就是要弹出的值，一直弹出<br>            if(q.size()&gt;0&amp;&amp;index&lt;popped.length&amp;&amp;popped[index]==q.get(q.size()-1)){<br>                while(q.size()&gt;0&amp;&amp;index&lt;popped.length&amp;&amp;popped[index]==q.get(q.size()-1)){<br>                    q.remove(q.size()-1);<br>                    index++;<br>                }<br>            }<br>        }<br>        return q.size()==0;<br>    }<br>}</integer></p><h2 id="29-从上到下打印二叉树"><a href="#29-从上到下打印二叉树" class="headerlink" title="29.从上到下打印二叉树"></a>29.从上到下打印二叉树</h2><p>利用队列层序遍历</p><p>class Solution {<br>    public int[] levelOrder(TreeNode root) {<br>        if(root==null) return new int[0];<br>        //按顺序存进队列，先进先出<br>        //从头拉出来的顺序就是层序遍历<br>        LinkedList<treenode> q = new LinkedList&lt;&gt;();<br>        ArrayList<integer> ans = new ArrayList&lt;&gt;();<br>        q.add(root);<br>        while(!q.isEmpty()){<br>            TreeNode r = q.poll();<br>            ans.add(r.val);<br>            if(r.left!=null) q.add(r.left);<br>            if(r.right!=null) q.add(r.right);</integer></treenode></p><pre><code>    }    int[] res = new int[ans.size()];    for(int i=0;i&lt;ans.size();i++){        res[i]=ans.get(i);    }    return res;}</code></pre><p>}</p><h2 id="30-从上到下分层打印二叉树"><a href="#30-从上到下分层打印二叉树" class="headerlink" title="30.从上到下分层打印二叉树"></a>30.从上到下分层打印二叉树</h2><p>同样利用队列</p><p>class Solution {<br>    public List&lt;List<integer>&gt; levelOrder(TreeNode root) {<br>        //同样利用队列<br>        //但要在每一层遍历一次<br>        List&lt;List<integer>&gt; res = new ArrayList&lt;&gt;();</integer></integer></p><pre><code>    if(root==null) return res;    LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.add(root);    while(!q.isEmpty()){        int size = q.size();        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();        for(int i=0;i&lt;size;i++){            TreeNode r = q.poll();            temp.add(r.val);            if(r.left!=null) q.add(r.left);            if(r.right!=null) q.add(r.right);        }        res.add(temp);    }     return res;}</code></pre><p>}</p><h2 id="31-从上到下之字形打印二叉树"><a href="#31-从上到下之字形打印二叉树" class="headerlink" title="31.从上到下之字形打印二叉树"></a>31.从上到下之字形打印二叉树</h2><p>count计数判断奇偶层</p><p>class Solution {<br>    public List&lt;List<integer>&gt; levelOrder(TreeNode root) {<br>        List&lt;List<integer>&gt; res = new ArrayList&lt;&gt;();<br>        if(root==null) return res;<br>        //利用队列存节点<br>        //每层遍历一次<br>        //设置count计数，偶数层从前往后，奇数层从后往前</integer></integer></p><pre><code>    LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.add(root);    int count=0;    while(!q.isEmpty()){        int size=q.size();        LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();        for(int i=0;i&lt;size;i++){            TreeNode r = q.poll();            if(r.left!=null) q.add(r.left);            if(r.right!=null) q.add(r.right);            if(count%2==0) temp.add(r.val);            if(count%2==1) temp.addFirst(r.val);        }        count++;        res.add(temp);    }    return res;}</code></pre><p>}</p><h2 id="32-二叉搜索树的后序遍历序列"><a href="#32-二叉搜索树的后序遍历序列" class="headerlink" title="32.二叉搜索树的后序遍历序列"></a>32.二叉搜索树的后序遍历序列</h2><p>class Solution {<br>    public boolean verifyPostorder(int[] postorder) {<br>        //二叉搜索树：左&lt;根&lt;右<br>        //后序遍历： 左右根<br>        //递归<br>        return dfs(postorder,0,postorder.length-1);<br>    }</p><pre><code>//判断这一段是否满足规律boolean dfs(int[] p,int start,int end){    if(start&gt;=end) return true;    int l=start;    int root = p[end];    //左边都比根小，找到左右分界点先    while(p[l]&lt;root) l++;    int m = l;    //右边都比根大    while(p[l]&gt;root) l++;    //此时如果l没有顺利到最后，说明不满足规则    if(l!=end) return false;    //递归判断子问题    return dfs(p,start,m-1)&amp;&amp;dfs(p,m,end-1);}</code></pre><p>}</p><h2 id="33-二叉树中和为某一值的路径"><a href="#33-二叉树中和为某一值的路径" class="headerlink" title="33.二叉树中和为某一值的路径"></a>33.二叉树中和为某一值的路径</h2><p>深度优先搜索,每层减一次值<br>回溯</p><p>class Solution {<br>    LinkedList<integer> path;<br>    List&lt;List<integer>&gt; res;<br>    int T;<br>    public List&lt;List<integer>&gt; pathSum(TreeNode root, int target) {<br>        path = new LinkedList&lt;&gt;();<br>        res = new ArrayList&lt;&gt;();<br>        T = target;</integer></integer></integer></p><pre><code>    dfs(root);    return res;}void dfs(TreeNode r){    if(r==null) return;    T -= r.val;    path.add(r.val);    //添加得出的解    if(T==0&amp;&amp;r.right==null&amp;&amp;r.left==null){        res.add(new LinkedList(path));    }            dfs(r.left);    dfs(r.right);    //回溯    path.removeLast();    T += r.val;}</code></pre><p>}</p><h2 id="34-复杂链表的复制"><a href="#34-复杂链表的复制" class="headerlink" title="34.复杂链表的复制"></a>34.复杂链表的复制</h2><p>class Solution {<br>    public Node copyRandomList(Node head) {<br>        if(head==null) return null;<br>        //1.复制成11<code>22</code>33`<br>        copy(head);<br>        //2.复制random的链<br>        random(head);<br>        //3.分离<br>        return divide(head);<br>    }</p><pre><code>void copy(Node head){    Node clone = head;    while(head!=null){        clone = new Node(head.val);        clone.next = head.next;        head.next = clone;        head = clone.next;    }}void random(Node head){    //clone.random=head.random.next    Node clone = null;    while(head!=null){        clone = head.next;        if(head.random!=null){            clone.random = head.random.next;        }        head = clone.next;    }}Node divide(Node head){    Node dummy = head.next;    Node clone = dummy;    head.next=clone.next;    head = head.next;    while(head!=null){        clone.next=head.next;        clone=head.next;        head.next=clone.next;        head=clone.next;    }    return dummy;}</code></pre><p>}</p><h2 id="35-二叉搜索树与双向链表"><a href="#35-二叉搜索树与双向链表" class="headerlink" title="35.二叉搜索树与双向链表"></a>35.二叉搜索树与双向链表</h2><p>中序遍历</p><p>class Solution {<br>    ArrayList<node> res;<br>    public Node treeToDoublyList(Node root) {<br>        if(root==null) return null;<br>        //二叉搜索树：左&lt;根&lt;右<br>        //因此中序遍历是递增的,按中序遍历构造节点即可<br>        res = new ArrayList&lt;&gt;();<br>        dfs(root);<br>        int s = res.size();<br>        Node dummy = res.get(0);</node></p><pre><code>    Node pre = res.get(s-1);    for(int i=0;i&lt;s;i++){        Node cur = res.get(i);        cur.left=pre;        pre.right=cur;        pre = cur;    }    return dummy;}void dfs(Node r){    if(r==null) return;    dfs(r.left);    res.add(r);    dfs(r.right);}</code></pre><p>}</p><h2 id="36-序列化二叉树"><a href="#36-序列化二叉树" class="headerlink" title="36.序列化二叉树"></a>36.序列化二叉树</h2><p>public class Codec {</p><pre><code>// Encodes a tree to a single string.public String serialize(TreeNode root) {    //判空     if(root==null) return null;    LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    q.add(root);    StringBuilder strb = new StringBuilder("[");    //层序遍历,空值补上null    while(!q.isEmpty()){        TreeNode r = q.poll();        if(r!=null) {            strb.append(r.val+",");            q.add(r.left);            q.add(r.right);        }        else strb.append("null,");    }    //删除最后一个 ，    strb.deleteCharAt(strb.length()-1);    strb.append("]");    return strb.toString();}// Decodes your encoded data to tree.public TreeNode deserialize(String data) {    //判空    if(data==null||data.length()==0) return null;    LinkedList&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();    String[] str = data.substring(1,data.length()-1).split(",");    TreeNode root = new TreeNode(Integer.valueOf(str[0]));    q.add(root);    int index = 1;    while(!q.isEmpty()){        TreeNode r = q.poll();        //先重建左节点        if(!str[index].equals("null")){            r.left = new TreeNode(Integer.valueOf(str[index]));            q.add(r.left);        }        index++;        //再重建右节点        if(!str[index].equals("null")){            r.right = new TreeNode(Integer.valueOf(str[index]));            q.add(r.right);        }        index++;    }    return root;}</code></pre><p>}</p><h2 id="37-字符串的排列"><a href="#37-字符串的排列" class="headerlink" title="37.字符串的排列"></a>37.字符串的排列</h2><p>全排列</p><p>class Solution {<br>    //hash存放去重的结果<br>    HashSet<string> hash;<br>    boolean[] visited;<br>    public String[] permutation(String s) {<br>        hash = new HashSet&lt;&gt;();<br>        char[] ch = s.toCharArray();<br>        visited = new boolean[ch.length];</string></p><pre><code>    dfs(ch,"");    String[] res = new String[hash.size()];    Iterator it = hash.iterator();    int i = 0;    while(it.hasNext()){        res[i++] = it.next().toString();    }    return res;}//ch：字符数组 ans：已经拼接的答案void dfs(char[] ch,String ans){    if(ans.length()==ch.length){        hash.add(ans);        return;    }    for(int i=0;i&lt;ch.length;i++){        if(!visited[i]){            visited[i] = true;            dfs(ch,ans+ch[i]);            //回溯            visited[i] = false;        }    }} </code></pre><p>}</p><h2 id="38-数组中出现次数超过一半的数字"><a href="#38-数组中出现次数超过一半的数字" class="headerlink" title="38.数组中出现次数超过一半的数字"></a>38.数组中出现次数超过一半的数字</h2><p>候选者法<br>手上拿着可能的数，下一个一样的就留着，不一样就从手上减掉一个</p><p>class Solution {<br>    public int majorityElement(int[] nums) {<br>        //候选者法<br>        int count = 1;<br>        int pos = nums[0];</p><pre><code>    for(int i=1;i&lt;nums.length;i++){        //count==0说明手上没有候选，把当前元素加入候选        if(count==0){            pos = nums[i];            count = 1;        }        //count&gt;=1说明目前有        else if(count &gt;=1){            if(pos == nums[i]){                count++;            }else{                count--;            }        }    }    //最后再验证一下    count=0;    for(int n : nums){        if(n==pos) count++;    }    return count&gt;nums.length/2?pos:-1;}</code></pre><p>}</p><h2 id="39-最小的k个数"><a href="#39-最小的k个数" class="headerlink" title="39.最小的k个数"></a>39.最小的k个数</h2><p>排序+遍历</p><p>class Solution {<br>    public int[] getLeastNumbers(int[] arr, int k) {<br>        Arrays.sort(arr);<br>        int[] res = new int[k];<br>        for(int i=0;i&lt;k;i++){<br>            res[i] = arr[i];<br>        }<br>        return res;<br>    }<br>}</p><h2 id="40-数据流中的中位数"><a href="#40-数据流中的中位数" class="headerlink" title="40.数据流中的中位数"></a>40.数据流中的中位数</h2><p>利用大根堆和小根堆</p><p>class MedianFinder {<br>    //大根堆堆顶最大，存小的一部分数<br>    //小根堆堆顶最小，存小的一部分数<br>    PriorityQueue<integer> A;<br>    PriorityQueue<integer> B;<br>    public MedianFinder() {<br>        //大根堆<br>        A = new PriorityQueue&lt;&gt;((x,y)-&gt;(y-x));<br>        //小根堆<br>        B = new PriorityQueue&lt;&gt;();<br>    }<br>    public void addNum(int num) {<br>        //两个队轮流存，<br>        //第一轮先存进大根堆<br>        //大根堆存小数，先放进小根堆比一下再弹进大根堆<br>        if(A.size()==B.size()){<br>            B.add(num);<br>            A.add(B.poll());<br>        }else{<br>            A.add(num);<br>            B.add(A.poll());<br>        }<br>    }</integer></integer></p><pre><code>public double findMedian() {    //如果两个堆一样大中位数就是堆顶的中位数    //如果不相等，就是A的堆顶    return A.size()==B.size()?(A.peek()+B.peek())/2.0:A.peek()/1.0;}</code></pre><p>}</p><h2 id="41-连续子数组的最大和"><a href="#41-连续子数组的最大和" class="headerlink" title="41.连续子数组的最大和"></a>41.连续子数组的最大和</h2><p>动态规划<br>利用nums[i]存i之前的最大和</p><p>class Solution {<br>    public int maxSubArray(int[] nums) {<br>        if(nums==null||nums.length==0) return 0;<br>        //动态规划<br>        //利用nums[i]来表示前面的最大和<br>        int res = nums[0];<br>        for(int i=1;i&lt;nums.length;i++){<br>            //dp[i-1]和0比较，大于0就加上，小于0就不用加进解里<br>            nums[i] += Math.max(nums[i-1],0);<br>            res = Math.max(nums[i],res);<br>        }<br>        return res;<br>    }<br>}</p><h2 id="42-1-n整数中1出现的次数"><a href="#42-1-n整数中1出现的次数" class="headerlink" title="42.1~n整数中1出现的次数"></a>42.1~n整数中1出现的次数</h2><p>设置3个标志位 high cur low, cur从个位开始左移</p><p>class Solution {<br>    public int countDigitOne(int n) {<br>        //设置3个标志位<br>        //high cur low<br>        //遍历：cur从个位移到最高位<br>        //cur在十位上时：cur上的1一共出现了多少次<br>        //cur=0  45 0 5  00 1 0<del>44 1 9 一共450个 = high*10<br>        //cur=1  45 1 5  00 1 0</del>45 1 5 一共456个 = high<em>10+low+1<br>        //cur=2  45 2 5  00 1 0~45 1 9 一共460个 = (high+1)</em>10</p><pre><code>    //公式一样，从个位开始遍历    int high = n/10,cur=n%10,low=0;    int x=1;    int count = 0;    while(high!=0||cur!=0){        if(cur==0){            count += high*x;}        else if(cur==1){            count += high*x+low+1;}        else {            count += (high+1)*x;}        //标志位左移        low += x*cur;        cur = high%10;        high /=10;        x *=10;    }     return count;}</code></pre><p>}</p><h2 id="43-数字序列中某一位数字"><a href="#43-数字序列中某一位数字" class="headerlink" title="43.数字序列中某一位数字"></a>43.数字序列中某一位数字</h2><p>class Solution {<br>    public int findNthDigit(int n) {<br>        //1. 确定在几位数里<br>        //0-9     9个数字<br>        //10-99   10<em>9</em>2个数字<br>        //100-999 100<em>9</em>3个数字<br>        int digit = 1;<br>        long start = 1;<br>        long count = 9;<br>        while(n&gt;count){<br>            n -= count;<br>            digit++;<br>            start <em>= 10;<br>            count = start</em>digit*9;<br>        }<br>        //2. 确定在那个数字里<br>        //start+(n-1)/digit<br>        long num = start+(n-1)/digit;</p><pre><code>    //3. 确定数字    //在num的第(n-1)%digit位    return Long.toString(num).charAt((n-1)%digit)-'0';}</code></pre><p>}</p><h2 id="44-把数组排成最小的数"><a href="#44-把数组排成最小的数" class="headerlink" title="44.把数组排成最小的数"></a>44.把数组排成最小的数</h2><p>重写快排, 排在前面更小的就往前换,排在后面更小的就往后换</p><p>class Solution {<br>    public String minNumber(int[] nums) {<br>        //重写快排，对字符串用compareTo比较，拼接起来小的就往前放<br>        //1. 把int[]换成String[]<br>        int len = nums.length;<br>        String[] strs = new String[len];<br>        for(int i=0;i&lt;len;i++){<br>            strs[i] = String.valueOf(nums[i]);<br>        }<br>        //快排<br>        QuickSort(strs,0,len-1);</p><pre><code>    StringBuilder res = new StringBuilder();    for(String s:strs){        res.append(s);    }    return res.toString();}void QuickSort(String[] s,int start,int end){    if(start&gt;=end) return;    int l = start,r = end;    String p = s[start];    while(l&lt;r){        while(l&lt;r&amp;&amp;(p+s[r]).compareTo(s[r]+p)&lt;=0) r--;        while(l&lt;r&amp;&amp;(s[l]+p).compareTo(p+s[l])&lt;=0) l++;        if(l&lt;r){            String temp = s[l];            s[l] = s[r];            s[r] = temp;        }    }    s[start] = s[r];    s[r] = p;    QuickSort(s,start,r);    QuickSort(s,r+1,end);}</code></pre><p>}</p><h2 id="45-把数字翻译成字符串"><a href="#45-把数字翻译成字符串" class="headerlink" title="45.把数字翻译成字符串"></a>45.把数字翻译成字符串</h2><p>动态规划<br>[i-2][i-1]如果在0~25之间,则这两个数字有两种翻译 dp[i]=dp[i-1]+dp[i-2]<br>否则只有一种翻译 dp[i] = dp[i-1]</p><p>class Solution {<br>    public int translateNum(int num) {<br>        //动态规划<br>        //dp[i] 前i个一共有多少种翻译<br>        //如果str(i-2)str(i-1)在10-25之间 则可以分开翻译也可以合并翻译 dp[i] = dp[i-1]+dp[i-2]<br>        //否则 只能分开翻译 dp[i] = dp[i-1]<br>        String str = String.valueOf(num);<br>        int n = str.length();<br>        int[] dp = new int[n+1];</p><pre><code>    //初始化    dp[0] = 1;    dp[1] = 1;    for(int i=2;i&lt;=n;i++){        String temp = str.substring(i-2,i);        if(temp.compareTo("10")&gt;=0&amp;&amp;temp.compareTo("25")&lt;=0) dp[i] = dp[i-1]+dp[i-2];        else dp[i]=dp[i-1];    }    return dp[n];}</code></pre><p>}</p><h2 id="46-礼物的最大值"><a href="#46-礼物的最大值" class="headerlink" title="46.礼物的最大值"></a>46.礼物的最大值</h2><p>经典二维动态规划</p><p>class Solution {<br>    public int maxValue(int[][] grid) {<br>        //经典二维动态规划<br>        //f[i][j] = f[i][j]+max(f[i-1][j],f[i][j-1])</p><pre><code>    int m = grid.length,n=grid[0].length;    for(int i=0;i&lt;m;i++){        for(int j=0;j&lt;n;j++){            //初始化边界            if(i==0&amp;&amp;j==0) continue;            else if(i==0) grid[i][j] += grid[i][j-1];            else if(j==0) grid[i][j] += grid[i-1][j];            //更新            else grid[i][j] += Math.max(grid[i-1][j],grid[i][j-1]);        }    }    return grid[m-1][n-1];}</code></pre><p>}</p><h2 id="47-最长不含重复字符的子字符串"><a href="#47-最长不含重复字符的子字符串" class="headerlink" title="47.最长不含重复字符的子字符串"></a>47.最长不含重复字符的子字符串</h2><p>class Solution {<br>    public int lengthOfLongestSubstring(String s) {<br>        //hashMap存字符和最后出现的索引</p><pre><code>    HashMap&lt;Character,Integer&gt; hash = new HashMap&lt;&gt;();    //不重复字符串的起点    int left = 0;    int res = 0;    for(int i=0;i&lt;s.length();i++){        char c = s.charAt(i);        //如果c重复了，当前字符串就不满足要求了，重选起点        //新left = 当前重复字符上一次出现的位置后一个索引和旧left的大者        if(hash.containsKey(c)) left = Math.max(left,hash.get(c)+1);        hash.put(c,i);        res = Math.max(res,i-left+1);    }    return res;}</code></pre><p>}</p><h2 id="48-丑数"><a href="#48-丑数" class="headerlink" title="48.丑数"></a>48.丑数</h2><p>class Solution {<br>    public int nthUglyNumber(int n) {<br>        //丑数=前面某一个丑数乘上2，3或5得到的<br>        //设置一个数组记录前面与2，3，5相乘的索引<br>        //每次从乘上2，3，5后的三个备选数里选最小的</p><pre><code>    int[] pos = new int[3];    int[] res = new int[n];    res[0] = 1;    for(int i=1;i&lt;n;i++){        //三个备选数        int a = res[pos[0]]*2;        int b = res[pos[1]]*3;        int c = res[pos[2]]*5;        int min = Math.min(Math.min(a,b),c);        res[i] = min;        //重复的要跳掉        if(a==min) pos[0]++;        if(b==min) pos[1]++;        if(c==min) pos[2]++;    }    return res[n-1];}</code></pre><p>}</p><h2 id="49-第一个只出现一次的字符"><a href="#49-第一个只出现一次的字符" class="headerlink" title="49.第一个只出现一次的字符"></a>49.第一个只出现一次的字符</h2><p>class Solution {<br>    //hashmap存储是否重复</p><pre><code>public char firstUniqChar(String s) {    char[] ch = s.toCharArray();    HashMap&lt;Character,Boolean&gt; hash = new HashMap&lt;&gt;();    for(char c:ch){        hash.put(c,!hash.containsKey(c));    }    for(char c:ch){        if(hash.get(c)) return c;    }    return ' ';}</code></pre><p>}</p><h2 id="50-数组中的逆序对"><a href="#50-数组中的逆序对" class="headerlink" title="50.数组中的逆序对"></a>50.数组中的逆序对</h2><p>重写归并排序</p><p>class Solution {<br>    int[] temp;<br>    public int reversePairs(int[] nums) {<br>        //重写归并算法<br>        //一路二分，最后归并<br>        if(nums==null||nums.length&lt;=0) return 0;<br>        temp = new int[nums.length];</p><pre><code>    return mergeSort(nums,0,nums.length-1);}int mergeSort(int[] nums,int start,int end){    if(start&gt;=end) return 0;    int l = start,r = end;    //一路二分    int mid = l+(r-l)/2;    int leftc = mergeSort(nums,start,mid);    int rightc = mergeSort(nums,mid+1,end);    //归并    int cross = merge(nums,start,mid,end);    return cross+leftc+rightc;}int merge(int[] nums,int start,int mid,int end){    //先存进临时数组    for(int i=start;i&lt;=end;i++){        temp[i] = nums[i];    }    int l=start,r=mid+1;    int count = 0;    for(int index=start;index&lt;=end;index++){        //如果temp[l]的值比temp[r]大的话，l后面的都比它大，        //这就存在mid-l+1个逆序对        if(l&gt;mid){            nums[index] = temp[r++];        }        else if(r&gt;end){            nums[index] = temp[l++];        }        else if(temp[l]&gt;temp[r]){            nums[index] = temp[r++];            count+=(mid-l+1);        }else{            nums[index] = temp[l++];        }    }    return count;}</code></pre><p>}</p><h2 id="51-两个链表的第一个公共节点"><a href="#51-两个链表的第一个公共节点" class="headerlink" title="51.两个链表的第一个公共节点"></a>51.两个链表的第一个公共节点</h2><p>双指针<br>p1走完A再走B，p2走完B再走A，相遇的就是公共点<br>public class Solution {<br>    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {<br>        if(headA==null|headB==null) return null;<br>        ListNode p1 = headA;<br>        ListNode p2 = headB;</p><pre><code>    while(p1!=p2){        p1 = p1 == null?headB:p1.next;        p2 = p2 == null?headA:p2.next;    }    return p1;}</code></pre><p>}</p><h2 id="52-在排序数组中查找数字"><a href="#52-在排序数组中查找数字" class="headerlink" title="52.在排序数组中查找数字"></a>52.在排序数组中查找数字</h2><p>统计一个数字在排序数组中出现的次数</p><p>class Solution {<br>    public int search(int[] nums, int target) {<br>        //二分法找临界点<br>        int l = 0,r = nums.length;<br>        //先找左边界<br>        //左边都比target小<br>        while(l&lt;r){<br>            int mid = l+(r-l)/2;<br>            if(nums[mid]&lt;target) l=mid+1;<br>            if(nums[mid]&gt;=target) r=mid;</p><pre><code>    }    int left = l;    //再找右边界    //右边都比target大    l = 0;    r = nums.length;    while(l&lt;r){        int mid = l+(r-l)/2;        if(nums[mid]&lt;=target) l=mid+1;        if(nums[mid]&gt;target) r =mid;    }    return r-left;}</code></pre><p>}</p><h2 id="53-0-n-1中缺失的数字"><a href="#53-0-n-1中缺失的数字" class="headerlink" title="53.0~n-1中缺失的数字"></a>53.0~n-1中缺失的数字</h2><p>二分</p><p>class Solution {<br>    public int missingNumber(int[] nums) {<br>        //二分<br>        int l=0,r=nums.length;<br>        int mid = 0;<br>        while(l&lt;r){<br>            mid = l+(r-l)/2;<br>            if(mid==nums[mid]) l=mid+1;<br>            else r = mid;<br>        }<br>        return l;<br>    }<br>}</p><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.二叉搜索树的第k大节点</h2><p>左&lt;中&lt;右 中序遍历即为递增</p><p>class Solution {<br>    int res;<br>    int t;<br>    public int kthLargest(TreeNode root, int k) {</p><pre><code>    //二叉搜索树: 左&lt;中&lt;右    //所以中序遍历是递增的,反过来遍历    t=k;    dfs(root);    return res;}void dfs(TreeNode r){    if(r==null) return ;    dfs(r.right);    t--;    if(t==0){        res = r.val;    }    dfs(r.left);}</code></pre><p>}</p><h2 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h2><p>class Solution {<br>    public int maxDepth(TreeNode root) {<br>        //递归<br>        if(root==null) return 0;</p><pre><code>    return 1+Math.max(maxDepth(root.left),maxDepth(root.right));}</code></pre><p>}</p><h2 id="56-平衡二叉树"><a href="#56-平衡二叉树" class="headerlink" title="56.平衡二叉树"></a>56.平衡二叉树</h2><p>class Solution {<br>    public boolean isBalanced(TreeNode root) {<br>        //利用深度的方法判断平衡<br>        if(root==null) return true;<br>        if(Math.abs(Depth(root.left)-Depth(root.right))&gt;1) return false;</p><pre><code>    return isBalanced(root.left)&amp;&amp;isBalanced(root.right);}int Depth(TreeNode r){    if(r==null) return 0;    return 1+Math.max(Depth(r.left),Depth(r.right));}</code></pre><p>}</p><h2 id="57-数组中数字出现的次数-2次"><a href="#57-数组中数字出现的次数-2次" class="headerlink" title="57.数组中数字出现的次数(2次)"></a>57.数组中数字出现的次数(2次)</h2><p>数组中的数其余都是出现了两次,找出两个只出现了一次的数</p><p>class Solution {<br>    public int[] singleNumbers(int[] nums) {<br>        //利用异或<br>        //最后得到的是res1^res2<br>        //0^A=A  A^A=0<br>        int sum = 0;<br>        for(int n:nums){<br>            sum ^=n;<br>        }</p><pre><code>    //找sum中1的位置即两个解相异的位    int index = 0;    while((sum &gt;&gt; index &amp;1) !=1) index++;    //按此相异的位分成两组异或    int res1 = 0;    for(int n:nums){        if((n &gt;&gt; index&amp;1)==1) res1^=n;    }    int[] res = {res1,sum^res1};    return res;}</code></pre><p>}</p><h2 id="58-数组中数字出现的次数-3次"><a href="#58-数组中数字出现的次数-3次" class="headerlink" title="58.数组中数字出现的次数(3次)"></a>58.数组中数字出现的次数(3次)</h2><p>一个数字出现了1次,其余出现了3次<br>hashMap存数字和出现次数</p><p>class Solution {<br>    public int singleNumber(int[] nums) {<br>        HashMap&lt;Integer,Integer&gt; hash = new HashMap&lt;&gt;();<br>        for(int n:nums){<br>            if(hash.containsKey(n)) hash.put(n,hash.get(n)+1);<br>            else hash.put(n,1);<br>        }</p><pre><code>    for(int n:nums){        if(hash.get(n)==1) return n;    }    return -1;}</code></pre><p>}</p><h2 id="59-和为s的两个数字"><a href="#59-和为s的两个数字" class="headerlink" title="59.和为s的两个数字"></a>59.和为s的两个数字</h2><p>sum=nums[l]+nums[r],向中间移动</p><p>class Solution {<br>    public int[] twoSum(int[] nums, int target) {<br>            //双指针<br>            int l=0,r=nums.length-1;<br>            int sum = nums[l]+nums[r];</p><pre><code>        while(l&lt;r){            sum = nums[l]+nums[r];            if(sum==target){                return new int[] {nums[l],nums[r]};            }            else if(sum&lt;target){                l++;            }else{                r--;            }        }        return null;}</code></pre><p>}</p><h2 id="60-和为s的连续正数序列"><a href="#60-和为s的连续正数序列" class="headerlink" title="60.和为s的连续正数序列"></a>60.和为s的连续正数序列</h2><p>暴力遍历</p><p>class Solution {<br>    public int[][] findContinuousSequence(int target) {<br>        ArrayList&lt;ArrayList<integer>&gt; res = new ArrayList&lt;&gt;();</integer></p><pre><code>    for(int i=1;i&lt;target;i++){        int sum=0;        int j = i;        ArrayList&lt;Integer&gt; temp = new ArrayList&lt;&gt;();         while(sum&lt;target){            sum+=j;            temp.add(j);            if(sum==target){                res.add(temp);            }            j++;        }    }    if(res.size()==0) return new int[0][];    int[][] ans = new int[res.size()][];    for(int i=0;i&lt;res.size();i++){        int s = res.get(i).size();        int[] temp = new int[s];        for(int j=0;j&lt;s;j++){            temp[j] = res.get(i).get(j);        }        ans[i] = temp;    }    return ans;}</code></pre><p>}</p><h2 id="61-翻转单词的顺序"><a href="#61-翻转单词的顺序" class="headerlink" title="61.翻转单词的顺序"></a>61.翻转单词的顺序</h2><p>class Solution {<br>    public String reverseWords(String s) {<br>        String[] ss = s.trim().split(“ “);<br>        if(ss==null||ss.length==0) return “”;<br>        StringBuilder res = new StringBuilder();<br>        for(int i=ss.length-1;i&gt;0;i–){<br>            //“s  ss” split出来的是”s” “” “ss” 要判断中间的””<br>            if(ss[i].equals(“”)) continue;<br>            res.append(ss[i]);<br>            res.append(“ “);<br>        }</p><pre><code>    res.append(ss[0]);    return res.toString();}</code></pre><p>}</p><h2 id="62-左旋转字符串"><a href="#62-左旋转字符串" class="headerlink" title="62.左旋转字符串"></a>62.左旋转字符串</h2><p>class Solution {<br>    public String reverseLeftWords(String s, int n) {<br>        if(n&gt;=s.length()) return s;<br>        //左开右闭<br>        return s.substring(n,s.length())+s.substring(0,n);<br>    }<br>}</p><h2 id="63-滑动窗口的最大值"><a href="#63-滑动窗口的最大值" class="headerlink" title="63.滑动窗口的最大值"></a>63.滑动窗口的最大值</h2><p>采用双端队列，队列中的头节点保存的数据比后面的要大。<br>比如当前假如的数据比队尾的数字大，说明当前这个数字最起码在从现在起到后面的过程中可能是最大值，而之前队尾的数字不可能最大了，所以要删除队尾元素。<br>此外，还要判断队头的元素是否超过size长度，由于存储的是下标，所以可以计算得到；特别说明，我们在双端队列中保存的数字是传入的向量的下标；</p><p>class Solution {<br>    public int[] maxSlidingWindow(int[] nums, int k) {<br>        //LinkedList 用作队列<br>        LinkedList<integer> deque = new LinkedList&lt;&gt;();</integer></p><pre><code>    //先判断窗口可不可行    if(k&lt;=0||k&gt;nums.length) return new int[0];    int[] res = new int[nums.length - k + 1];    // 未形成窗口    for(int i = 0; i &lt; k; i++) {        while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])            deque.removeLast();        deque.addLast(nums[i]);    }    res[0] = deque.peekFirst();    // 形成窗口后    for(int i = k; i &lt; nums.length; i++) {        if(deque.peekFirst() == nums[i - k])            deque.removeFirst();        while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])            deque.removeLast();        deque.addLast(nums[i]);        res[i - k + 1] = deque.peekFirst();    }    return res;}</code></pre><p>}</p><h2 id="64-队列的最大值"><a href="#64-队列的最大值" class="headerlink" title="64.队列的最大值"></a>64.队列的最大值</h2><p>窗口不滑动</p><p>class MaxQueue {<br>    //队列常规存取<br>    LinkedList<integer> que;<br>    //双端队列维护最大值<br>    LinkedList<integer> deq;<br>    public MaxQueue() {<br>        que = new LinkedList<integer>();<br>        deq = new LinkedList<integer>();<br>    }</integer></integer></integer></integer></p><pre><code>public int max_value() {    //deq队首即为最大值    return deq.size()==0?-1:deq.peekFirst();}public void push_back(int value) {    //que正常存取    que.add(value);    //存入算法与滑动窗口最大值相同    //只是窗口就是整个队列    while(!deq.isEmpty()&amp;&amp;deq.peekLast()&lt;value){        deq.removeLast();    }    deq.add(value);}public int pop_front() {    int v = que.size()&gt;0?que.poll():-1;    if(deq.size()&gt;0&amp;&amp;v==deq.peekFirst()) deq.poll();    return v;}</code></pre><p>}</p><h2 id="65-n个骰子的点数"><a href="#65-n个骰子的点数" class="headerlink" title="65.n个骰子的点数"></a>65.n个骰子的点数</h2><p>动态规划 dp[i][j]表示 i个骰子投出j点的次数</p><p>class Solution {<br>    public double[] dicesProbability(int n) {<br>        //n个骰子，有n~6n种点数 解的长度为6n-n+1<br>        //总数是6^n次<br>        //概率=dp[i][j]/6^n<br>        //dp[i][j]表示 i个骰子投出j点的次数<br>        double all = Math.pow(6,n);</p><pre><code>    //动态规划    double[] res = new double[5*n+1];    int[][] dp = new int[n+1][6*n+1];    //初始化    dp[0][0] = 1;    //遍历更新    //n个骰子    for(int i=1;i&lt;=n;i++){        //n~6n种点数        for(int j=1;j&lt;=6*n;j++){            //最后一投1~6            for(int k = 1;k&lt;=Math.min(j,6);k++){                dp[i][j] += dp[i-1][j-k];            }        }    }     for(int i=n;i&lt;=6*n;i++){        res[i-n] = dp[n][i]/all;    }    return res;}</code></pre><p>}</p><h2 id="66-扑克牌中的顺子"><a href="#66-扑克牌中的顺子" class="headerlink" title="66.扑克牌中的顺子"></a>66.扑克牌中的顺子</h2><p>class Solution {<br>    public boolean isStraight(int[] nums) {<br>        //1. 先排序<br>        Arrays.sort(nums);<br>        //2. 去掉0<br>        int l=0,r=nums.length;<br>        while(nums[l]==0) l++;<br>        //3. 有重复的指定不是<br>        for(int i=l;i&lt;r-1;i++){<br>            if(nums[i]==nums[i+1]) return false;<br>        }<br>        //4. 再次前提下，只要max-min&lt;=4 必是顺子<br>        return nums[r-1]-nums[l]&lt;=4;</p><pre><code>}</code></pre><p>}</p><h2 id="67-圆圈中最后剩下的数字"><a href="#67-圆圈中最后剩下的数字" class="headerlink" title="67.圆圈中最后剩下的数字"></a>67.圆圈中最后剩下的数字</h2><p>约瑟夫环</p><p>class Solution {<br>    public int lastRemaining(int n, int m) {<br>        //n    0,1,2,…,m-2, m,m+1,m+2,…n<br>        //n-1                 0,1,2,…n-m<br>        //n个数字，删掉一个后，n-1个数字的结果是同一个<br>        //但重新编号 存在对应的映射<br>        //f(n)=(f(n-1)+m)%n</p><pre><code>    if(n==0) return 0;    return (lastRemaining(n-1,m)+m)%n;}</code></pre><p>}</p><h2 id="68-股票的最大利润"><a href="#68-股票的最大利润" class="headerlink" title="68.股票的最大利润"></a>68.股票的最大利润</h2><p>class Solution {<br>    public int maxProfit(int[] prices) {<br>        if(prices==null||prices.length==0) return 0;<br>        int res = 0;<br>        //i前的最小价格<br>        int minv = prices[0];<br>        for(int i=0;i&lt;prices.length;i++){<br>            res = Math.max(res,prices[i]-minv);<br>            //更新i前的最小值<br>            minv = Math.min(minv,prices[i]);<br>        }<br>        return res;<br>    }<br>}</p><h2 id="69-求1-2-3-…-n"><a href="#69-求1-2-3-…-n" class="headerlink" title="69.求1+2+3+…+n"></a>69.求1+2+3+…+n</h2><p>不用乘除法,for循环等等</p><p>用try catch 实现判断</p><p>class Solution {<br>    int [] a = new int[1];<br>    public int sumNums(int n) {<br>        //利用trycatch实现判断<br>        try{<br>            a[n] =0;</p><pre><code>    }catch(Exception e){        return n+sumNums(n-1);    }    return 0;}</code></pre><p>}</p><h2 id="70-不用加减乘除做加法"><a href="#70-不用加减乘除做加法" class="headerlink" title="70.不用加减乘除做加法"></a>70.不用加减乘除做加法</h2><p>class Solution {<br>    public int add(int a, int b) {<br>        //运用逻辑运算<br>        //异或算非进位上的和<br>        //相与再左移一位算进位的和<br>        //用b来存进位和<br>        while(b!=0){<br>            int c = a^b;<br>            b = a&amp;b;<br>            b &lt;&lt;=1;<br>            a = c;<br>        }</p><pre><code>    return a;}</code></pre><p>}</p><h2 id="71-构建乘积数组"><a href="#71-构建乘积数组" class="headerlink" title="71.构建乘积数组"></a>71.构建乘积数组</h2><p>class Solution {<br>    public int[] constructArr(int[] a) {<br>        //两边分别乘好，再相乘<br>        int n=a.length;<br>        int[] b = new int[n];<br>        int p = 1;<br>        for(int i=0;i&lt;n;i++){<br>            b[i] = p; //b[0] = 1  ,b[1] = a[0], b[2] = a[0]*a[1] 都是前半部分<br>            p *=a[i];<br>        }</p><pre><code>    p = 1;    //再循环乘一波后半部分    for(int i = n-1;i&gt;=0;i--){        b[i] *=p; //b[n-1] = b[n-1]*1 b[n-2] = b[n-2]*a[n-1]从后往前乘上后半部分        p*=a[i];    }    return b;}</code></pre><p>}</p><h2 id="72-把字符串转换成整数"><a href="#72-把字符串转换成整数" class="headerlink" title="72.把字符串转换成整数"></a>72.把字符串转换成整数</h2><p>class Solution {<br>    public int strToInt(String str) {<br>        char[] ch = str.trim().toCharArray();<br>        if(ch==null||ch.length==0) return 0;<br>        int sign = 1;<br>        int index = 1;<br>        //用于判断最大值<br>        int temp = 214748364;<br>        if(ch[0]==’-‘) sign=-1;<br>        else if(ch[0]!=’+’) index = 0;<br>        int res = 0;<br>        for(int i=index;i&lt;ch.length;i++){<br>            //不是数字，直接返回<br>            if(ch[i]&lt;’0’||ch[i]&gt;’9’) break;<br>            //超过边界，返回最大值<br>            if(res&gt;temp ||(res==temp&amp;&amp;ch[i]&gt;’7’)){<br>                return sign==1?Integer.MAX_VALUE:Integer.MIN_VALUE;<br>            }<br>            //拼接上数字<br>            res = res<em>10+ch[i]-‘0’;<br>        }<br>        return res</em>sign;<br>    }<br>}</p><h2 id="73-二叉搜索树的最近公共祖先"><a href="#73-二叉搜索树的最近公共祖先" class="headerlink" title="73.二叉搜索树的最近公共祖先"></a>73.二叉搜索树的最近公共祖先</h2><p>class Solution {<br>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br>        //二叉搜索树 左&lt;根&lt;右<br>        //递归<br>        //如果p&gt;r且q&gt;r 说明都在r右边 向右搜索<br>        //如果p&lt;r且q&lt;r 说明都在r左边 向左搜索<br>        if(p.val&gt;root.val&amp;&amp;q.val&gt;root.val) return lowestCommonAncestor(root.right,p,q);<br>        if(p.val&lt;root.val&amp;&amp;q.val&lt;root.val) return lowestCommonAncestor(root.left,p,q);<br>        return root;<br>    }<br>}</p><h2 id="74-二叉树的最近公共祖先"><a href="#74-二叉树的最近公共祖先" class="headerlink" title="74.二叉树的最近公共祖先"></a>74.二叉树的最近公共祖先</h2><p>class Solution {<br>    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br>        //递归</p><pre><code>    //向下搜索 如果都在左边说明公共节点在左边 如果都在右边说明公共节点在右边    //递归终止条件：返回null或者找到了p或q    if(root==null||root==p||root==q) return root;    //搜索左边有没有p或q    TreeNode left = lowestCommonAncestor(root.left,p,q);    //搜索右边有没有p或q    TreeNode right = lowestCommonAncestor(root.right,p,q);    //如果left==null 说明都在右边 继续搜索右边    if(left==null) return right;    //如果right==null 说明都在左边 继续搜索左边    if(right==null) return left;    //左右都不为空 说明pq在root的一左一右 此时root即为公共节点    return root;}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>呈呈抽背小专栏</title>
      <link href="/2021/06/02/ji-chu-zheng-li/cheng-cheng-chou-bei-xiao-zhuan-lan/"/>
      <url>/2021/06/02/ji-chu-zheng-li/cheng-cheng-chou-bei-xiao-zhuan-lan/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://raw.githubusercontent.com/sqtian-hhu/images/main/images/friends/5.jpg" alt="冲冲冲"></p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring是一个轻量级的IOC容器和AOP容器框架<br>目的是简化企业应用程序的开发，使开发人员只需关注业务需要本身</p><p>主要包括七个模块：<br>Spring Context：提供框架式的Bean访问方式以及企业级的功能<br>Spring Core：核心类库，所有功能都依赖于该类库，提供IOC和DI服务<br>Spring MVC：提供面向Web应用的Model-view-controller<br>Spring Web：提供基本的面向Web的综合特性<br>Spring AOP：提供AOP服务<br>Spring Dao：对JDBC的抽象封装，简化了数据访问异常的处理，并能统一管理JDBC事务<br>Spring ORM：对现有的ORM框架的支持</p><h3 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h3><ol><li>Spring属于低侵入式框架, 代码污染率较低<br>低侵入式: 去除此框架后, 只需要修改一些配置信息,不需要大量修改代码</li><li>Spring的依赖注入机制将对象之间的依赖关系交由框架处理, 降低了组件的耦合度</li><li>Spring提供了AOP技术, 能够对一些通用任务集中式管理, 从而提供更好的复用</li><li>Spring提供了对主流框架的集成支持</li></ol><h3 id="理解Spring-IOC"><a href="#理解Spring-IOC" class="headerlink" title="理解Spring IOC"></a>理解Spring IOC</h3><p>IOC就是控制反转, 指将创建对象的控制转移给Spring框架来管理, Spring利用Java反射机制, 根据配置文件创建实例并管理实例之间的依赖关系<br>Spring IOC有三种注入方式: 构造器注入, Setter方法注入, 根据注解注入</p><p>DI指依赖注入, 和控制反转是同一个概念的不同角度的描述, 即应用程序在运行时利用IOC容器来动态地注入对象需要的外部依赖<br>*控制的什么反转了? 其实就是获得依赖对象的方式反转了</p><h3 id="理解Spring-AOP"><a href="#理解Spring-AOP" class="headerlink" title="理解Spring AOP"></a>理解Spring AOP</h3><p>OOP指面向对象, 面向对象允许开发者定义纵向的关系, 但不适用于定义横向的关系, 会导致大量代码重复, 不利于各个模块的重用</p><p>AOP指面向切面, 就是对面向对象的一种补充, 用于将那些与业务无关,但对多个对象产生影响的公共行为逻辑抽取封装成一个可重用模块,<br>这个模块就被称为”切面”, 利用切面减少系统中的重复代码, 降低了模块间的耦合度, 提高了系统的可维护性.</p><p>AOP实现的关键在于代理模式, AOP代理主要分为静态代理和动态代理. 静态代理的代表是AspectJ, 动态代理则以Spring AOP为代表</p><ol><li>AspectJ是静态代理, 又称编译时增强. AOP框架会在编译阶段生成AOP代理类, 并将切面织入到Java字节码中,<br>运行时就是增强之后的AOP对象</li><li>Spring AOP是动态代理, AOP框架不会去修改字节码, 而是每次运行时临时为方法生成一个AOP对象,<br>这个AOP对象包含了目标对象的所有方法, 并且在特定的切点做了增强处理.</li></ol><p>Spring AOP代理主要有两种形式: JDK动态代理和CGLIB动态代理</p><ol><li><p>JDK动态代理只提供接口的代理, 不支持类的代理,要求被代理类实现接口.<br>JDK动态代理的核心是InvocationHandler接口和Proxy类, 在获取代理对象时使用Proxy类来动态创建目标类的代理类<br>即最终真正的代理类, 这个类继承自Proxy类并实现了我们定义的接口,当代理对象调用真实对象的方法时,<br>InvocationHandler通过invoke()方法反射来调用目标类中的代码, 动态地将横切逻辑和业务编织在一起</p></li><li><p>如果代理类没有实现接口,那么Spring AOP会选择使用CGLIB来动态代理目标类.<br>CGLIB是一个代码生成的类库, 可以在运行时动态地生成指定类的一个子类对象,<br>并覆盖其中特定方法以及添加增强代码,从而实现AOP<br>CGLIB是用继承的方式做的动态代理, 因此, 如果某个类被标记为final, 那么它无法使用CGLIB做动态代里</p></li></ol><h2 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h2><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。</p><ol><li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</li><li>spring按bean定义信息配置bean的所有属性</li><li>检查Aware相关接口并设置相关依赖:<br>(如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法<br> 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入<br> 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。)</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法进行前置处理。</li><li>如果Bean实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，</li><li>如果bean使用init-method声明了初始化方法，该方法也会被调用</li><li>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法进行后置处理。</li><li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直保留在Bean工厂中直到不再需要为止。</li><li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用</li></ol><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>Mybatis是一个半ORM框架, 它内部封装了JDBC, 开发时只需要关注SQL语句本身, 不需要花费精力去处理加载驱动, 创建连接, 创建statement等繁杂的过程. 程序员直接编写原生态SQL语句, 可以严格控制SQL执行性能, 灵活度高</p><p>ORM思想: 指对象关系映射, 主要目的是操作实体类就相当于操作数据库表.<br>         需要建立两个映射思想: 1. 建立实体类到表的关系 2. 建立实体类中属性和表中字段的关系</p><h3 id="Mybatis的优点"><a href="#Mybatis的优点" class="headerlink" title="Mybatis的优点"></a>Mybatis的优点</h3><ol><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；<br>提供XML标签，支持编写动态SQL语句，并可重用。</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。</li><li>能够与Spring很好的集成；</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li></ol><h3 id="Mybatis的缺点"><a href="#Mybatis的缺点" class="headerlink" title="Mybatis的缺点"></a>Mybatis的缺点</h3><ol><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>第一范式：每一列都是不可分割的原子数据项<br>第二范式：在1NF的基础上，非主属性必须完全依赖于主码<br>第三范式：在2NF的基础上，任何非主属性不依赖于其他非主属性</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，<br>其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p><p>事务的特征(ACID)：<br>原子性(Atomicity)：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；<br>一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态；<br>隔离性(Isolation)：并发执行的事务之间不能相互影响；<br>持久性(Durability)：事务一旦提交，对数据库中数据的改变是永久性的。</p><p>一致性是对数据可见性的约束, 保证在一个事务中的多项操作的数据中间状态对其他事务是不可见的.<br>因为这些中间状态是一个过渡状态, 与事务的开始状态和事务的结束状态是不一致的.</p><p>事务并发带来的问题<br>脏读：一个事务读取到了另一个事务未提交的数据；<br>不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；<br>幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。</p><p>隔离级别<br>隔离级别决定了一个session中的事务可能对另一个session中的事务的影响。<br>ANSI标准定义了4个隔离级别</p><ol><li>读未提交(READ UNCOMMITTED)：最低级别的隔离，通常又称为dirty read，它允许一个事务读取另一个事务还没提交的数据.<br>产生的问题: 脏读, 不可重复读, 幻读</li><li>读已提交(READ COMMITTED)：在一个事务中只允许对其它事务已经commit的记录可见.<br>产生的问题: 不可重复读, 幻读 (Oracle默认)   </li><li>可重复读(REPEATABLE READ)：在一个事务开始后，其他事务对数据库的修改在本事务中不可见，直到本事务提交或回滚。<br>但是，其他事务的insert/delete操作对该事务是可见的，也就是说，该隔离级别并不能避免幻读问题。<br>(MySQL默认)</li><li>串行化(SERIALIZABLE)：最高级别的隔离，只允许事务串行执行。</li></ol><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询，更新数据库表中数据。<br>索引的实现通常使用BTree及其变种，索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据，<br>相反，他从根节点开始，根节点保存了子节点的指针，存储引擎根据指针快速寻找数据<br>常用索引：哈希索引，全文索引，BTree索引，B+Tree索引</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC 是一个基于Java的实现了MVC设计模式的轻量级Web框架，通过把Model，View，Controller分离，<br>将Web层进行解耦，把复杂的Web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h3 id="Spring-MVC的优点"><a href="#Spring-MVC的优点" class="headerlink" title="Spring MVC的优点"></a>Spring MVC的优点</h3><ol><li>可以支持各种视图技术，而不仅仅局限于JSP</li><li>与Spring框架集成</li><li>清晰地角色分配：前端控制器，处理器映射器，处理器适配器，视图解析器</li><li>支持各种请求资源的映射策略</li></ol><h3 id="MVC与三层架构"><a href="#MVC与三层架构" class="headerlink" title="MVC与三层架构"></a>MVC与三层架构</h3><p>三层架构是一个分层式的软件体系架构设计，适用于所有项目<br>MVC模式是为了让前端与业务逻辑以及数据分开，只使用在Web项目中</p><p>三层架构：<br>表现层(UI):与用户交互的界面。可以用于接收用户输入的数据和显示处理后的数据<br>业务逻辑层(BLL):是UI与DAL的桥梁, 实现业务逻辑处理<br>数据访问层(DAL):关联着数据库, 实现对数据的增删改查</p><p>MVC模式<br>Model模型: 负责数据库操作, 以及业务逻辑的实现, 是MVC的主体<br>View视图: 用户与系统之间的交互界面<br>Controller控制器: 根据用户的输入, 控制用户界面数据显示和更新对象状态.起到控制整个业务流程的作用,实现view层跟Model层的协同工作.</p><h3 id="Spring-MVC流程"><a href="#Spring-MVC流程" class="headerlink" title="Spring MVC流程"></a>Spring MVC流程</h3><ol><li>用户发送请求至DispatcherServlet;</li><li>DispatcherServlet收到请求后, 调用HandlerMapping处理器映射器,请求获取Handler;</li><li>处理器映射器根据url请求找到具体的处理器Handler, 生成处理器对象及处理器拦截器, 一并返回给前端控制器;</li><li>前端控制器调用HandlerAdapter处理器适配器,请求执行Handler;</li><li>HandlerAdapter经过适配调用具体的处理器处理业务逻辑;</li><li>处理器处理完成返回ModelAndView</li><li>处理器适配器将处理器执行结果返回给前端控制器</li><li>前端控制器将ModelAndView传给视图解析器ViewResolver进行解析</li><li>视图解析器解析之后返回具体View</li><li>前端控制器对View进行渲染视图, 即将Model数据填充到View中去</li><li>前端控制器响应用户<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://raw.githubusercontent.com/sqtian-hhu/images/main/images/friends/springMVC.png" alt="SpringMVC流程"><h3 id="Spring-MVC常用注解"><a href="#Spring-MVC常用注解" class="headerlink" title="Spring MVC常用注解"></a>Spring MVC常用注解</h3>@RequestMapping:<br>用于处理请求url映射的注解, 可用在类或方法上.用在类上表示类中的所有响应请求的方法都是以该地址作为父路径.<br>@RequestBody:<br>注解实现接收http请求的json数据, 将json转换为java对象<br>@ResponseBody:<br>注解实现将Controller方法返回对象转化为json对象响应给客户</li></ol><h3 id="如何解决POST请求以及GET请求中文乱码问题"><a href="#如何解决POST请求以及GET请求中文乱码问题" class="headerlink" title="如何解决POST请求以及GET请求中文乱码问题"></a>如何解决POST请求以及GET请求中文乱码问题</h3><p>POST: 在配置文件中配置一个CharacterEncodingFilter过滤器, 编码设置成UTF-8<br>GET: 修改tomcat配置文件添加编码与工程编码一致</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>SpringBoot是Spring开源组织下的子项目, 是Spring组件一站式解决方案, 主要是简化了使用Spring的难度, 减省了繁重的配置.<br>提供了各种启动器, 开发者能快速上手</p><h3 id="Spring-Boot的优势"><a href="#Spring-Boot的优势" class="headerlink" title="Spring Boot的优势"></a>Spring Boot的优势</h3><p>SpringBoot最大的优势就是”约定优于配置”. 约定优于配置是一种软件开发范式, 开发人员按照约定的方式来进行编程, 可以减少开发人员需做决定的数量, 让开发更简单灵活<br>具体的优点有</p><ol><li>容易上手, 提升开发效率, 为Spring开发提供一个更快更广泛的入门体验</li><li>开箱即用, 远离繁琐的配置</li><li>提供了一系列大型项目通用的非业务性功能, 例如: 内嵌服务器, 安全管理, 运行数据监控, 运行状态检查和外部化配置</li><li>避免大量的Maven导入和各种版本冲突</li></ol><h3 id="“约定优于配置”的具体产品体现在哪里"><a href="#“约定优于配置”的具体产品体现在哪里" class="headerlink" title="“约定优于配置”的具体产品体现在哪里"></a>“约定优于配置”的具体产品体现在哪里</h3><p>SpringBoot Starter, SpringBoot JPA都是”约定优于配置”的一种体现. 都是通过”约定优于配置”的设计思路来设计的<br>SpringBoot Starter在启动的过程中会根据约定的信息对资源进行初始化<br>SpringBoot JPA通过约定的方式来自动生成sql, 避免大量无效代码编写.</p><h3 id="Spring-Boot-核心注解-主要是由哪几个注解组成的"><a href="#Spring-Boot-核心注解-主要是由哪几个注解组成的" class="headerlink" title="Spring Boot 核心注解, 主要是由哪几个注解组成的?"></a>Spring Boot 核心注解, 主要是由哪几个注解组成的?</h3><p>启动类注解: @SpringBootApplication<br>主要包含了以下三个注解:<br>@SpringBootConfiguration: 组合了@Configuration注解, 实现配置文件功能<br>@EnableAutoConfiguration: 打开自动配置的功能, 也可以关闭某个自动配置的选项<br>@ComponentScan: Spring组件扫描</p><h3 id="SpringBoot-Starter的工作原理"><a href="#SpringBoot-Starter的工作原理" class="headerlink" title="SpringBoot Starter的工作原理"></a>SpringBoot Starter的工作原理</h3><p>SpringBoot在启动的时候,按照约定去读取SpringBoot Starter中的配置信息, 再根据配置信息对资源进行初始化, 并注入到Spring容器中.<br>这样Spring Boot启动完毕后, 就已经准备好了一切资源, 使用过程直接注入对应的Bean资源即可.</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ol><li>进程是对运行时程序的封装,是系统进行资源调度和分配的基本单位,实现操作系统的并发。</li><li>线程是进程的子任务,是CPU调度和分派的基本单位,用于保证程序的实时性,实现进程内部的并发。</li><li>一个程序至少有一个进程,一个进程至少有一个线程,线程依赖进程的存在。</li><li>进程执行过程中拥有独立的内存单元,而多个线程共享进程的内存。</li></ol><h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>指进程之间的信息交换<br>进程是分配系统资源的单位,因此各进程拥有的内存地址空间相互独立<br>为了保证安全,一个进程不能直接访问另一个进程的地址空间.<br>但是进程之间的信息交换又是必须实现的. 为了保证进程间的安全通信,操作系统提供了一些方法</p><ol><li><p>管道（pipe）：<br>管道是指用于连接读写进程的一个共享文件,实际上就是在内存中开辟一个大小固定的缓冲区<br>进程1写数据到管道,进程2从管道读数据<br>1没写满2不能读,2没读空1不能写<br>各进程互斥访问，速度慢、容量有限</p></li><li><p>消息队列：<br>消息队列是消息的链接表，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p></li><li><p>共享内存：<br>在内存中画出一块共享存储区，多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。<br>这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p></li><li><p>信号量：<br>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p></li><li><p>套接字：<br>这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p></li></ol><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><ol><li>同步<br>多个线程通过synchronized通讯</li><li>while轮询<br>线程A不断改变条件，线程B不断查看条件是否满足需求（比方说=5），从而实现通讯。<br>效率不高，因为B一直在查看，没做别的</li><li>wait/notify<br>进入阻塞，而不是像轮询一样一直占用CPU资源</li><li>管道通信<br>通过管道，将一个线程的消息发送个另一个线程</li></ol><h3 id="进程调度的策略"><a href="#进程调度的策略" class="headerlink" title="进程调度的策略"></a>进程调度的策略</h3><ol><li>FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU</li><li>SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度</li><li>优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化</li><li>时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。</li><li>多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。</li><li>多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。</p><p>死锁产生的四个必要条件</p><ol><li>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</li><li>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</li><li>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系</li></ol><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存允许执行进程不必完全在内存中。<br>虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。<br>这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。<br>当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；<br>当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。<br>这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，<br>还有一些没加载在内存中的对应在硬盘上</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ol><li>FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</li><li>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</li><li>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</li><li>OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。</li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h3><p>OSI七层模型(法定标准):<br>物理层-&gt;链路层-&gt;网络层-&gt;传输控制层-&gt;会话层-&gt;表示层-&gt;应用层</p><p>TCP/IP五层模型(事实标准):<br>应用层: 支持各种网络应用  TFTP, SMTP, HTTP，Telnet，DNS<br>传输层: 进程-进程的数据传输  TCP, UDP<br>网络层: 源主机到目的主机的数据分组路由与转发  IP, ICMP，ARP，RARP<br>数据链路层: 把网络层传下来的数据报组装成帧<br>物理层: 比特传输</p><p>发送数据的过程：</p><ol><li>应用层程序发送数据</li><li>传输层把发送的数据分成多个报文段</li><li>网络层对每个报文段加上源主机ip地址和目的主机ip地址（DNS获取），封装成IP数据报</li><li>数据链路层在IP数据报上再加上源主机MAC地址和目的主机MAC地址（ARP协议获取）</li><li>物理层传输数据</li></ol><h3 id="TCP-和-UDP的区别（传输层）"><a href="#TCP-和-UDP的区别（传输层）" class="headerlink" title="TCP 和 UDP的区别（传输层）"></a>TCP 和 UDP的区别（传输层）</h3><p>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输<br>TCP借助三次握手建立连接四次挥手断开连接来保障传输的可靠性，而UDP在传输数据前不建立连接，想传送时就直接抓取来自应用程序的数据并尽可能快地发送到网络上。<br>TCP传输单位成为TCP报文段，UDP传输单位成为用户数据包；<br>TCP注重数据安全性，UDP数据传输快，更具实时性；<br>TCP是面向字节流，UDP面向报文<br>TCP是点对点连接，UDP一对一，一对多，多对多传输都可以<br>TCP适合用于网页，邮件等，UDP适合用于视频，语音广播等</p><p>TCP对应的协议：<br>FTP:定义了文件传输协议，使用21端口<br>Telnet：一种用于远程登录的端口，使用23端口，用户可以以自己的身份连接到远程的计算机上。<br>SMTP：邮件传送协议，用于发送邮件。服务器开放的是25端口<br>POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>HTTP ：是从Web服务器传输超文本到本地浏览器的传送协议<br>UDP对应的协议：<br>DNS协议：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>SNMP：简单网络管理协议，使用161号端口，使用来管理网络设备<br>TFTP ：简单文件传输协议，该协议是在熟知的端口69上使用UDP服务。</p><h3 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h3><p>TCP协议是面向连接的,可靠的传输协议<br>面向连接: 三次握手之后, 双方当开辟资源接收信息</p><p>为什么三次?<br>当客户端第一次发送连接请求syn后, 服务器端接收成功后返回一个syn和ack响应.<br>此时两端完成了两次握手, 从客户端的角度, 客户端已经确认了往返连接是相通的.<br>但从服务器角度, 只接收到了客户端的syn,还不确定服务器端回复的syn和ack响应是否被客户端收到,<br>即还不确定服务器端向客户端是否连通. 因此客户端收到服务器端的返回后需要在发送一次ack,<br>服务器端接收到此ack响应后即完成了三次握手, 此时就保证了连接的可靠.</p><p>为什么四次挥手?<br>端口资源是有限的, 如果一个程序不断申请端口号建立连接, 那资源总会消耗光,因此数据传输完毕需要断开连接</p><ol><li>客户端应用进程调用断开连接的请求, 向服务器端发送一个终止标志位FIN, 表示要发送的数据已经安全发送完毕,可以开始关闭链路操作</li><li>服务器端收到FIN后返回一个ACK, 表示收到了断开链路的请求, 并关闭客户端到服务器端的链路.</li><li>服务器端将关闭链路前需要发送的数据发给客户端, 完成后发送一个终止标志位FIN, 表示数据发送完毕, 请求关闭服务器到客户端的链路</li><li>客户端在接收到这个最终FIN后, 发送一个ACK=1的消息给服务器端, 并断开服务器到客户端的链路.</li></ol><h3 id="HTTP原理（应用层）"><a href="#HTTP原理（应用层）" class="headerlink" title="HTTP原理（应用层）"></a>HTTP原理（应用层）</h3><p>HTTP是一个无状态的协议, 无状态指在客户端和服务器之间不需要建立持久的连接,在一个客户端向服务器发出请求且服务器端收到该请求并返回响应后, 本次通信结束, HTTP连接将被关闭, 服务器不保留连接的相关信息.</p><p>HTTPS是以安全为目标的HTTP通道, 它在HTTP中加入SSL层以提高数据传输的安全性.<br>HTTP被用于在Web浏览器和网站服务器之间传递信息, 但以明文方式发送内容, 不提供任何方式的数据加密,<br>如果攻击者截取了Web浏览器和网站服务器之间的传输报文, 就可以直接读懂.<br>为了数据安全, HTTPS在HTTP基础上加入了SSL协议, SSL依靠证书来验证服务器的身份,<br>并对浏览器和服务器之间的通信进行数据加密, 以保障传输的安全性.</p><h3 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h3><ol><li>路由器工作在网络层，而交换机一般工作在链路层;</li><li>路由器根据IP地址转发, 交换机根据MAC地址转发;</li><li>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入外网。</li><li>路由器还可以提供防火墙的功能, 交换机提供不了。</li></ol><h3 id="简述ICMP、TFTP、HTTP、NAT、DHCP协议"><a href="#简述ICMP、TFTP、HTTP、NAT、DHCP协议" class="headerlink" title="简述ICMP、TFTP、HTTP、NAT、DHCP协议"></a>简述ICMP、TFTP、HTTP、NAT、DHCP协议</h3><p>ICMP : 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息<br>TFTP：是TCP/IP协议族中的一个用来在客户机和服务器之间进行简单的文件传输的协议，提供不复杂、开销不大的文件传输服务<br>HTTP：超文本传输层协议，是一个属于应用层的面向对象的协议<br>NAT协议：网络地址转换接入广域网（WAN）技术，是一种将私有地址转换为合法IP地址的转换技术<br>DHCP协议：动态主机配置协议，使用UDP协议工作。给内部的网络和网络服务供应商自动的分配IP地址。</p><h3 id="get与post请求的区别"><a href="#get与post请求的区别" class="headerlink" title="get与post请求的区别"></a>get与post请求的区别</h3><ol><li>get重点在从服务器上获取资源,post重点在想服务器发送数据;</li><li>get传输数据是通过URL请求,以filed(字段)=value的形式,置于URL后,并用”?”连接,多个请求数据之间用”&amp;”连接,如<a href="http://127.0.0.1/Test/login.a...，这个过程用户是可见的" target="_blank" rel="noopener">http://127.0.0.1/Test/login.a...，这个过程用户是可见的</a></li><li>get传输量小,因为受URL长度限制,但效率较低, post可以传输大量数据,所以上传文件时只能用post方式</li><li>get是不安全的,因为URL是可见的,可能会泄露私密信息,如密码等, post较get安全</li></ol><h3 id="DNS域名系统（应用层）"><a href="#DNS域名系统（应用层）" class="headerlink" title="DNS域名系统（应用层）"></a>DNS域名系统（应用层）</h3><p>根域名服务器<br>顶级域名服务器：管理该顶级域名服务器注册的所有二级域名<br>权限域名服务器：负责一个区的域名服务器<br>本地域名服务器</p><p>当需要把主机名解析成IP地址时，应用进程调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器，本地域名服务器查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的主机的IP地址后即可进行。<br>递归查询：（靠别人）比较少用<br>    首先当一个主机发出DNS查询请求时，先查找本机缓存，查询不到再把这个查询请求报文发给本地域名服务器，<br>    如果在本地域名服务器的高速缓存中没有查询到，本地域名服务器会向根域名服务器发送请求<br>    根域名服务器根据顶级域名向下查询顶级域名服务器，顶级域名服务器再根据二级域名向下查询权限域名服务器，直到查询出域名对应的IP。<br>迭代查询：（靠自己）<br>    首先当一个主机发出DNS查询请求时，先查找本机缓存，查询不到再把这个查询请求报文发给本地域名服务器，<br>    如果在本地域名服务器的高速缓存中没有查询到，本地域名服务器会向根域名服务器发送请求，<br>    根域名服务器告诉本地域名服务器顶级域名对应的顶级域名服务器，本地域名服务器再向顶级域名服务器发送请求，<br>    顶级域名服务器告诉本地服务器二级域名对应的权限域名服务器，本地服务器再向权限域名服务器发送请求，<br>    直到查询出域名对应的IP。</p><h3 id="NAT网络地址转换（网络层）"><a href="#NAT网络地址转换（网络层）" class="headerlink" title="NAT网络地址转换（网络层）"></a>NAT网络地址转换（网络层）</h3><p>NAT：网络地址转换技术，将私网地址和公网地址进行转换，实现私网用户能在公网上通信，一般配置在网络路由器或防火墙上。<br>NAT实际上实现的是私有地址和公有地址的一对一映射，并不能很好的解决公有地址短缺的问题。<br>现在的网络地址转换技术更多的是指NAPT网络端口地址转换技术，主机中利用IP：端口号来表示进程，IP数据报送达NAT路由器，NAT路由器会根据NAT转换表查找数据报中IP端口号映射的NAT路由器中的端口号，让后用NAT路由器的公网IP和查到的端口号替换原来数据报中的源主机IP和端口号，然后把更新的IP数据报发送出去，实现在公网上的通信。</p><h3 id="ARP协议（网络层）"><a href="#ARP协议（网络层）" class="headerlink" title="ARP协议（网络层）"></a>ARP协议（网络层）</h3><p>在实际网络的链路上传送数据帧时，最终必须使用MAC地址。ARP协议实现IP地址与MAC地址的映射，用来获取目的IP对应的MAC地址<br>IP数据报中包含源主机IP地址和目的主机IP地址，首先检查ARP高速缓存，有对应表项则写入MAC帧，没有先把源主机IP地址和目的IP相与，看是否是同一个网段下，<br>如果是同一个网段，就广播ARP请求分组：源IP|目的IP|源MAC|全1广播地址, 目的主机收到后返回单播ARP响应分组: 目的IP|目的MAC, 源主机获取到目的MAC后加入封装。<br>如果不是同一个网段，下一跳就应该是默认网关，广播ARP请求分组：主机IP|网关IP|主机MAC|全1广播地址, 网关返回单播ARP响应分组: 网关IP|网关MAC,源主机获取网关MAC后封装进IP数据报。</p><h3 id="DHCP协议（应用层）"><a href="#DHCP协议（应用层）" class="headerlink" title="DHCP协议（应用层）"></a>DHCP协议（应用层）</h3><p>动态主机配置协议，使用UDP协议工作。给内部的网络和网络服务供应商自动的分配IP地址。</p><ol><li>主机广播DHCP发现报文，尝试找到网络中的服务器获取一个IP地址。</li><li>DHCP服务器广播DHCP提供报文，服务器拟分配给主机一个IP地址及相关配置，先到先得。</li><li>主机广播DHCP请求报文，主机向服务器请求提供IP地址</li><li>DHCP服务器广播DHCP确认报文，正式将IP地址分配给主机。</li></ol><h3 id="链路状态路由算法OSPF"><a href="#链路状态路由算法OSPF" class="headerlink" title="链路状态路由算法OSPF"></a>链路状态路由算法OSPF</h3><h3 id="距离向量路由算法RIP"><a href="#距离向量路由算法RIP" class="headerlink" title="距离向量路由算法RIP"></a>距离向量路由算法RIP</h3><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://raw.githubusercontent.com/sqtian-hhu/images/main/images/friends/24.jpg" alt="全文背诵"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 呈呈专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2021/05/30/ji-chu-zheng-li/jvm/"/>
      <url>/2021/05/30/ji-chu-zheng-li/jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM内存空间"><a href="#JVM内存空间" class="headerlink" title="JVM内存空间"></a>JVM内存空间</h2><p>用于运行Java字节码的虚拟机，是Java能够跨平台的关键所在<br>每个操作系统的解释器不同，但基于解释器实现的虚拟机是相同的<br>Java程序的具体运行过程：<br>1）Java源文件被编译器编译成字节码文件<br>2）JVM将字节码文件编译成相应操作系统的机器码<br>3）机器码调用相应的操作系统的本地方法库执行相应的方法</p><p>内存区域：寄存器，本地方法区，栈内存，堆内存，方法区</p><p>寄存器：存储当前运行的线程所执行的字节码的行号指示器<br>        线程私有，无内存溢出问题</p><p>虚拟机栈：描述Java方法的执行过程的内存模型，方法执行时虚拟机会为其创建一个栈帧，他在当前栈帧中存储了局部变量表，操作数栈，动态链接，方法出口等信息<br>          线程私有 </p><p>本地方法区：本地方法区与虚拟机栈的作用类似，区别是虚拟机栈为执行Java方法服务，本地方法栈为执行原生方法服务<br>            线程私有</p><p>堆：JVM运行时创建的对象和产生的数据都存在堆中，堆是线程共享的内存区域，也是垃圾收集器进行垃圾回收的最主要内存区域</p><p>方法区：用于存储常量，静态变量，类信息等数据，线程共享</p><p>线程私有与线程共享：<br>    线程私有指区域随线程的创建而创建，随线程的结束而结束。<br>    线程共享指区域随虚拟机的启动而创建，随虚拟机的关闭而销毁。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h3><p>Java采用引用计数法和可达性分析来确定对象是否应该被回收</p><ol><li><p>引用计数法<br> 在Java中要操作对象，就必须获取对象的引用，因此可以通过引用计数法来判断对象是否可以被回收<br>在对象添加一个引用时，引用计数+1；在为对象删除一个引用时，引用计数-1；如果一个对象的引用计数=0了，<br>就表示该对象没有被引用，可以被回收<br> 引用计数法容易产生循环引用的问题，循环引用指两个对象相互引用，导致他们的引用一直存在，而不能被回收</p></li><li><p>可达性分析<br> 为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以回收。<br> 首先定义一些GC Roots 对象，然后以这些GC Roots对象作为起点向下搜索，<br> 如果在GC Roots和一个对象之间没有可达路径，则称该对象是不可达的<br> 不可达对象要经过至少两次标记才被回收。</p></li></ol><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><p>Java中常用的回收算法有标记清除，复制算法，标记整理和分代收集</p><ol><li><p>标记清除算法<br> 标记清除算法是基础的垃圾回收算法，其过程分为标记和清除两个阶段。<br>标记阶段标记出所友需要回收的对象，在清除阶段清除可回收的对象并释放其所占用的内存<br>  由于标记清理算法在清理对象后没有重新整理可用的内存空间，因此如果内存中可被召回的小对象居多<br>则会引起内存碎片化的问题，继而引起大对象无法获得连续可用空间的问题</p></li><li><p>复制算法<br> 为了解决标记清理算法内存碎片化的问题，复制算法首先将内存划分为大小相等的两个区域<br>新生成的对象都被存放在区域1中，在区域1存满后会进行一次标记，并将标记的对象复制到区域2中<br>然后直接清理整个区域1的内存<br> 复制算法的内存清理效率高且易实现，但由于同一时间只有一个内存区域能用，因此存在大量内存浪费<br>同时，当系统中有大量长时间存活的对象时，这些对象将在内存区域1和2之间反复复制而影响系统效率</p></li><li><p>标记整理算法<br> 首先进行一次标记，标记完成后将存活的对象移到内存的另一端，把这一端的对象清除并释放内存</p></li></ol><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><pre><code>分代收集算法根据对象的不同类型将内存划分为新生代，老年代，永久代</code></pre><p>其中新生代占1/3左右堆空间，老年代占2/3左右堆空间，永久代一般指方法区。<br>新生代又被分为Eden区，ServivorFrom区和ServivorTo区，Eden区默认占新生代空间的8/10；<br>ServivorFrom区和ServivorTo区分别占1/10。</p><p>新生代：<br>    新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，在每次进行垃圾回收时都有大量对象被回收<br>新生代的GC过程叫做MinorGC，采用复制算法实现</p><p>Eden区：Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，责备直接放进老年代，<br>        在Eden区的内存不足时会触发MinorGC，对新生代进行一次回收<br>ServivorTo区：保留这一次MinorGC的幸存者<br>ServivorFrom区：将上一次MinorGC的幸存者作为这一次MinorGC的被扫描者</p><p>MinorGC：<br>    1）对Eden区和ServivorFrom区进行一次标记，将标记后的存活对象复制到ServivorTo区，同时所有存活对象年龄加一<br>       如果ServivorTo区内存空间不够或者对象属于大对象或者对象年龄达到了老年代标准，则直接将其复制到老年代，<br>    2）清空Eden区和ServivorFrom区<br>    3）将ServivorTo和ServivorFrom区对换，原来的ServivorTo区变成了下一次GC的ServivorFrom区</p><p>老年代：<br>    老年代主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。<br>老年代的GC过程叫做MajorGC，在老年代，对象比较稳定，MajorGC不会频繁触发。<br>在进行MajorGC之前，JVM会进行一次MinorGC，如果仍然出现老年代空间不足或者找不到足够大的空间分配给新创建的大对象时，会触发MajorGC<br>MajorGC采用标记整理法，首先对老年代中所有对象进行一次扫描并标记存活的对象，<br>然后回收未被标记的对象，并释放内存空间<br>    因为要先扫描老年代的所有对象再回收，所以MajorGC时间较长。MajorGC的标记清除算法会产生内存碎片，<br>在老年代没有内存空间可分配时，会抛出Out Of Memory异常；</p><p>永久代：<br>    永久代指内存永久保护区域，主要存放Class和Meta（元数据）的信息<br>Class在类加载时被放入永久代，永久代与老年代和新生代不同，GC不会在程序运行期间对永久代的内存进行清理<br>这也导致了永久代的内存会随着加载的Class文件增加而增加，在加载的Class文件过多时就会抛出Out of Memory 异常</p><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>在Java中一切皆对象，对象的操作是通过该对象的引用实现的，Java中的引用类型有4种</p><ol><li>强引用<br> 在java中最常见的就是强引用,把对象赋给一个引用变量时,这个引用变量就是一个强引用.<br> 有强引用的对象一定为可达性状态, 所以不会被垃圾回收,因此强引用是造成Java内存泄漏的主要原因</li><li>软引用<br> 如果一个对象只有软引用, 则在系统内存空间不足时该对象将被回收 </li><li>弱引用<br> 如果一个对象只有弱引用, 则在垃圾回收过程中一定会被回收</li><li>虚引用<br> 虚引用主要用于跟踪对象的垃圾回收状态</li></ol><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>JVM针对新生代和老年代分别提供了多种不同的垃圾回收器<br>针对新生代: Serial(单线程, 复制算法), ParNew(多线程,复制算法), Parallel Scavenge(多线程,复制算法)<br>针对老年代: Serial Old(单线程,标记整理法), Parallel Old(多线程,标记整理法),CMS,<br>针对不同区域: G1</p><p>CMS:<br>    CMS垃圾收集器是为老年代设计的垃圾收集器,其主要目的是达到最短的垃圾回收停顿时间.<br>主要包含四个步骤:</p><p>1) 初始标记: 只标记和GC Roots直接关联的对象, 速度很快, 需要暂停所有工作线程<br>2) 并发标记: 和用户线程一起工作, 执行GC Roots跟踪标记过程, 不需要暂停工作线程<br>3) 重新标记: 在并发标记过程中用户线程继续运行, 导致在垃圾回收过程中部分对象的状态发生变化,<br>             为了确保这部分对象的状态正确性,需要对这部分重新标记并暂停工作线程<br>4) 并发清除: 和用户线程一起工作, 执行清除GC Roots不可达对象的任务, 不需要暂停工作线程</p><pre><code>CMS垃圾收集器在和用户线程一起工作时(并发标记和并发清除)不需要暂停用户线程,</code></pre><p>有效缩短了垃圾回收时系统的停顿时间,同时由于CMS垃圾收集器和用户线程一起工作,因此其并行度和效率也有所提升.</p><h3 id="Java网络编程模型"><a href="#Java网络编程模型" class="headerlink" title="Java网络编程模型"></a>Java网络编程模型</h3><p>待学</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="JVM类加载阶段"><a href="#JVM类加载阶段" class="headerlink" title="JVM类加载阶段"></a>JVM类加载阶段</h3><p>JVM的类加载分为5个阶段: 加载, 验证, 准备, 解析, 初始化<br>在类初始化完成后就可以使用该类的信息, 在一个类不再被需要时就可以从JVM中卸载</p><ol><li>加载<br> 指JVM读取Class文件,并且根据Class文件描述创建Java.lang.Class对象的过程.<br>类加载过程主要包含将Class文件读取到运行时区域的方法内, 在堆中创建Class对象,并封装类在方法区的数据结构的过程<br>在读取Class文件时既可以通过文件的形式读取,也可以通过jar包,war包读取,还可以通过代理自动生成Class或其他方式获取</li><li>验证<br> 主要用于确保Class文件符合当前虚拟机的要求, 保障虚拟机自身安全,只有通过验证的Class文件才能被JVM加载</li><li>准备<br> 主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值.<br>初始值指不同数据类型的默认值, 需要注意的是final类型的变量和非final类型的变量在准备阶段的数据初始化不同，<br>非final类型的变量在准备阶段的初始值是数据类型的默认值，对变量赋值是在对象初始化阶段<br>final类型的变量在编译后会生成对应的ConstantValue属性，虚拟机在准备阶段会根据ConstantValue属性直接赋值</li><li>解析<br> JVM会将常量池中的符号引用替换成直接引用</li><li>初始化<br> 主要通过执行类构造器的<client>方法为类进行初始化。<br><client>方法是在编译阶段由编译器自动收集类中静态代码块和静态变量的赋值操作组成的.<br>只有在父类的<client>方法都执行成功后,子类的<client>方法才可以被执行.<br>在一个类中既没有静态变量赋值操作也没有静态代码块时,编译器不会为该类生成<client>方法</client></client></client></client></client></li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><pre><code>JVM提供了3种类加载器,分别是启动类加载器,扩展类加载器和应用程序类加载器</code></pre><ol><li>启动类加载器: 负责加载Java_HOME/lib目录中的类库, 或通过-Xbootclasspath参数指定路径中被虚拟机认可的类库</li><li>扩展类加载器: 负责加载Java_HOME/lib/ext 目录中的类库, 或通过java.ext.dirs系统变量加载指定路径中的类库</li><li>应用程序类加载器: 负责加载用户路径(classpath)上的类库<br>除了上述三种类加载器,也可以通过继承java.lang.ClassLoader实现自定义的类加载器</li></ol><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><pre><code>JVM通过双亲委派机制对类进行加载.</code></pre><p>双亲委派机制指一个类在收到类加载请求后不会尝试自己加载这个类,而是把该类加载请求向上委派给其父类去完成,<br>其父类在接收到该类加载请求后又会将其委派给自己的父类, 以此类推, 这样所有的类加载请求都被向上委派到启动类加载器中.<br>若父类加载器在接收到类加载请求后发现自己也无法加载该类(通常原因是该类的Class文件在父类的类加载路径中不存在),<br>则父类会将该信息反馈给子类并向下委派子类加载器加载该类,直到该类被成功加载,若找不到该类,则JVM会抛出ClassNotFound异常<br>    双亲委派机制的类加载流程</p><p>1) 将自定义加载器挂载到应用程序类加载器.<br>2) 应用程序类加载器将类加载请求委托给扩展类加载器<br>3) 扩展类加载器将类加载请求委托给启动类加载器<br>4) 启动类加载器在加载路径下查找并加载Class文件, 如果未找到目标Class文件, 则交由扩展类加载器加载<br>5) 扩展类加载器在加载路径下查找并加载Class文件, 如果未找到目标Class文件, 则交由应用程序类加载器<br>6) 应用程序类加载器在加载路径下查找并加载Class文件, 如果未找到目标Class文件,则交由自定义加载器加载<br>7) 在自定义加载器下查找并加载用户指定目录下的Class文件,如果未找到Class文件,则抛出ClassNotFOund异常</p><pre><code>双亲委派机制的核心是保障类的唯一性和安全性. 无论哪个类加载器加载该类, 最终都将类加载请求委托给启动类加载器加载, </code></pre><p>这样就保证了类加载的唯一性. 如果在JVM中存在包名和类名相同的两个类,则该类就无法被加载,JVM也无法完成类加载流程</p><h3 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h3><pre><code>实例初始化就是执行&lt;init&gt;方法, &lt;init&gt;方法由编译器自动收集类中非静态代码块和非静态变量的赋值操作组成的.非静态实例变量显示赋值代码和非静态代码块从上而下顺序执行,而对应构造器代码最后执行.每次创建实例对象,调用对应构造器,执行的就是对应&lt;init&gt;方法</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第五章</title>
      <link href="/2021/05/27/cao-zuo-xi-tong/cao-zuo-xi-tong-di-wu-zhang/"/>
      <url>/2021/05/27/cao-zuo-xi-tong/cao-zuo-xi-tong-di-wu-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p>输入输出<br>将数据输入到计算机或接受计算机输出数据的外部设备<br>鼠标键盘–典型的输入设备<br>显示器–输出<br>移动硬盘–输入输出</p><p>I/O设备的电子部件（I/O控制器）<br>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的中介</p><p>I/O控制器的功能：<br>    接受和识别CPU发出的命令 – 控制寄存器<br>    向CPU报告设备的状态     – 状态寄存器<br>    数据交换                – 数据寄存器<br>    地址识别</p><p>I/O控制方式<br>    程序直接控制方式<br>    中断驱动方式<br>    DMA方式<br>    通道控制方式</p><ol><li><p>程序直接控制<br>完成一次读写的流程<br> 给I/O模块发出读命令  CPU向控制器发出命令<br> 读I/O模块的状态      将I/O状态信息读入CPU寄存器<br> 检查状态             设备可能出现错误<br> 从I/O模块中读取字    将数据寄存器中的内容读入CPU寄存器<br> 往存储器中写入字     将CPU寄存器中的内容写到主存中</p></li><li><p>中断驱动方式<br> 引入中断机制。由于I/O设备速度很慢，因此CPU发出读写命令后，可将等待I/O的进程阻塞，<br> 先切换到别的进程<br> 优：与1相比，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询</p><pre><code> CPU和I/O设备可并行工作，CPU利用率明显提升</code></pre><p> 缺：每个字在I/O设备与内存之间的传输都需要经过CPU，而频繁的中断处理会消耗较多的CPU时间。</p><p> 数据流向：读 I/o设备 -&gt; CPU -&gt; 内存</p><pre><code>       写 内存 -&gt; CPU -&gt; I/O设备</code></pre></li><li><p>DMA方式<br> (直接存储器存取)<br> 数据的传送单位是”块”, 不再是一个字一个字<br> 数据直接从设备到内存, 不再需要中间经过CPU<br> 尽在传送数据块的开始和结束时才需要CPU的干预</p><p> 控制器根据CPU要求完成后才向CPU发出中断信号</p></li><li><p>通道控制方式<br> CPU给通道任务清单, 通道完成I/O后向CPU发出信号, CPU干预率低,每次传输一组块<br> 设备 &lt;-&gt; 内存</p></li></ol><p>逻辑设备表(LUT)<br>建立逻辑设备到物理设备的映射关系,根据设备类型调用相应的驱动程序</p><p>I/O调度: 用某种算法确定顺序来处理各个I/O请求<br>(先来先服务,优先级算法,短作业优先等)</p><p>设备被看作是一种特殊的文件, 因此每个设备也会有对应的FCB<br>设备保护即如文件保护</p><p>脱机技术: 脱离主机的控制进行的输入输出操作<br>假脱机技术(实现于用户层软件,但也属于I/O核心子系统)</p><p>假脱机(SPOOLing技术)<br>    用软件的方式模拟脱机技术<br>共享打印机:<br>    用SPOOLing技术将独占式打印机”虚拟”成共享打印机</p><h3 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h3><p>设备分配时应考虑的因素</p><ol><li><p>设备的固有属性<br> 独占设备 – 一个时段只能分配一个进程<br> 共享设备 – 宏观上可同时使用<br> 虚拟设备 – 采用SPOOLing技术将独占改造成虚拟的共享设备</p></li><li><p>设备的分配算法<br> 先来先服务,优先级算法,短作业优先等</p></li><li><p>设备分配中的安全性<br>安全分配方式:<br> 为进程分配一个设备后就将其阻塞, 本次I/O完成后才唤醒(不会死锁)<br>不安全分批方式:<br> 进程发出I/O请求后还可继续执行(进程的计算任务与I/O任务可并行执行,但可能死锁)</p></li></ol><p>静态分配:<br>    进程运行前为其分配全部资源,运行结束后归还<br>动态分配:<br>    进程运行过程中动态申请</p><p>系统设备表(SDT): 记录了系统中全部设备的情况,每个设备对应一个表目</p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>单缓冲<br>双缓冲<br>循环缓冲<br>缓冲池</p><p>可以由专门的硬件寄存器组成,也可利用内存作为缓冲区<br>使用硬件作为缓冲区的成本较高,容量也较小,一般利用内存作为缓冲区</p><p>缓冲区的作用:</p><ol><li>缓和CPU与I/O设备之间速度不匹配的矛盾</li><li>减少对CPU的中断频率,放宽对CPU中断响应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU与I/O设备的并行性</li></ol><p>CPU把数据块快速地放入缓冲区,然后去执行别的任务<br>慢速的I/O设备可以慢慢取走</p><p>缓冲区的特点: 不存满不能读,不读空不能存</p><p>单缓冲 –&gt; 半双工<br>双缓冲 –&gt; 全双工</p><p>循环缓冲区:<br>    in指针指向下一个可以冲入数据的空缓冲区<br>    out指针指向下一个可以取出的满缓冲区</p><p>缓冲池由系统中共用的缓冲区组成<br>按使用状况分为: 空缓冲队列, 装满输入数据的缓冲队列</p><p>四种工作缓冲区:<br>用于收容输入数据的工作缓冲区 hin<br>用于提取输入数据的工作缓冲区 sin<br>用于收容输出数据的工作缓冲区 hout<br>用于提取输出数据的工作缓冲区 sout</p><p>收容输入 -&gt; hin       sin -&gt; 提取输入<br>提取输出 &lt;- sout     hout -&gt; 收容输出</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第四章</title>
      <link href="/2021/05/25/cao-zuo-xi-tong/cao-zuo-xi-tong-di-si-zhang/"/>
      <url>/2021/05/25/cao-zuo-xi-tong/cao-zuo-xi-tong-di-si-zhang/</url>
      
        <content type="html"><![CDATA[<p>##文件管理<br>文件就是一组有意义的信息/数据集合</p><p>同一个目录下不允许有重名文件</p><p>读文件：将文件从外存读入内存，才能让cpu处理<br>写文件：从内存写回外存</p><p>无结构文件：如文本文件，由一些二进制或字符流组成，又称“流式文件”<br>有结构文件：如数据库表，由一组相似的记录组成，又称“记录式文件”</p><p>类似内存块，外存也会分为一个个磁盘快，每个磁盘块的大小是相等的</p><p>###顺序文件<br>    文件中的记录一个接一个地顺序排列，记录可以是定长或可变长的，<br>各个记录在物理上可以是顺序存储或链式存储</p><p>链式存储：<br>    逻辑上相邻但物理上不一定相邻，类似于链表<br>    无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找<br>顺序存储：<br>    逻辑上相邻物理上也相邻，类似于顺序表<br>    可变长记录：无法实现随机存取，每次只能从第一个记录开始依次往后查找<br>    定长记录： 可以实现随机存取。若采用串结构，无法快速找到某关键字对应的记录<br>               若采用顺序结构，可以快速找到某关键字对应的记录</p><p>###索引文件<br>    建立一张索引表以加快文件检索速度，每条记录对应一个索引项<br>    索引表本身是定长记录的顺序文件，因此可以快速找到第i个记录对应的索引项</p><pre><code>索引文件的缺点：    每个记录对应一个索引表项，因此索引表可能会很大，比如文件每个记录只占8B    索引表项占32个字节，那么索引表比文件本身大了4倍，不划算</code></pre><p>###索引顺序文件<br>    索引项不需要按关键字排列（串结构），不会每个记录对应一个索引表项，而是一组记录对应一个索引表项<br>    多级索引顺序文件–&gt;类似于新华字典</p><p>##文件目录<br>文件控制块 FCB: 目录文件中的一条记录就是一个文件控制块<br>    FCB的有序集合称为”文件目录”,一个FCB就是一个文件目录项<br>目录结构:<br>    单级目录结构: 按名存取, 不允许文件重名<br>    两级目录结构: 主文件目录(MFD) –用户名<br>                  用户文件目录    –用户文件<br>    多级目录结构: 树形目录结构 无法共享</p><pre><code>无环图目录结构 可以用不同的文件名指向同一个文件</code></pre><p>索引结点:<br>    除了文件名之外的所有信息都放在索引结点中,每个文件对应一个索引结点<br>    目录项中只包含文件名, 索引结点指针,因此每个目录项的长度大幅减小<br>    由于目录项长度减小,因此每个磁盘块可以存放更多个目录项,因此检索文件时磁盘I/O的次数就少了很多</p><p>##文件的物理结构<br>    (文件分配方式)<br>连续分配<br>链接分配{隐式分配, 显示分配}<br>索引分配</p><p>类似于内存分页, 磁盘中的存储单元也会被分为一个个”块/磁盘块/物理块”.<br>很多操作系统中,磁盘块的大小与内存块, 页面的大小相同<br>因为内存与磁盘之间的数据交换都是以”块”为单位进行的</p><p>文件的逻辑地址也可以表示为(逻辑块号,块内地址). OS要负责从逻辑地址到物理地址的映射</p><ol><li><p>连续分配<br>要求每个文件在磁盘上占有一组连续的块<br>读取某个磁盘块时, 需要移动磁头. 访问的两个磁盘块相隔越远,移动磁头所需的时间就越长<br>因此, 连续分配的文件在顺序读/写时速度最快<br>但物理上采用连续分配的文件不方便拓展, 且存储空间利用率低,会产生难以利用的磁盘碎片<br>可以用紧凑来处理碎片, 但是需要消耗很大的时间代价</p></li><li><p>链接分配<br>采用离散分配的方式, 可以为分配离散的磁盘块</p><p> 隐式链接: 除文件最后一个盘块之外, 每个盘块中都存有指向下一个盘块的指针.</p><pre><code>       文件目录包括文件第一块的指针和最后一块的指针 优点: 很方便文件拓展, 不会有碎片问题, 外存利用率高 缺点: 只支持顺序访问, 不支持随机访问, 查找效率低,指向下一个盘块的指针也需要耗费少量的存储空间</code></pre><p> 显式链接: 把用于链接文件个物理块的指针显式地存放在一张表中, 即文件分配表(FAT,File Aliocation Table)</p><pre><code> 一个磁盘块设置一张FAT. 开机时,将FAT读入内存,并常驻内存 采用链式分配显示链接方式的文件, 支持顺序访问,也支持随机访问(想访问i号逻辑块时, 并不需要依次访问之前的0~i-1号逻辑块,只需要在FAT里查找后直接访问),  由于块号的转换过程不需要访问磁盘, 因此相比于隐式链接访问速度快很多 显示链接不会产生外部碎片,也可以很方便地对文件进行拓展,并且支持随机访问 缺点: 文件分配表需要占用一定的存储空间</code></pre></li><li><p>索引分配<br> 索引分配允许文件离散地分配在各个磁盘块中, 系统会为每个文件建立一张索引表,<br>索引表中记录了文件的各个逻辑块(索引表的功能类似于内存管理中的页表–建立逻辑页面到物理页之间的映射关系)<br>索引表存放的磁盘块称为索引块, 文件数据存放的磁盘块称为数据块</p></li></ol><p>目录中记录文件的索引块是几号磁盘块, 得到索引表存放位置后将索引表从外存读入内存, 并查找索引表即可知i号逻辑块在外存中的存放位置</p><p>索引分配方式支持随机访问, 文件拓展也很容易实现,只需分配一个空闲块,并增加一个索引表项<br>但索引表需要占用一定的存储空间</p><p>如果一个文件太大, 一个磁盘块装不下整张索引表, 则可以类似多级页表, 建立多层索引.</p><pre><code>混合索引: 多种索引方式结合, 顶级索引里既包含直接地址索引(直接指向数据块),又包含一级间接索引表,二级间接索引表等多级索引</code></pre><p>##文件存储空间管理<br>磁盘分区: 将物理磁盘划分为一个个文件卷<br>文件卷包含目录区和文件区, 目录区主要存放文件目录信息(FCB), 用于磁盘存储空间管理的信息<br>文件区用于存放文件数据</p><ol><li><p>空闲表法<br> 适用于连续分配<br> 第一个空闲盘块号 | 空闲盘块数</p><p> 与内存管理中的动态分区分配类似, 为一个文件分配连续的存储空间<br> 可采用首次适应,最佳适应,最坏适应等算法来决定为文件分配哪个分区</p></li><li><p>空闲链表法<br> 空闲盘块链: 以盘块为单位组成一条空闲链<br> 空闲盘区链: 以盘区为单位组成一条空闲链</p></li><li><p>位示图法<br>每个二进制位对应一个盘块, “0”代表空闲, “1”代表盘块已分配<br>用(字号,位号)来对应盘块号</p></li><li><p>成组链接法<br>空闲表法和空闲链表法不适用于大型文件系统, 因为空闲表或空闲链表可能过大.<br>UNIX系统中采用了成组链接法对磁盘空闲块进行管理<br>文件卷的目录区中专门用一个磁盘块作为超级块, 当系统启动时需要将超级块读入内存,并且要保证内存与外存中的超级块数据一致<br>超级块相当于一个链头, 规则复杂</p></li></ol><p>##文件共享</p><ol><li>基于索引结点的共享(硬链接)</li><li>基于符号链的共享(软链接)</li></ol><p>多个用户共享同一个文件意味着系统只有”一份”文件数据,并且只要某个用户修改了文件数据,其他用户也可以看到<br>如果是多个用户”复制”了同一个文件, 那么系统中会有好几份文件数据</p><p>##文件保护</p><ol><li><p>口令保护<br> 为文件设置一个”口令”, 用户访问时必须提供”口令”<br> 优: 保存口令的空间开销不多,验证口令的时间开销也很小<br> 缺: 口令存放在系统内部, 不够安全</p></li><li><p>加密保护<br> 使用某个密码对文件加密, 在访问时需要正确解密<br> 如 用”01001”进行异或加密, 只需用户记得”01001”<br> 优: 保密性强,不许再系统中存储密码<br> 缺: 编译/译码需要时间</p></li><li><p>访问控制<br> 每个文件的FCB中增加一个访问控制表, 记录各个用户可对该文件进行哪些操作</p></li></ol><p>##磁盘<br>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据<br>磁盘的盘面被划分为一圈圈磁道。<br>一个磁道又被划分成一个个扇区，每个扇区就是一个个“磁盘块”。各个扇区存放的数据量相同</p><p>如何在磁盘中读写数据：<br>    需要把磁头移动到想要读写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，<br>才能完成对扇区的读写操作<br>每个盘面对应一个磁头，所有磁头都是连在同一个磁臂上的，所有盘面中相对位置相同的磁道组成柱面</p><p>可用（柱面号，盘面号，扇区号）来定位任意一个磁盘块。在“文件的物理结构”小节中，文件数据存放在外存中的几号块<br>这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式</p><ol><li>根据柱面号移动磁臂，让磁头指向指定柱面</li><li>激活指定盘面对应的磁头</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读写</li></ol><p>###磁盘调度算法</p><ol><li>先来先服务算法（FCFS）<br>根据进程请求访问磁盘的先后顺序进行调度<br>假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55，58，39，18，90，160，150，38，184号磁道<br>FCFS算法就按顺序依次访问<br>优点：公平，如果请求访问的磁道比较集中的话，算法性能还行<br>缺点：如果有大量进程竞争使用磁盘，请求访问的磁盘很分散，则FCFS在性能上很差，寻道时间长</li></ol><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><blockquote></blockquote></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ol start="2"><li><p>最短寻找时间优先（SSTF）<br>优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻到时间最短<br>贪心算法的思想<br>优点：性能较好，平均寻道时间短<br>缺点：可能产生”饥饿“现象</p><pre><code>   - -&gt; &lt;- - - - - - - &gt;</code></pre></li><li><p>扫描算法（SCAN）<br>SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回地移动。为了防止这个问题，可以规定，<br>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。<br>由于磁头移动的方式很像电梯，因此也叫电梯算法<br>优点：性能较好，平均寻道时间较短，不会产生饥饿现象<br>缺点：1.只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了<br>   2.SCAN算法对于各个位置磁道的响应频率不平均（假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；<br>   而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</p><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>-&gt;|<br>&lt;- - - - - - - - - - -|</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>LOOK调度算法<br>SCAN算法中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。<br>LOOK算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向（边移动边观察）<br>优点：比起SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>-&gt;  |<br>&lt;- - - - - - - -   |      </li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>循环扫描算法（C-SCAN）<br>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题<br>规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p></li></ol><p>优点：比起SCAN来对于各个位置磁道的响应频率很平均<br>缺点：只有到达最边上才改动磁头移动方向，并且急回时只需要返回18号磁道即可，没必要返回最边缘磁道<br>      - - - - - - - -&gt;|<br>&lt;———————|  急回</p><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>-&gt;|</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><ol start="6"><li><p>C-LOOK调度算法<br>如果磁头移动方向上已经没有访问请求了，就可以让磁头立即返回到最里面有访问请求的磁道</p><ul><li><ul><li><ul><li><ul><li><ul><li>-&gt;    |<br>&lt;————–    |  急回</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>-&gt;   |</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ol><p>###减少磁盘延迟时间的方法<br>寻找时间(寻道时间): 启动磁臂,移动磁头所花的时间<br>延迟时间: 将目标扇区转到磁头下面所花的时间<br>传输时间: 读写数据花费的时间</p><p>磁头读入一个扇区数据需要一小段时间处理,如果逻辑上相邻的扇区物理上也相邻,<br>则读入几个连续逻辑扇区可能要很长的”延迟时间”</p><ol><li><p>交替编号<br>即让逻辑上相邻的扇区在物理上有一定的间隔,可以使读取连续的逻辑扇区所需要的延迟时间更小</p></li><li><p>错位命名<br>让相邻盘面的扇区编号错位<br>上一个盘面的扇区读完后需要隔一段时间处理再读下一个盘面的扇区，因此把对应扇区错位可以减少延迟时间</p></li></ol><p>为什么磁盘的物理地址是(柱面号,盘面号,扇区号)而不是(盘面号,柱面号,扇区号)?<br>    读取地址连续的磁盘块时, 采用(柱面号,盘面号,扇区号)的地址结构可以减少磁头移动消耗的时间</p><p>###磁盘初始化<br>低级格式化/物理格式化：划分扇区<br>磁盘分区（C盘，D盘，E盘）<br>逻辑格式化：建立文件系统（建立根目录文件，建立用于存储空间管理的数据结构）</p><p>引导块：计算机启动时需要运行初始化程序（自举程序）来完成初始化<br>ROM（只读存储器，出厂写入，以后不能再改）中存放很小的自举装入程序<br>完整的自举程序存放在启动块（引导块）中，启动块位于磁盘的固定位置。</p><p>坏块的管理：简单的磁盘：逻辑格式化时将坏块标记出来<br>            复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第三章</title>
      <link href="/2021/05/24/cao-zuo-xi-tong/cao-zuo-xi-tong-di-san-zhang/"/>
      <url>/2021/05/24/cao-zuo-xi-tong/cao-zuo-xi-tong-di-san-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被cpu处理</p><p>逻辑地址与物理地址<br>四个学号分别为0，1，2，3，安排到酒店5，6，7，8号房间<br>0, 1, 2, 3：相对位置 -&gt; 逻辑地址<br>5, 6, 7, 8: 绝对位置 -&gt; 物理地址</p><p>从写程序到程序运行</p><p>程序员 -编辑-&gt; 源代码文件1 ——&gt;目标模块1 (逻辑地址)<br>               源代码文件2 -编译-&gt;目标模块2    —-链接—-&gt;装入模块 形成完整逻辑地址 —&gt;内存 物理地址<br>               源代码文件3 ——&gt;目标模块3</p><p>编译: 由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译成机器语言)<br>链接: 由链接程序将编译后形成的一组目标模块,以及所需库函数链接在一起,形成一个完整的装入模块<br>装入(装载): 由装入程序将装入模块装入内存运行       </p><h3 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h3><pre><code>完成逻辑地址--&gt;物理地址转换</code></pre><ol><li>绝对装入</li><li>静态重定位</li><li>动态重定位</li></ol><p>绝对装入<br>    在编译时,如果知道程序将放到内存中的哪个位置, 编译程序将产生绝对地址的目标地址<br>    绝对装入只适用于单道程序环境</p><p>静态重定位<br>    装入时转换<br>    由装入程序对地址”重定位”, 根据内存情况,将装入模块装入到内存的适当位置<br>    特点: 装入一个作业时,必须分配其要求的全部内存空间.<br>          如果没有足够的内存,就不能装入<br>          作业一旦进入内存,运行期间就不能再移动<br>    早期多道批处理系统</p><p>动态重定位<br>    运行时转换<br>    装入后并不会立即改为物理地址, 而是把地址转换推迟到程序真正要执行时才进行.<br>    因此装入内存的所有地址依然是逻辑地址.<br>    需要一个重定位寄存器的支持,存放装入模块存放的起始位置<br>    允许程序在内存中发生移动(改变寄存器的值), 还可以分配不连续的地区<br>    现代操作系统</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li>OS负责内存空间的分配与回收{连续,非连续}</li><li>OS需要提供某种技术从逻辑上对内存空间进行扩充</li><li>OS需要提供地址转换功能, 负责程序的逻辑地址与物理地址的转换</li><li>OS需要提供内存保护功能,保证各进程在各自存储空间内运行,互不干扰</li></ol><p>两种保护方式</p><ol><li>设置上下限寄存器, 上下限物理地址</li><li>利用重定位寄存器(基址寄存器: 起始物理地址),界地址寄存器(限长寄存器: 最大逻辑地址)</li></ol><p>内存空间的扩充<br>    覆盖技术<br>    交换技术<br>    虚拟存储技术</p><h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3><ol><li><p>覆盖技术<br> 用来解决”程序大小超过物理内存总和”的问题<br> 将程序分为多个段(多个模块).<br> 常用的段常驻内存, 不常用的段在需要时调入内存</p><p> 内存中分为一个”固定区”和若干个”覆盖区”</p><p> 必须由程序员声明覆盖结构,操作系统完成自动覆盖.<br> 缺点: 对用户不透明,增加了用户编程负担<br> 现已经很少使用了</p></li><li><p>交换技术<br> 内存空间紧张时,系统将内存中某些进程暂时换出内存(挂起),<br> 把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p><p> PCB常驻内存</p><p> 中级调度(内存调度), 就是要决定将哪个处于挂起状态的进程重新调入内存</p><p> 磁盘存储分成文件区和对换区<br> 文件区主要用于存放文件, 主要追求存储空间的利用率, 采用离散分配方式<br> 对换区只占磁盘的小部分, 被换出的进程存于此, 采用连续分配方式, 追求换入换出的速度<br> 对换区的I/O速度比文件区更快</p><p> 覆盖是在同一个程序或进程中进行<br> 交换是在不同进程或作业之间进行的</p></li></ol><h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3><pre><code>为用户进程分配的必须是一个连续的内存空间单一连续分配固定分区分配动态分区分配</code></pre><p>单一连续分配<br>    内存被分为系统区和用户区<br>    系统区通常位于内存的低地址部分,用于存放操作系统相关数据;<br>    用户区只能有一道用户程序, 用户程序独占整个用户空间</p><pre><code>优点: 实现简单; 无外部碎片; 可以采用覆盖技术扩充内存;      不一定需要采取内存保护缺点: 只能用于单用户,单任务的OS中, 有内部碎片(分配给某进程的内存区域中,如果有些部分没有用上, 就是内部碎片);      存储器利用率低</code></pre><p>固定分区分配<br>    为了能在内存中装入多道程序,且这些程序不会相互干扰, 将用户空间划分为若干个固定大小的分区,<br>    在每个分区中只装入一道作业</p><pre><code>系统区  分区1  分区2  分区3 ...分区大小相等: 缺乏灵活性, 但适用于一台计算机控制多个相同对象的场合分区大小不相等: 增加灵活性, 可以满足不同大小的进程需求OS需要建立一个分区说明表来实现各个分区的分配与回收优点: 实现简单, 无外部碎片缺点: 如果程序太大,所有分区都无法满足则只能使用覆盖技术解决, 会产生内部碎片</code></pre><p>动态分区分配<br>    可变分区分配, 这种分配方式不会预先划分内存分区, 而是在进程装入内存时,<br>    根据进程的大小动态地建立分区, 并使分区的大小正好适合进程的需要.<br>    因此分区的大小和数目是可变的</p><pre><code>系统要用什么样的数据结构记录内存的使用情况呢?两种常用的数据结构: 空闲分区表                    空闲分区链动态分区分配没有内部碎片，但是有外部碎片内部碎片：分配给某进程的内存区域中，如果有些部分没有用上外部碎片：是指内存中的某些分区由于太小而难以利用如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间因此这些“碎片”不能满足进程的需求可以通过紧凑技术来解决外部碎片，动态重定位装入，修改重定位寄存器动态分区分配算法    当多个空闲分区满足需求时，应该选哪个分区进行分配？    1. 首次适应算法    2. 最佳适应算法    3. 最坏适应算法    4. 邻近适应算法首次适应算法    思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区    实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)          找到大小能满足要求的第一个空闲分区最佳适应算法    思想: 由于动态分区分配是一种连续分配方式,为各进程分配的空间必须是连续的一整片区域.          因此为了保证当"大进程"到来时能有连续的大片空间, 可以尽可能多的留下大片的空闲区          即优先使用更小的空闲区    实现: 空闲分区按容量递增次序链接. 每次分配内存时顺序查找空闲分区链(或空闲分区表)          找到大小能满足要求的第一个空闲分区    缺点: 每次都选最小的分区进行分配, 会留下越来越多的,很小的,难以利用的内存块.          因此这种方法会产生很多外部碎片最坏适应算法    又称最大适应算法    思想: 为了解决最佳适应算法的问题(即留下太多难以利用的小碎片),可以在每次分配时优先使用最大的连续空闲区          这样分配后的空闲区就不会太小,更方便使用.     实现: 空闲分区按容量递减次序链接. 每次分配内存时顺序查找空闲分区链(或空闲分区表)          找到大小能满足要求的第一个空闲分区    缺点: 每次都选最大的分区进行分配, 虽然可以让分配后留下的空闲区更大更可用,但是这种方式会导致较大的连续空闲去被迅速用完          如果之后有大进程到达,就没有内存分区可用了邻近适应算法    思想: 首次适应算法每次都从链头开始查找. 这可能会导致低地址部分出现很多小的空闲分区          而每次分配查找时, 都要经过这些分区, 因此也增加了查找的开销.          如果每次都从上次查找结束的位置开始检索,就能解决上述问题    实现: 空闲分区以地址递增的次序排列。每次分配内存时从上次查找结束的位置查找空闲分区链(或空闲分区表)          找到大小能满足要求的第一个空闲分区首次适应算法每次都要从头开始查找,每次都检索低地址的小分区. 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时会更有可能用到低地址部分的小分区, 也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)邻近适应算法的规则可能会导致无论低地址,高地址部分的空闲分区都有相同的概率被使用,也就导致了高地址部分的大分区更可能被使用,从而划分为小分区,最后导致无大分区可用(最大适应算法的缺点)四种算法综合来看，反而是首次适应算法更好</code></pre><h3 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h3><p>连续分配方式的缺点<br>支持多道程序的两种连续分配方式</p><ol><li>固定分区分配: 缺乏灵活性, 会产生大量的内部碎片, 内存的利用率很低</li><li>动态分区分配: 会产生很多外部碎片,虽然可以用”紧凑”技术来处理, 但是”紧凑”的时间代价很高</li></ol><p>如果允许将一个进程分散地装入到许多不相邻的分区中, 便可充分地利用内存,而无需再进行”紧凑”<br>基于这一思想, 产生了”非连续分配方式”, 或者称为”离散分配方式”</p><p>连续分配: 为用户进程分配的必须是一个连续的内存空间<br>非连续分配: 为用户进程分配的可以是一些分散的内存空间</p><p>基本分页存储的管理的思想：把内存分为一个个相等的小分区,每个分区就是一个”页框”,页框号从0开始.<br>    再按照分区大小把进程拆分成一个个小部分, 称为页,从0开始. 各个页面不必连续存放</p><p>如何实现了逻辑地址到物理地址的转换<br>    1. 算出逻辑地址对应的页号<br>    2. 要知道该页号对应页面在内存中的起始地址<br>    3. 算出逻辑地址在页面内的偏移量<br>    4. 物理地址=页面地址+页面偏移量</p><pre><code>页号 = 逻辑地址/页面长度业内偏移量=逻辑地址%页面长度如果每个页面大小为2^k B,用二进制表示逻辑地址, 则末尾k位即为页内偏移量其余部分就是页号为了知道进程的每个页面在内存中存放的位置,操作系统要为每个进程建立一张页表页表记录每个页面存进哪个页框页号  块号(页框号)=&gt; 物理地址=页框起始地址+页内偏移量</code></pre><p>基本地址变换机构<br>    基址地址变换机构可以借助进程的页表将逻辑地址转换为物理地址<br>    通常会在系统中设置一个页表寄存器(PTR), 存放页表在内存中的起始地址F和页表长度M.<br>    进程未执行时,页表的始址和页表长度放在进程控制块(PCB)中,当进程被调度时,<br>    操作系统内核会把他们放到页表寄存器中</p><pre><code>地址变换过程    1. 根据逻辑地址算出页号、页内偏移量    2. 页号的合法性检查(与页表长度对比)    3. 若页号合法, 再根据页表起始地址, 页号找到对应页表项    4. 根据页表项中记录的内存块号,页内偏移量 得到最终物理地址    5. 访问物理内存对应的内存单元</code></pre><p>具有快表的地址变换机构</p><pre><code>时间局部性: 如果执行了程序中的某条指令, 那么不久后这条指令很有可能再次执行;            如果某个数据被访问过,不久之后该数据很有可能再次被访问空间局部性: 一旦程序访问了某个存储单元, 在不久之后, 其附近的存储单元也很有可能被访问            因为很多数据在内存中都是连续存放的基本地址变换机构中, 每次都要访问一个逻辑地址,都需要查询内存中的页表.由于局部性原理,可能连续很多次查到的都是同一个页表项. 利用此特性减少访问页表的次数快表, 又称联想寄存器(TLB), 是一种访问速度比内存快很多的高速缓冲存储器,用来存放当前访问的若干页表项, 以加速地址变换的过程. 与此对应, 内存中的页表常称为慢表引入快表后地址的变换过程1. cpu给出逻辑地址, 由某个硬件算得页号,页内偏移量, 将页号与快表中的所有页号比较2. 如果找到匹配的页号, 则直接从快表中取出该页对应的内存块号,再将内存块号与页内偏移量拼接形成物理地址   仅需一次访存3. 如果没有匹配的页号,则需要访问内存中的页表, 找到对应页表项,得到页面存放的内存块号   同时复制到快表中.   需要两次访存</code></pre><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>单级页表存在的问题<br>问题1: 页表必须连续存放,因此当页表很大时,需要占用很多个连续的页框<br>问题2: 没有必要让整个页表常驻内存,因为进程在一段时间内可能只需要访问几个特定的页面</p><p>如何解决进程在内存中必须连续存储的问题的?<br>将进程地址空间分页, 并为其建立一张页表, 记录各页面的存放位置</p><p>同理, 可以把连续存放的页表再分页以解决问题1</p><p>一级页号|二级页号|页内偏移量</p><p>页目录表(顶级页表) —&gt;0#页表(二级页表) —&gt;内存块<br>                   —&gt;1#页表            —&gt;内存块<br>                   —&gt;2#页表            —&gt;内存块</p><p>如何实现地址变换</p><ol><li>按照地址结构将逻辑地址分成三部分</li><li>从PCB中读出页目录表始址, 再根据一级页号查页目录表, 找到下一级页表再内存中的存放位置</li><li>根据二级页号查表, 找到最终想访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><p>对于问题2<br>可以在需要访问页面时才把页面调入内存(虚拟存储技术). 可以在页表项中增加一个标志位,由于表示该页面是否已经调入内存<br>若想访问的页面不在内存中,则产生缺页中断(内中断),然后将目标页面从外存调入内存</p><p>N级页表访问一个逻辑地址需要N+1次访存</p><h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><p>与分页最大的区别就是离散分配时所分配地址空间的基本单位不同</p><p>分段 类似于分页<br>段表 类似于页表</p><p>进程的地址空间: 按照程序自身的逻辑关系划分为若干个段, 每个段都有一个段名(在低级语言中,程序员使用段名来编程)<br>                每段从0开始编址</p><p>内存分配规则: 以段为单位进行分配, 每个段在内存中占据连续空间, 但各段之间可以不相邻</p><p>分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成</p><p>段号|段内地址</p><p>段号的位数决定了每个进程最多可以分几个段<br>段内地址位数决定了每个段的最大长度是多少</p><p>程序分多个段, 各段离散地装入内存,为了保证程序能正常运行,就必须能从物理内存中找到各个逻辑段的存放位置<br>为此,需为每个进程建立一张段映射表, 简称段表</p><ol><li>每个段对应一个段表项, 其中记录理该段在内存中的起始位置(又称基址)和段的长度<br>段号 | 段长 | 基址 </li><li>各个段表项的长度是相同的,因此段号可以是隐含的, 不占存储空间</li></ol><p>对比:<br>    页是信息的物理单位. 分页目的是为了实现离散分配, 提高内存利用率.<br>    仅仅系统管理需要,对用户是不可见的<br>    段是信息的逻辑单位. 主要目的是满足用户需求, 对用户是可见的<br>    分页的用户进程地址空间是一维的,程序员仅需给出一个记忆符即可表示一个地址<br>    分段的用户进程地址空间是二维的,程序员在标识一个地址时, 既要给出段名,也要给出段内地址</p><p>分段更容易实现信息的共享与保护<br>不能被修改的代码称为纯代码或可重入代码(不属于临界资源). 这样的代码是可共享的</p><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p>分段,分页的优缺点<br>分页: 优: 内存利用率高,不产生外部碎片,会有少量内部碎片<br>      缺: 不方便按照逻辑模块实现共享与保护<br>分段: 优: 更容易实现信息的共享与保护<br>      缺: 如果段长很大,为其分配很大的连续空间会很不方便.会产生外部碎片</p><p>经典折中<br>=&gt;<br>先分段再分页<br>         0号段—&gt;0号页<br>              —&gt;1号页</p><p>进程—&gt; 1号段—&gt;0号页<br>              —&gt;1号页</p><pre><code>     2号段---&gt;0号页</code></pre><p>段页式<br>段号 | 页号 | 页内偏移<br>段号位数决定了每个进程最多可以分多少段<br>页号位数决定了每个段最大有多少页<br>页内偏移量决定了页面大小,内存块大小是多少</p><ol><li>由逻辑地址得到段号,页号,页内偏移量</li><li>段号与段表寄存器中的段长度比较,检查是否越界</li><li>由段表始址,段号找到对应段表项</li><li>根据段表中记录的页表长度,检查页号是否越界</li><li>由段表中的页表地址,页号得到查询页表,找到相应页表项</li><li>由页面存放的内存块号,页内偏移量得到最终的物理地址</li><li>访问目标单元</li></ol><p>引入快表, 若快表命中则仅需一次访存(用段号和页号作为查询关键字)</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>传统存储管理{<br>    连续分配{<br>        单一连续分配<br>        固定分区分配<br>        动态分区分配<br>    }<br>    非连续分配{<br>        基本分页存储管理<br>        基本分段存储管理<br>        基本段页式存储管理<br>    }<br>}</p><p>传统存储管理中, 很多暂时用不到的数据也会长期占用内存, 导致内存利用率不高<br>一次性: 作业必须一次性全部装入内存后才能开始运行, 会造成两个问题:<br>        1. 作业很大时,不能全部装入内存,导致大作业无法运行<br>        2. 当大量作业要求运行时, 由于内存无法容纳所有作业,因此只有少量作业能运行,导致多道程序并发度下降</p><p>驻留性: 一旦作业被装入内存,就会一直驻留在内存中,直至作业运行结束. 事实上,在一个时间段内,<br>        只需要访问作业的一小部分数据即可正常运行, 这就导致了内存中会驻留大量的,暂时用不到的数据<br>        浪费了宝贵的内存资源</p><p>高速缓冲技术的思想: 将近期会频繁访问到的数据放到更高速的存储器中,暂时用不到的数据放在更低速的存储器中</p><p>寄存器–&gt;高速缓存–&gt;内存–&gt;外存(如磁盘,磁带)</p><p>容量小,速度快,成本高&lt;—-&gt;容量大,速度慢,成本低</p><p>基于局部性原理,在程序装入时,可以将程序中很快会用到的部分装入内存, 暂时用不到的部分留在外存<br>就可以让程序开始执行<br>在程序执行过程中,当所访问的信息不在内存时,由操作系统负责将所需信息从外存调入内存,<br>然后继续执行程序<br>若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存.<br>在操作系统的管理下,在用户看来似乎有一个比实际内存大得多的内存,这就是虚拟内存</p><p>虚拟内存有以下三个主要特征:<br>多次性: 无需在作业运行时一次性全部装入内存,而是允许被分成多次调入内存<br>对换性: 在作业运行时无需一直常驻内存,而是允许在作业运行过程中,将作业换入换出<br>虚拟性: 从逻辑上扩充了内存的容量,使用户看到的内存容量,远大于实际的容量</p><p>虚拟内存技术的实现需要建立在离散分配的内存管理方式基础上</p><ol><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ol><p>主要区别: 在程序执行过程中,当所访问的信息不再内存时,由操作系统负责将所需信息从外存调入内存,然后继续执行程序<br>          若内存空间不够,由操作系统负责将内存中暂时用不到的信息换出到外存</p><p>操作系统要提供请求调页(或请求调段)功能<br>操作系统要提供页面置换（或段置换）功能</p><p>请求分页存储管理<br>    页表机制<br>    缺页中断机构<br>    地址变换机构</p><p>请求页表新增了四个字段<br>    页号 | 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址<br>状态位: 是否已经调入内存<br>访问字段: 记录最近被访问过几次,或记录上次访问的时间,供置换算法选择换出页面时参考<br>修改位: 页面调入内存后是否被修改过<br>外存地址: 页面在外存中的存放位置</p><p>在请求分页系统中,每当要访问的页面不在内存时, 便产生一个缺页中断,<br>然后由操作系统的缺页中断处理程序处理中断<br>此时缺页的进程阻塞, 放入阻塞队列,调页完成后再将其唤醒, 放回就绪队列</p><p>如果内存中有空闲块, 则为进程分配一个空闲块, 将所缺页面装入该块, 并修改页表中相应的页表项<br>如果内存中没有空闲块, 则由页面置换算法选择一个页面淘汰,<br>若该页面在内存期间被修改过, 则要将其写回外存, 未修改过的页面不用写回外存</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>页面的换入,换出需要磁盘I/O, 会有比较大的开销<br>因此好的页面置换算法应该追求更少的缺页率</p><ol><li><p>最佳置换算法(OPT)<br> 每次选择淘汰的页面将是以后永不使用,或者在最长时间内不再被访问的页面, 这样可以保证最低的缺页率</p><p> 理想化算法, 实际上无法实现</p></li><li><p>先入先出算法(FIFO)<br> 每次淘汰最早进入内存的页面<br> 实现方法: 把调入内存的页面根据调入的先后顺序排成一个队列, 需要换出页面时选择队头页面即可</p><pre><code>       队列的最大长度取决于系统为进程分配了多少内存块</code></pre><p> Belady异常–当为进程分配的物理块数增大时,缺页次数不减反增的异常现象<br> 只有FIFO算法会产生Belady异常,另外,FIFO算法虽然实现简单,但是该算法与进程实际运行时的规律不适应<br> 因为先进入的页面也有可能最经常被访问. 因此算法性能差</p></li><li><p>最近最久未使用算法(LRU, least recently used)<br> 每次淘汰的页面是最近最久未使用的页面<br> 实现方法: 赋予每个页面对应的页表项中, 用访问字段记录该页面自上次被访问以来所经历的时间t</p><pre><code>       当需要淘汰一个页面时,选择现有页面中t最大的</code></pre><p> 该算法的实现需要专门的硬件支持,虽然算法性能好,但是实现困难,开销大</p></li><li><p>时钟置换算法(CLOCK)<br> 一种性能和开销较均衡的算法<br> 又称为最近未用算法(NRU, not recently used)<br> 简单的CLOCK算法实现方法: 每个页面设置一个访问位, 再将内存中的页面都通过链接指针链接成一个队列</p><pre><code> 当某页被访问时, 其访问位置为1. 当需要淘汰一个页面时, 只需要检查页的访问位. 如果是0,就选择该页换出; 如果是1, 则将他置为0,暂不换出,继续检查下一个页面, 若第一轮扫描中所有页面都是1, 则将这些页面的访问位依次置为0后,再进行第二轮扫描 (第二轮扫描中一定会有访问位为0的页面, 因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</code></pre><p> 改进的时钟置换算法:</p><pre><code> 简单时钟仅考虑一个页面最近是否被访问过. 事实上, 如果被淘汰的页面没有被修改过, 就不需要执行I/O操作写回外存.只有被淘汰的的页面被修改过时才需要写回外存 在其他条件都相同时, 优先淘汰没有修改过的页面, 避免I/O操作 修改位=0表示没被修改过 用(访问位,修改位)表示各页面状态</code></pre><p> 算法规则: 将所有可能被置换的页面排成一个循环队列</p><pre><code> 第一轮: 从当前位置开始扫描到第一个(0,0)的帧用于替换.          本轮扫描不修改任何标志位 第二轮: 若第一轮扫描失败,则重新扫描,查找第一个(0,1)的帧用于替换,         本轮将所有扫描过的帧访问位设为0 第三轮: 若第二轮扫描失败,则重新扫描,查找第一个(0,0)的帧用于替换,         本轮扫描不修改任何标志位 第四轮: 若第三轮扫描失败,则重新扫描,查找第一个(0,1)的帧用于替换</code></pre><p> 第一轮–&gt;第一优先级: 最近没访问,且没有修改过的页面<br> 第二轮–&gt;第二优先级: 最近没访问,但修改过的页面<br> 第三轮–&gt;第三优先级: 最近访问过,但没修改过的页面<br> 第四轮–&gt;第四优先级: 最近访问过且修改过的页面</p><p> 算法开销较小, 性能也不错</p></li></ol><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><p>驻留集: 指请求分页存储管理中给进程分配的物理块的集合</p><p>在采用了虚拟存储技术的系统中,驻留集大小一般小于进程的总大小<br>若驻留集太小, 会导致缺页频繁, 若太大, 会导致多道程序并发度下降</p><p>固定分配:<br>    OS为每个进程分配一组固定数组的物理块, 在进程运行期间不再改变, 即驻留集大小不变</p><p>可变分配:<br>    先为每个进程分配一定的物理块,运行期间可改变</p><p>局部置换:<br>    发生缺页时只能选进程自己的物理块置换<br>全局置换:<br>    可以将OS保留的空闲物理块分配给缺页进程, 也可以将别的进程持有的物理块置换到外存<br>    再分配给缺页进程</p><pre><code>        局部置换    全局置换</code></pre><p>固定分配       有           无<br>可变分配       有          有</p><p>可变分配全局置换: 只要缺页就给分配新的物理块<br>可变分配局部置换: 要根据发生缺页的频率来动态地增加或减少进程的物理块</p><p>何时调入页面</p><ol><li><p>预调页策略: 根据局部性原理, 依次调入若干个相邻的页面可能比一次调一个更高效,</p><pre><code>        但如果调入的页面大多数没有被访问,则又是低效的        主要用于进程的首次调入</code></pre></li><li><p>请求调页策略:<br> 进程在运行期间发现缺页时才将所缺页面调入内存. 由这种策略调入的页面一定会被访问到<br> 但由于每次只调入一页,每次调页都要磁盘I/O操作,因此I/O开销较大</p></li></ol><p>从何处调页<br>    对换区: 采用连续存储,速度比文件区更快</p><pre><code>对换区足够大: 运行前将数据复制从文件区到对换区, 之后所有的出入都在内存与对换区之间进行对换区不够大: 不会修改的数据每次都从文件区调入;              会修改的数据调出到对换区, 需要时再从对换区调入UNIX方式: 第一次使用的都从文件区调入, 调出的写回对换区,再使用时从对换区调入</code></pre><p>抖动现象<br>    刚刚换出的页面马上又要调入内存, 刚刚换入的页面马上又要换出, 这种频繁的页面调度行为称为抖动<br>    主要是因为分配给进程的物理块不够</p><p>工作集: 指在某段时间间隔里,进程实际访问页面的集合</p><p>工作集大小可能小于窗口尺寸<br>驻留集大小不能小于工作集大小,否则进程运行过程中将频繁缺页</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第二章</title>
      <link href="/2021/05/10/cao-zuo-xi-tong/cao-zuo-xi-tong-di-er-zhang/"/>
      <url>/2021/05/10/cao-zuo-xi-tong/cao-zuo-xi-tong-di-er-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>程序：就是一个指令序列<br>进程：程序的一次执行过程</p><p>单道程序<br>程序的代码放在程序段内，程序运行过程处理的数据放在数据段内</p><p>多道程序技术：多道程序并发执行<br>系统为每个运行的程序配置一个数据结构，称为进程控制块（PCB）<br>用来存放进程描述信息，进程控制和管理信息，资源分配清单，处理机相关信息</p><p>PCB，程序段，数据段三部分构成了进程实体<br>所谓创建进程，实质上就是创建进程实体中的PCB；而撤销进程实质上是撤销进程实体中的PCB</p><p>PCB是进程存在的唯一标志</p><p>进程的组织方式：<br>链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针<br>执行指针指向当前处于运行态的指针<br>就绪队列指针指向就绪队列的队首，通常把优先级较高的放在队首<br>阻塞队列指向处于阻塞态的进程</p><p>索引方式：根据进程状态不同，建立几张索引表，操作系统持有指向各个索引表的指针<br>执行指针指向当前处于运行态的指针<br>就绪表<br>阻塞表</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>运行状态，就绪状态，阻塞状态，创建状态，终止状态</p><p>三种基本状态<br>运行态：占有CPU，并在CPU上运行<br>就绪态：拥有了除处理机之外所有需要的资源，但由于没有空闲CPU，暂时不能运行一旦获得处理机即可立即进入运行态<br>阻塞态：等待操作系统分配资源</p><p>进程状态间的转换<br>创建态-&gt;就绪态<br>就绪态&lt;-&gt;运行态 进程被调度进入运行态,时间片到了或处理机被抢占返回就绪态<br>运行态-&gt;阻塞态 进程用系统调用的方式申请某种系统资源,或请求某件事情发生(主动) 进入阻塞态<br>阻塞态-&gt;就绪态 申请的资源被分配,或者等待的事件发生,进入就绪态<br>运行态-&gt;终止态 进程运行结束或运行过程遇到不可修复的错误</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程,撤销已有进程,实现进程状态转换等功能</p><p>状态转换时需修改PCB内容和相应队列防止内容与队列不一致发生错误,使用原语实现进程控制</p><p>原语特点: 不允许终端</p><p>关中断指令<br>原语代码<br>开中断指令</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>指进程之间的信息交换<br>进程是分配系统资源的单位,因此各进程拥有的内存地址空间相互独立</p><p>为了保证安全,一个进程不能直接访问另一个进程的地址空间.<br>但是进程之间的信息交换又是必须实现的. 为了保证进程间的安全通信,操作系统提供了一些方法</p><p>共享存储<br>    操作系统为进程分配共享空间<br>    两个进程对共享空间互斥访问<br>    1. 基于数据结构的共享: 比如共享空间里只能放一个长度为10的数组,<br>        这种方式速度慢,限制多,是一种低级通信方式<br>    2. 基于存储区的共享: 在内存中画出一块共享存储区,数据的形式,存放位置都由进程控制,而不是操作系统<br>        相比之下更快,是一种高级通信方式</p><p>管道通信<br>    管道是指用于连接读写进程的一个共享文件,实际上就是在内存中开辟一个大小固定的缓冲区<br>    进程1写数据到管道,进程2从管道读数据<br>    1没写满2不能读,2没读空1不能写<br>    各进程互斥访问</p><pre><code>管道只能采用半双工通信,要实现双向通信,需要设置两个管道</code></pre><p>消息传递<br>    进程间的数据交换以格式化的消息为单位. 进程通过操作系统提供的发送消息/接收消息两个原语进行数据交换<br>    1. 直接通信方式<br>        进程通过发送原语创建消息,消息直接挂到接受进程的消息缓冲队列上,接受进程通过接收原语依次读取消息<br>    2. 间接通信方式<br>        消息要先发送到中间实体(信箱)中,系统管理这些消息,具体是哪些进程发,哪些进程收都写在消息头里</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有的进程可能需要同时做很多事，而传统的进程只能串行地执行一系列程序。<br>为此引入线程来增加并发度<br>引入线程后，线程成了程序执行流的最小单位</p><p>线程的属性：<br>线程是处理机调度的单位，进程是资源分配的单位<br>多CPU计算机中，各个线程占用不同的cpu<br>每个线程都有一个线程ID，线程控制块（TCB）<br>线程也有就绪，阻塞，运行三种基本状态<br>线程几乎不拥有系统资源<br>同一进程的不同线程间共享进程的资源<br>由于共享内存地址空间，同一进程的线程间通信甚至无需系统干预<br>同一进程中的线程切换，不会引起进程切换，系统开销小<br>不同进程中的线程切换，会引起进程切换，系统开销大</p><p>线程的实现方式<br>用户级线程：从用户角度看的线程<br>内核级线程：从操作系统视角看的线程，内核级线程才是处理机分配的单位</p><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><p>从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现并发</p><p>作业调度：<br>    高级调度，按一定的原则从外存上处于后备队列的作业中挑选一个或多个作业，给他们分配内存等必要资源<br>    并建立相应的进程（建立PCB），以使他们获得竞争处理机的权利。</p><pre><code>高级调度是外存与内存之间的调度，每个作业只调入一次，调出一次，调入时PCB创建，调出时PCB撤销</code></pre><p>内存调度：<br>    中极调度，引入虚拟存储技术后，可将暂时不能运行的进程调至外存等待。<br>    等他重新具备运行条件且内存又稍有空闲时，再重新调入内存<br>    提高内存利用率和系统吞吐量<br>    暂时调出的进程状态为挂起状态，PCB并不会一起调出</p><p>挂起与阻塞的区别：两种状态都是暂不能获得CPU的服务<br>    但挂起态将进程映像调到外存去，阻塞态进程映像还在内存中</p><p>进程调度：<br>    低级调度，从就绪队列中选取一个进程，将处理机分配给他<br>    是操作系统中最基本的一种调度</p><h3 id="进程调度与进程切换的区别"><a href="#进程调度与进程切换的区别" class="headerlink" title="进程调度与进程切换的区别"></a>进程调度与进程切换的区别</h3><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。<br>这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况需要进程切换<br>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</p><p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p><p>进程切换的过程主要完成了<br>    1. 对原来运行进程各种数据的保存<br>    2. 对新的进程各种数据的恢复</p><p>进程切换是有代价的，因此如果过于频繁的进行进程调度，切换，必然使整个系统效率降低</p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p>cpu利用率：指cpu忙碌的时间占总时间的比例<br>系统吞吐量：单位时间内完成作业的数量<br>周转时间：从作业提交给系统到作业完成为止的间隔=作业完成时间-作业提交时间<br>    平均周转时间=各作业周转时间之和/作业数<br>    带权周转时间=作业周转时间/作业实际运行时间 （越小越好）<br>    平均带权周转时间=各作业带权周转时间之和/作业数</p><p>等待时间：进程/作业处于等待处理机状态时间之和，时间越长，用户满意度越低</p><p>响应时间：从用户提交请求到首次产生响应所用的时间</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>{<br>  先来先服务 FCFS<br>  短作业优先 SJF<br>  高响应比优先 HRRN<br>}</p><ol><li><p>先来先服务 First Come First Serve<br>算法思想： 主要从公平的角度考虑，类似于排队买东西<br>算法规则：按照作业/进程到达的先后顺序进行服务<br>用于作业/进程调度：用于作业调度时，考虑是哪个作业先到达后备队列</p><pre><code>            用于进程调度时，考虑是哪个进程先到达就绪队列</code></pre><p>是否可抢占：非抢占式算法<br>优缺点：<br> 优点：公平，算法实现简单<br> 缺点：排在长作业/进程后面的短作业需要等待很长时间，带权周转时间很大，</p><pre><code>   对短作业来说用户体验不好。即FCFS对长作业有利，对短作业不利</code></pre><p>是否会导致饥饿：不会</p></li><li><p>短作业优先 Shortest Job First<br>算法思想：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间<br>算法规则：最短作业/进程优先得到服务，所谓最短，是指要求服务时间最短<br>用于作业/进程调度：可用于作业调度也可用于进程调度，用于进程调度叫SPF，短进程优先<br>是否可抢占：SJF和SPF都是非抢占式，也有抢占式版本-最短剩余时间优先算法 SRTN<br>优缺点：<br> 优：“最短的”平均等待时间，平均周转时间<br> 缺：不公平，短作业有利，长作业不利<br>是否会导致饥饿：会，如果源源不断的短作业，可能使长作业饥饿，一直得不到会“饿死”</p><p> 最短剩余时间优先算法<br> 每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短<br> 则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p></li><li><p>高响应比优先 Highest Response Ratio Next<br>算法思想：要综合考虑作业/进程的等待时间和要求服务的时间<br>算法规则：每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业为其服务</p><pre><code>   响应比=（等待时间+要求服务时间）/要求服务时间</code></pre><p>用于作业/进程调度：可以用于作业调度也可以用于进程调度<br>是否可抢占：非抢占式的算法，只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比<br>优缺点：<br> 综合考虑了等待时间和运行时间（要求服务时间）<br> 等待时间相同时，要求服务时间短的优先（SJF的优点）<br> 要求服务时间相同时，等待时间长的优先（FCFS的优点）<br> 对于长作业优先来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题<br>是否会导致饥饿：不会</p></li></ol><p>这三种算法一般适合用于早期的批处理系统。</p><h3 id="适用于交互式系统的调度算法"><a href="#适用于交互式系统的调度算法" class="headerlink" title="适用于交互式系统的调度算法"></a>适用于交互式系统的调度算法</h3><p>时间片轮转轮转调度算法<br>优先级调度算法<br>多级反馈队列算法</p><ol><li>时间片轮转轮转调度算法 Round-Robin<br>算法思想：公平地，轮流地为各个进程服务，让每个进程在一定时间间隔内都能得到响应<br>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，<pre><code>   则剥夺处理机，将进程重新放到就绪队列队尾重新排队</code></pre>用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）<br>是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权。属于抢占式算法<br>优缺点：<br> 优：公平，响应快，是用于分时操作系统<br> 缺：高频率的进程切换，因此会有一定开销，不区分任务紧急程度<br>是否会导致饥饿：不会</li></ol><p>如果时间片太大，使得每一个进程都能在一个时间片内就完成，则时间片轮转调度算法会退化为先来先服务算法<br>因此时间片不能太大<br>另一方面，进程调度，切换是有时间代价的，如果时间片太小，会导致进程切换过于频繁，系统会花大量时间来处理进程切换<br>因此时间片也不能太小</p><ol start="2"><li>优先级调度算法<br>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序<br>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程<br>用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至还可用于I/O调度<br>是否可抢占：抢占式，非抢占式都有。<br>优缺点：<br> 优：用优先级区分紧急程度，重要程度，是用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度<br> 缺：若源源不断地有高优先级的进程到来，则可能导致饥饿<br>是否会导致饥饿：会</li></ol><p>静态优先级：创建进程时确定，之后一直不变<br>动态优先级：创建进程时有一个初始值，之后会动态调整</p><ol start="3"><li>多级反馈队列算法<br>折中</li></ol><p>算法思想：对其他调度算法的折中权衡<br>算法规则：<br>    1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大<br>    2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片<br>       若用完时间片进程还未结束，则进程进入下一级队列队尾，如果此时已经是最下级的队列<br>       则重新放回该队列队尾<br>    3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片<br>    被抢占处理机的进程重新放回原队列队尾，不会放入下一级</p><p>用于作业/进程调度：用于进程调度<br>抢占：抢占式的算法。在k级队列的进程运行过程中，若更上级的队列中进入一个新进程，<br>      因此新进程会抢占处理机，原来运行的进程放回k级队列队尾<br>优缺点：集大成<br>是否会导致饥饿：会</p><h2 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h2><p>同步，亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，<br>这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系</p><p>我们把一个时间段内允许一个进程使用的资源称为临界资源<br>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。</p><p>进程互斥的软件实现方法<br>单标志法<br>双标志先检查<br>双标志后检查<br>Peterson算法</p><ol><li>单标志法<br>算法思想：两个进程在访问完临界区后会把使用临界区的权限交给另一个进程<pre><code>   也就是说，每个进程进入临界区的权限只能被另一个进程赋予</code></pre></li></ol><p>主要问题：违背了空闲让进原则</p><ol start="2"><li>双标志先检查法<br>算法思想：设置一个布尔型数组flag[]， 数组中各个元素用来标记各进程想进入临界区的意愿<br>比如flag[0]=true意味着0号进程现在想要进入临界区。每个进程在进入临界区之前先检查当前<br>有没有别的进程想进临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</li></ol><p>主要问题：违反忙则等待原则<br>while(flag[1]);<br>flag[0]=true;<br>访问临界区</p><p>原因在于，进入区的检查和上锁两个处理不是一气呵成的。检查后，上锁前可能发生进程变换</p><ol start="3"><li>双标志后检查<br>算法思想: 双标志位检查法的改版,前一个算法的问题是先检查,后上锁,但是这两个操作又无法一气呵成<br>因此导致了两个进程同时进入临界区的问题. 因此,人们又想到了先上锁后检查<br>flag[0]=true;<br>while(flag[1]);<br>访问临界区</li></ol><p>主要问题: 虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则<br>会因各进程都长期无法访问临界资源而产生饥饿现象</p><ol start="4"><li>Peterson算法<br>算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，<br>最后谁都无法进入临界区。如果双方都争着向进入临界区，那可以让进程尝试孔融让梨<br>主动让对方先使用临界区<br>boolean[] flag；表示进入临界区意愿的数组<br>int turn；表示优先让哪个进程进入临界区</li></ol><p>flag[0]=true；<br>turn =1；<br>while(flag[1]&amp;&amp;turn = 1);<br>访问临界区</p><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进，忙则等待，有限等待的原则。<br>但依然未遵循让权等待的原则</p><p>进程互斥的硬件实现方法</p><ol><li>中断屏蔽方法</li></ol><p>关中断<br>临界区<br>开中断 </p><p>利用开关中断指令实现，与原语的实现思想相同，即在某进程开始访问临界资源到结束访问为止不允许被中断<br>也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况</p><p>优点：简单、高效<br>缺点：不适用于多处理机：只适用于操作系统内核进程，不适用于用户进程（因为开关中断指令只能运行在内核态，<br>      这组指令如果让用户随意使用会很危险）</p><ol start="2"><li><p>TestAndSet指令<br>简称TS指令或TSL指令<br>优点：实现简单，适用于多处理机环境<br>缺点：不满足让权等待</p></li><li><p>Swap指令</p></li></ol><p>信号量机制<br>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），<br>可以用一个信号量来表示系统中某种资源的数量<br>比如：系统中只有一台打印机，就可以设置一个初值为1的信号量</p><p>用户可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥，进程同步 </p><p>一对原语：wait(S)和signal(S)<br>简称P,V操作,写作P(S),V(S)</p><p>信号量机制实现进程互斥</p><ol><li>分析并发进程的关键活动,划定临界区</li><li>设置互斥信号量(mutex),初值为1</li><li>在临界区之前执行P(mutex)</li><li>在临界区之后执行V(mutex)</li></ol><p>对不同的临界资源需要设置不同的互斥信号量</p><p>信号量机制实现同步</p><ol><li>分析什么地方需要实现”同步关系”,即必须保证”一前一后”执行的两个操作</li><li>设置同步信号量S,初始为0</li><li>在”前操作”之后执行V(S)</li><li>在”后操作”之前执行P(S)</li></ol><h3 id="经典进程互斥同步问题"><a href="#经典进程互斥同步问题" class="headerlink" title="经典进程互斥同步问题"></a>经典进程互斥同步问题</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>/**</p><ul><li>系统中有一组生产者进程和一组消费者进程,生产者进程每次生产一个产品放入缓冲区,消费者进程每次从缓冲区中取出一个产品并使用</li><li>生产者,消费者共享一个初始为空,大小为n的缓冲区</li><li>只有缓冲区没满时,生产者才能把产品放入缓冲区,否则必须等待</li><li>只有缓冲区不空时,消费者才能从中取出产品,否则必须等待</li><li></li><li>关系分析</li><li>同步关系: 缓冲区满时,生产者要等待消费者取走</li><li>缓冲区空时,消费者要等待生产者放入</li><li></li><li>互斥关系: 各进程必须互斥地访问</li><li></li><li>使用semaphore信号量实现</li><li>/</li></ul><p>生产者生产-v—full—p-&gt;消费者消费</p><p>生产者生产&lt;-p—empty—v-消费者消费</p><p>public class 生产者消费者 {<br>    private static Integer count = 0;  // 苹果数量<br>    //创建三个信号量<br>    final Semaphore empty = new Semaphore(5); //同步信号量,表示缓冲区大小<br>    final Semaphore full = new Semaphore(0); // 同步信号量,表示产品的数量,即非空缓冲区的数量<br>    final Semaphore mutex = new Semaphore(1);   // 互斥信号量,实现对缓冲区互斥访问</p><pre><code>public static void main(String[] args) {    生产者消费者 test1 = new 生产者消费者();    new Thread(test1.new Producer()).start();    new Thread(test1.new Consumer()).start();}// 生产者生产产品class Producer implements Runnable {    @Override    public void run() {        while(true) {            try {                empty.acquire(); //P(empty) 消耗一个空闲缓冲区                mutex.acquire(); //P(mutex) 实现互斥是在同一进程中进行一对PV操作                //把产品放入缓冲区                Thread.sleep(400);                count++;   // 每次生产一个产品,需要0.5秒                System.out.println(Thread.currentThread().getName()                        + "生产者生产，目前总共有" + count);            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                mutex.release();  //V(mutex) 互斥操作 解锁                full.release();  // V(full) 增加一个产品            }        }    }}//消费者消费产品class Consumer implements Runnable {    @Override    public void run() {        while(true) {            try {                full.acquire();  // P(full) 消耗一个产品                mutex.acquire(); // P(mutex) 上锁                Thread.sleep(100);                count--;  // 每次消费一个产品,需要1s                System.out.println(Thread.currentThread().getName()                        + "消费者消费，目前总共有" + count);            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                mutex.release();  // V(mutex) 解锁                empty.release();  // V(empty) 缓冲区多出一个空间            }        }    }}</code></pre><p>}</p><p>通过在同一进程中进行一对P(mutex)v(mutex)操作实现互斥<br>如果P(mutex)操作在P(empty)前,<br>若此时缓冲区已经放满产品,则empty=0,full=n.<br>生产者先执行p(mutex)使mutex变为0,再执行p(empty),由于没有空闲缓冲区,因此生产者阻塞.<br>切回消费者进程<br>消费者进程执行p(mutex),由于mutex=0,即生产者还没有释放对临界资源的锁,因此消费者也被阻塞<br>这就造成了生产者等待消费者释放空闲缓冲区,而消费者又等待生产者释放临界区的情况,出现死锁.</p><p>因此,实现互斥的P操作一定要在实现同步的P操作之后</p><h4 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h4><p>/**</p><ul><li>桌子上有一直盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，</li><li>儿子专等着吃盘子里的橘子，女儿专等着吃盘子中的苹果。</li><li>只有盘子空时，爸爸或妈妈才可向盘子中放入一个水果。</li><li>仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取水果</li><li></li><li>关系分析</li><li>互斥关系: 对缓冲区(盘子)的访问要互斥地进行</li><li>同步关系: 1. 父亲将苹果放入盘子后,女儿才能取苹果</li><li><ol start="2"><li>母亲将橘子放入盘子后,儿子才能取橘子</li></ol></li><li><ol start="3"><li>只有盘子空时,父亲或母亲才能放入水果</li></ol></li><li>从”事件”的角度考虑,盘子变空事件在放入水果事件之前</li><li></li><li></li><li>/</li></ul><p>public class 多生产者多消费者 {</p><pre><code>final Semaphore mutex = new Semaphore(1);   //实现互斥访问盘子(缓冲区)final Semaphore apple = new Semaphore(0);   //盘子中有几个苹果final Semaphore orange = new Semaphore(0);  //盘子中有几个橘子final Semaphore plate = new Semaphore(1);   //盘子中还可以放多少个水果public static void main(String[] args) {    多生产者多消费者 test1 = new 多生产者多消费者();    new Thread(test1.new dad()).start();    new Thread(test1.new mom()).start();    new Thread(test1.new daughter()).start();    new Thread(test1.new son()).start();}class dad implements Runnable{    @Override    public void run() {        while(true){            try {                System.out.println("爸爸正在削苹果");                Thread.sleep(600);  //削一个苹果                plate.acquire();  //P(plate)                mutex.acquire();  //上锁                Thread.sleep(100);  //把苹果放进盘子                System.out.println("爸爸把苹果放进盘子了");            } catch (Exception e) {                e.printStackTrace();            }finally{                mutex.release();                apple.release();            }        }    }}class mom implements Runnable{    @Override    public void run() {        while (true){            try {                System.out.println("妈妈正在剥橘子");                Thread.sleep(300);  //剥一个橘子                plate.acquire();  //P(plate)                mutex.acquire();  //P(mutex) 上锁                Thread.sleep(100);  //把橘子放进盘子                System.out.println("妈妈把橘子放进盘子了");            } catch (Exception e) {                e.printStackTrace();            }finally{                mutex.release();                orange.release();            }        }    }}class daughter implements Runnable{    @Override    public void run() {        while (true){            try {                apple.acquire();  //P(apple)                mutex.acquire();  //P(mutex) 上锁                Thread.sleep(100);  //从盘中取出苹果                System.out.println("女儿取出了苹果");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                mutex.release();  //V(mutex)                plate.release();  //V(plate)                try {                    Thread.sleep(1000);  //吃掉苹果                    System.out.println("女儿把苹果吃掉了");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}class son implements Runnable{    @Override    public void run() {        while (true){            try {                orange.acquire();  //P(orange)                mutex.acquire();  //P(mutex) 上锁                Thread.sleep(100);  //从盘中取出橘子                System.out.println("儿子取出了橘子");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                mutex.release();  //V(mutex) 解锁                plate.release();  //V(plate)                try {                    Thread.sleep(500);  //吃掉橘子                    System.out.println("儿子把橘子吃掉了");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><p>}</p><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><p>/**</p><ul><li>三个吸烟者和一个供应者进程. 每个吸烟者不停地卷烟并抽掉他,但是要卷起并抽掉,抽烟者需要有三种材料:烟草,纸和胶水</li><li>三个抽烟者中,第一个拥有烟草,第二个拥有纸,第三个拥有胶水.</li><li>供应者进程无限提供三种材料,供应者每次将两种材料放桌子上,拥有剩下材料的抽烟者取走抽烟,并给供应者一个信号完成了,</li><li>供应者就会把另外两种材料放桌子上,让三个抽烟者轮流抽烟</li><li></li><li>关系分析 (从事件的角度来分析)</li><li>互斥关系: 桌子是容量为1的缓冲区,要互斥访问</li><li>同步关系: 1. 桌子上有组合一(纸+胶水)-&gt; 第一个抽烟者取走</li><li><ol start="2"><li>桌子上有组合二(烟草+胶水)-&gt; 第二个抽烟者取走</li></ol></li><li><ol start="3"><li>桌子上有组合三(烟草+纸)-&gt; 第三个抽烟者取走</li></ol></li><li><ol start="4"><li>发出完成信号-&gt;供应者将下一个组合放上</li></ol></li><li></li><li>/</li></ul><p>public class 吸烟者问题 {</p><pre><code>private int i = 0;  //用于实现轮流抽烟final Semaphore offer1 = new Semaphore(0);  //组合一资源的量final Semaphore offer2 = new Semaphore(0);  //组合二资源的量final Semaphore offer3 = new Semaphore(0);  //组合三资源的量final Semaphore table = new Semaphore(1);  //缓冲区(桌子)是否收到信号放上资源public static void main(String[] args) {    吸烟者问题 test = new 吸烟者问题();    new Thread(test.new provider()).start();    new Thread(test.new smoker1()).start();    new Thread(test.new smoker2()).start();    new Thread(test.new smoker3()).start();}class provider implements Runnable{    @Override    public void run() {        while (true){            try {                table.acquire();  //P(finish)                if (i==0){                    Thread.sleep(100);                    System.out.println("供应者放上了组合一资源");                    offer1.release();                }else if (i==1){                    Thread.sleep(100);                    System.out.println("供应者放上了组合二资源");                    offer2.release();                }else if (i==2){                    Thread.sleep(100);                    System.out.println("供应者放上了组合三资源");                    offer3.release();                }                i = (i+1)%3;            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}class smoker1 implements Runnable{    @Override    public void run() {        while (true){            try {                offer1.acquire();                Thread.sleep(100);                System.out.println("抽烟者一拿走了材料");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                try {                    Thread.sleep(300);                    System.out.println("抽烟者一卷好了烟");                    Thread.sleep(1000);                    System.out.println("抽烟者一抽完了烟");                } catch (InterruptedException e) {                    e.printStackTrace();                }finally {                    table.release();  //发出完成信号                }            }        }    }}class smoker2 implements Runnable{    @Override    public void run() {        while (true){            try {                offer2.acquire();                Thread.sleep(100);                System.out.println("抽烟者二拿走了材料");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                try {                    Thread.sleep(300);                    System.out.println("抽烟者二卷好了烟");                    Thread.sleep(1000);                    System.out.println("抽烟者二抽完了烟");                } catch (InterruptedException e) {                    e.printStackTrace();                }finally {                    table.release();  //发出完成信号                }            }        }    }}class smoker3 implements Runnable{    @Override    public void run() {        while (true){            try {                offer3.acquire();                Thread.sleep(100);                System.out.println("抽烟者三拿走了材料");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                try {                    Thread.sleep(100);                    System.out.println("抽烟者三卷好了烟");                    Thread.sleep(1000);                    System.out.println("抽烟者三抽完了烟");                } catch (InterruptedException e) {                    e.printStackTrace();                }finally {                    table.release();  //发出完成信号                }            }        }    }}</code></pre><p>}</p><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>/**</p><ul><li>有读者写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时,不会有副作用</li><li>若某个写进程和其他进程(读和写)同时访问共享数据时则可能导致数据不一致</li><li>因此要求: 1. 允许多个读者同时对文件读</li><li><ol start="2"><li>只允许一个写者往文件中写信息</li></ol></li><li><ol start="3"><li>任一写者在完成写操作前不允许其他读者或写者工作</li></ol></li><li><ol start="4"><li>写者执行操作前,应让已有的读者和写者全部退出</li></ol></li><li></li><li>关系分析</li><li>互斥关系: 写进程-写进程, 写进程-读进程, 但读与读不互斥</li><li>写者与任何进程都互斥,设置一个互斥信号量rw,在写者访问前后PV</li><li>读者与写者也互斥,因此读者操作前后也要PV</li><li>但读者之间不互斥,所以只让第一个读进程”加锁”, 最后一个读进程”解锁”</li><li>设置一个count来记录当前有几个读进程在访问</li><li></li><li>若两个读进程并发执行, 则有可能先后执行P(rw), 从而使第二个阻塞</li><li>原因在于对count变量的检查和赋值无法一气呵成</li><li>因此要设置mutex保证对count的访问是互斥的</li><li></li><li>潜在问题: 只要有读进程在读,写进程就要一直阻塞等待,可能”饿死”</li><li>增加一个互斥信号量,实现”写优先”</li><li></li><li>/</li></ul><p>public class 读者写者问题 {<br>    private static int count = 0;    //记录当前第几个读进程</p><pre><code>private Semaphore rw = new Semaphore(1);     //用于实现对文件互斥访问,表示当前是否有访问private Semaphore mutex = new Semaphore(1);  //用于保证对count变量的互斥访问private Semaphore w = new Semaphore(1);      //用于实现"写优先"public static void main(String[] args) {    读者写者问题 test = new 读者写者问题();    new Thread(test.new reader()).start();    new Thread(test.new writer()).start();    new Thread(test.new reader()).start();    new Thread(test.new reader()).start();    new Thread(test.new reader()).start();    new Thread(test.new reader()).start();}class writer implements Runnable{    @Override    public void run() {        while (true){            try {                w.acquire();   // P(w)                rw.acquire();  // P(rw)  对文件访问加锁                System.out.println(Thread.currentThread().getName()+"写进程正在写文件");                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                System.out.println(Thread.currentThread().getName()+"写进程写完了");                rw.release();  //写完后加锁                w.release();            }        }    }}class reader implements Runnable{    @Override    public void run() {        while (true){            try {                w.acquire();   // P(w)                mutex.acquire();  // P(mutex) 各读进程互斥访问count                if (count == 0){                    rw.acquire();  // P(rw)  第一个读进程对文件访问加锁                }                count++;                mutex.release();  // V(mutex)                w.release();      // V(w)                System.out.println(Thread.currentThread().getName()+"读进程正在读文件");                Thread.sleep(1000);                System.out.println(Thread.currentThread().getName()+"读进程读完了");                mutex.acquire();                count--;                if (count==0){                    rw.release();  //最后一个读进程负责解锁                }                mutex.release();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p>}</p><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路.<br>其核心思想在于设置一个计数器count用来记录当前正在访问共享文件的读进程数.<br>我们可以用count的值判断当前进入的进程是否是第一个/最后一个读进程,从而做出不同的处理<br>另外,对count变量的检查和赋值不能一气呵成导致了一些错误,如果需要实现”一气呵成”,自然应该想到用互斥信号量</p><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>/**</p><ul><li>一张桌子上五个哲学家,每两个哲学家间摆一根筷子,桌子中间一碗饭. 哲学家只思考与吃饭. 哲学家思考时不影响他人.</li><li>只有当哲学家饥饿时,才试图拿左右两根筷子(一根一根拿起). 如果筷子在他人手上则需等待.</li><li>只有同时那两根筷子才可以进餐,完毕后继续思考</li><li></li><li>关系分析</li><li>互斥关系: 哲学家与左右邻居对中间的筷子是互斥关系.</li><li>如何避免临界资源分配不当造成死锁是该问题的关键</li><li></li><li>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子</li><li>/</li></ul><p>如果5个人同时拿起一只筷子,则造成”死锁”<br>如何防止死锁</p><ol><li>可以对哲学家进程施加限制,比如最多允许4个哲学家同时进餐.<br> 这样至少有一个人可以拿两只</li><li>要求奇数号先左后右,偶数号相反<br>这就保证相邻两人只有一人会拿起一只筷子,另一个直接阻塞,就避免了占用一只后再等待另一只的情况</li><li>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子</li></ol><p>public class 哲学家进餐 {</p><pre><code>Semaphore[] chopsticks = {new Semaphore(1),new Semaphore(1),new Semaphore(1),new Semaphore(1),new Semaphore(1)};Semaphore mutex = new Semaphore(1); //互斥的取筷子public static void main(String[] args) {    哲学家进餐 test = new 哲学家进餐();    new Thread(test.new p0()).start();    new Thread(test.new p1()).start();    new Thread(test.new p2()).start();    new Thread(test.new p3()).start();    new Thread(test.new p4()).start();}class p0 implements Runnable{    @Override    public void run() {        while (true){            try {                mutex.acquire();                chopsticks[0].acquire();   //拿左筷子                chopsticks[(0+1)%5].acquire();  //拿右筷子                mutex.release();                System.out.println("哲学家0正在吃饭");                Thread.sleep(1000);                System.out.println("哲学家0继续思考");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                chopsticks[0].release();  //放下左筷子                chopsticks[(0+1)%5].release();  //放下右筷子            }        }    }}class p1 implements Runnable{    @Override    public void run() {        while (true){            try {                mutex.acquire();                chopsticks[1].acquire();   //拿左筷子                chopsticks[(1+1)%5].acquire();  //拿右筷子                mutex.release();                System.out.println("哲学家1正在吃饭");                Thread.sleep(1000);                System.out.println("哲学家1继续思考");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                chopsticks[1].release();  //放下左筷子                chopsticks[(1+1)%5].release();  //放下右筷子            }        }    }}class p2 implements Runnable{    @Override    public void run() {        while (true){            try {                mutex.acquire();                chopsticks[2].acquire();   //拿左筷子                chopsticks[(2+1)%5].acquire();  //拿右筷子                mutex.release();                System.out.println("哲学家2正在吃饭");                Thread.sleep(1000);                System.out.println("哲学家2继续思考");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                chopsticks[2].release();  //放下左筷子                chopsticks[(2+1)%5].release();  //放下右筷子            }        }    }}class p3 implements Runnable{    @Override    public void run() {        while (true){            try {                mutex.acquire();                chopsticks[3].acquire();   //拿左筷子                chopsticks[(3+1)%5].acquire();  //拿右筷子                mutex.release();                System.out.println("哲学家3正在吃饭");                Thread.sleep(1000);                System.out.println("哲学家3继续思考");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                chopsticks[3].release();  //放下左筷子                chopsticks[(3+1)%5].release();  //放下右筷子            }        }    }}class p4 implements Runnable{    @Override    public void run() {        while (true){            try {                mutex.acquire();                chopsticks[4].acquire();   //拿左筷子                chopsticks[(4+1)%5].acquire();  //拿右筷子                mutex.release();                System.out.println("哲学家4正在吃饭");                Thread.sleep(1000);                System.out.println("哲学家4继续思考");            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                chopsticks[4].release();  //放下左筷子                chopsticks[(4+1)%5].release();  //放下右筷子            }        }    }}</code></pre><p>}</p><p>哲学家进餐问题的关键在于解决进程死锁问题的隐患<br>这些进程之间只存在互斥关系,但是与之前接触到的互斥关系不同的是,每个进程都需要同时持有两个临界资源<br>,因此就有死锁问题的隐患</p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>信号量机制存在的问题: 编写程序困难,易出错,引入”管程”,一种高级同步机制</p><p>定义: 管程是一种特殊的软件模块<br>由以下组成</p><ol><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><p>管程的基本特征:</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ol><p>管程就像把PV操作当作语句封装成函数,这些函数又被封装在管程中</p><p>Java中类似于管程的机制<br>用synchronized关键字描述一个函数,则该函数同一时间段只能被一个线程调用</p><p>public class 多线程案例 {</p><pre><code>public static void main(String[] args){    //创建包子对象    多线程案例.BaoZi bz = new 多线程案例.BaoZi();    //创建包子铺线程,开始生产包子    new 多线程案例.BaoZiPu(bz).start();    //创建顾客线程,开始吃包子    new 多线程案例.ChiHuo(bz).start();}static class BaoZi {    //皮    String pi;    //馅    String xian;    //包子的状态    boolean flag = false;}static class BaoZiPu extends Thread{    private BaoZi bz;    public BaoZiPu(BaoZi bz) {        this.bz = bz;    }    //设置线程生产包子    @Override    public void run() {        int count = 0;        //让包子一直生产到100个包子        while(count&lt;100){            //同步技术            synchronized (bz){                if(bz.flag == true){                    //包子铺调用wait方法进入等待状态                    try {                        bz.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                //被唤醒后生产包子                //交替生产两种包子                if(count%2 == 0){                    //生产薄皮三鲜馅儿                    bz.pi = "薄皮";                    bz.xian = "三鲜馅儿";                }else{                    //生产冰皮牛肉大葱馅儿                    bz.pi = "冰皮";                    bz.xian = "牛肉大葱馅儿";                }                count++;                System.out.println("包子铺正在做"+bz.pi+bz.xian+"的包子");                //做一个包子五秒钟                try {                    Thread.sleep(5000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                //做好包子,flag改成有                bz.flag = true;                bz.notify();                System.out.println("包子铺做好了"+bz.pi+bz.xian+"的包子");            }        }    }}static class ChiHuo extends Thread {    private BaoZi bz;    public ChiHuo(BaoZi bz) {        this.bz = bz;    }    @Override    public void run() {        int count=0;        while(count&lt;100){            synchronized (bz){                if(bz.flag == false){                    try {                        bz.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                //被唤醒后吃包子                System.out.println("顾客在吃"+bz.pi+bz.xian+"的包子");                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                //吃完包子修改状态为没有                bz.flag = false;                count++;                //唤醒包子铺继续生产                bz.notify();                System.out.println("顾客把"+bz.pi+bz.xian+"的包子吃完了");                System.out.println("--------------------------------------");            }        }    }}</code></pre><p>}</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在并发环境下,各进程因竞争资源而造成的一种互相等待对方手里的资源,导致进程都阻塞,都无法向前推进的现象</p><p>死锁,饥饿,死循环的区别<br>饥饿: 长期得不到想要的资源,某进程无法向前推进的现象<br>死循环: 某进程执行过程中一直跳不出某个循环的现象</p><p>死锁至少两个或两个以上的进程同时发生<br>饥饿可能只有一个进程<br>死锁和饥饿是管理者(操作系统的问题),死循环是被管理者(程序)的问题</p><p>死锁产生的必要条件:<br>    1. 互斥条件: 只有对必须互斥使用的资源的争抢才会导致死锁<br>    2. 不剥夺条件: 进程所获得的资源在未使用完之前,不能由其他进程强行夺走,只能主动释放<br>    3. 请求和保持条件: 进程已经保持了至少一个资源,但又提出了新的资源请求,而该资源已被占有<br>    4. 循环等待条件: 存在一种进程资源的循环等待链, 链中每一个进程已得资源同时被下一进程请求</p><pre><code>注: 发生死锁一定有循环等待,但循环等待不一定死锁</code></pre><h3 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h3><p>预防死锁: 破坏四个必要条件之一或几个<br>避免死锁: 用某种方法防止系统进入不安全状态(银行家算法)<br>死锁的检测和解除: 允许死锁的发生,然后采取某种措施接触死锁</p><ol><li><p>预防死锁</p><ol><li><p>破坏互斥<br> 把只能互斥使用的资源改造成允许共享使用<br> Spoling技术, 吧独占设备在逻辑上改造成共享设备</p></li><li><p>破坏不剥夺<br> 方案一: 当某进程请求资源得不到满足时,必须立即释放</p><pre><code> 可能导致饥饿</code></pre><p> 方案二: 由操作系统协助强行剥夺</p><pre><code> 反复申请释放,增大了开销</code></pre></li><li><p>破环请求和保持条件<br> 采用静态分配方法,即进程一次申请所需全部资源,在资源未满足前不让他投入运行<br> 投入运行后这些资源一直归他所有,不会再请求别的资源<br> 资源利用率极低,且可能导致饥饿</p></li><li><p>破坏循环等待<br> 采用顺序资源分配法,首先给系统中的资源编号,规定每个进程必须按编号递增的顺序请求资源<br> 同类资源(即编号相同的资源)一次申请完<br> 原理: 一个进程只有占有小编号的资源是，才有资格申请更大编号的资源。</p><pre><code>   按此规则，以持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</code></pre><p> 不方便新增设备,可能重新分配所有的编号<br> 进程实际使用资源可能和编号递增顺序不一致,导致资源浪费<br> 必须按规定次序申请资源,用户编程麻烦</p></li></ol></li><li><p>避免死锁<br> 安全序列:</p><pre><code> 指如果系统按照某种序列分配资源,则每个进程都能顺利完成. 只要找出一个安全序列,系统就是安全状态,安全序列可能有多个</code></pre><p> 安全状态一定不会死锁,不安全状态可能会死锁</p><p> 银行家算法</p><pre><code> 核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂不答应这次请求           让该进程先阻塞等待</code></pre><p> 实例：银行家手里有100亿</p><pre><code>   B厂最多会借70亿   A厂最多会借40亿   T厂最多会借50亿   如果借给企业总数达不到企业提出的最大要求，钱就拿不回来 最大需求    已借走   最多还会借</code></pre><p> B      70         20         50<br> A      40         10         30<br> T      50         30         20</p><p> 银行家算法步骤</p><ol><li><p>检查此次申请是否超过了之前声明的最大需求数</p></li><li><p>检查此时系统剩余的可用资源是否还能满足这次请求</p></li><li><p>试探着分配，更改各数据结构</p></li><li><p>用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p>安全性算法步骤<br>检查当前的剩余可用资源是否满足某个进程的最大需求<br>如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收<br>不断重复上述过程，看最终是否能让所有进程加入安全序列</p></li></ol></li></ol><p>public class 银行家算法 {</p><pre><code>int[] Available = {10, 8, 7};int[][] Max = new int[3][3];int[][] Alloction = new int[3][3];int[][] Need = new int[3][3];int[][] Request = new int[3][3];int[] Work = new int[3];int num = 0;//进程编号Scanner in = new Scanner(System.in);public 银行家算法() {    // Max={{6,3,2},{5,6,1},{2,3,2}};}public void setSystemVariable(){//设置各初始系统变量，并判断是否处于安全状态。    setMax();    setAlloction();    printSystemVariable();    SecurityAlgorithm();}public void setMax() {//设置Max矩阵    System.out.println("请设置各进程的最大需求矩阵Max：");    for (int i = 0; i &lt; 3; i++) {        System.out.println("请输入进程P" + i + "的最大资源需求量：");        for (int j = 0; j &lt; 3; j++) {            Max[i][j] = in.nextInt();        }    }}public void setAlloction() {//设置已分配矩阵Alloction    System.out.println("请设置请各进程分配矩阵Alloction：");    for (int i = 0; i &lt; 3; i++) {        System.out.println("晴输入进程P" + i + "的分配资源量：");        for (int j = 0; j &lt; 3; j++) {            Alloction[i][j] = in.nextInt();        }    }    System.out.println("Available=Available-Alloction.");    System.out.println("Need=Max-Alloction.");    for (int i = 0; i &lt; 3; i++) {//设置Alloction矩阵        for (int j = 0; j &lt; 3; j++) {            Available[i] = Available[i] - Alloction[j][i];        }    }    for (int i = 0; i &lt; 3; i++) {//设置Need矩阵        for (int j = 0; j &lt; 3; j++) {            Need[i][j] = Max[i][j] - Alloction[i][j];        }    }}public void printSystemVariable(){    System.out.println("此时资源分配量如下：");    System.out.println("进程  "+"   Max   "+"   Alloction "+"    Need  "+"     Available ");    for(int i=0;i&lt;3;i++){        System.out.print("P"+i+"  ");        for(int j=0;j&lt;3;j++){            System.out.print(Max[i][j]+"  ");        }        System.out.print("|  ");        for(int j=0;j&lt;3;j++){            System.out.print(Alloction[i][j]+"  ");        }        System.out.print("|  ");        for(int j=0;j&lt;3;j++){            System.out.print(Need[i][j]+"  ");        }        System.out.print("|  ");        if(i==0){            for(int j=0;j&lt;3;j++){                System.out.print(Available[j]+"  ");            }        }        System.out.println();    }}public void setRequest() {//设置请求资源量Request    System.out.println("请输入请求资源的进程编号：");    num= in.nextInt();//设置全局变量进程编号num    System.out.println("请输入请求各资源的数量：");    for (int j = 0; j &lt; 3; j++) {        Request[num][j] = in.nextInt();    }    System.out.println("即进程P" + num + "对各资源请求Request：(" + Request[num][0] + "," + Request[num][1] + "," + Request[num][2] + ").");    BankerAlgorithm();}public void BankerAlgorithm() {//银行家算法    boolean T=true;    if (Request[num][0] &lt;= Need[num][0] &amp;&amp; Request[num][1] &lt;= Need[num][1] &amp;&amp; Request[num][2] &lt;= Need[num][2]) {//判断Request是否小于Need        if (Request[num][0] &lt;= Available[0] &amp;&amp; Request[num][1] &lt;= Available[1] &amp;&amp; Request[num][2] &lt;= Available[2]) {//判断Request是否小于Alloction            for (int i = 0; i &lt; 3; i++) {                Available[i] -= Request[num][i];                Alloction[num][i] += Request[num][i];                Need[num][i] -= Request[num][i];            }        } else {            System.out.println("当前没有足够的资源可分配，进程P" + num + "需等待。");            T=false;        }    } else {        System.out.println("进程P" + num + "请求已经超出最大需求量Need.");        T=false;    }    if(T==true){        printSystemVariable();        System.out.println("现在进入安全算法：");        SecurityAlgorithm();    }}public void SecurityAlgorithm() {//安全算法    boolean[] Finish = {false, false, false};//初始化Finish    int count = 0;//完成进程数    int circle=0;//循环圈数    int[] S=new int[3];//安全序列    for (int i = 0; i &lt; 3; i++) {//设置工作向量        Work[i] = Available[i];    }    boolean flag = true;    while (count &lt; 3) {        if(flag){            System.out.println("进程  "+"   Work  "+"   Alloction "+"    Need  "+"     Work+Alloction ");            flag = false;        }        for (int i = 0; i &lt; 3; i++) {            if (Finish[i]==false&amp;&amp;Need[i][0]&lt;=Work[0]&amp;&amp;Need[i][1]&lt;=Work[1]&amp;&amp;Need[i][2]&lt;=Work[2]) {//判断条件                System.out.print("P"+i+"  ");                for (int k = 0; k &lt; 3; k++){                    System.out.print(Work[k]+"  ");                }                System.out.print("|  ");                for (int j = 0; j&lt;3;j++){                    Work[j]+=Alloction[i][j];                }                Finish[i]=true;//当当前进程能满足时                S[count]=i;//设置当前序列排号                count++;//满足进程数加1                for(int j=0;j&lt;3;j++){                    System.out.print(Alloction[i][j]+"  ");                }                System.out.print("|  ");                for(int j=0;j&lt;3;j++){                    System.out.print(Need[i][j]+"  ");                }                System.out.print("|  ");                for(int j=0;j&lt;3;j++){                    System.out.print(Work[j]+"  ");                }                System.out.println();            }        }        circle++;//循环圈数加1        if(count==3){//判断是否满足所有进程需要            System.out.print("此时存在一个安全序列：");            for (int i = 0; i&lt;3;i++){//输出安全序列                System.out.print("P"+S[i]+" ");            }            System.out.println("故当前可分配！");            break;//跳出循环        }        if(count&lt;circle){//判断完成进程数是否小于循环圈数            count=5;            System.out.println("当前系统处于不安全状态，故不存在安全序列。");            break;//跳出循环        }    }}</code></pre><p>}</p><ol start="3"><li><p>检测和解除<br> 为了能对系统是否已发生了死锁进行检测，必须：</p><ol><li><p>用资源分配图来保存资源的请求和分配信息</p></li><li><p>提供了一种算法，利用上述信息来检测系统是否已进入死锁状态</p><p>资源分配图：<br> 两种节点：</p><pre><code> 进程节点：对应一个进程 资源节点：对应一类资源，一类资源可能有多个</code></pre><p> 两种边：</p><pre><code> 进程节点-&gt;资源节点: 表示进程想申请几个资源,每条边代表一个 资源节点-&gt;进程节点: 表示已经为进程分配了几个资源,每条边代表一个</code></pre><p>一般用矩形表示资源节点,矩形中的圆代表资源<br>稀疏图用邻接表表示, 稠密图用邻接矩阵</p><p>检测死锁的算法</p></li><li><p>在图中找出既不阻塞也不是孤点的进程pi(即找出一条有向边与它相连,<br>且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量),<br>有足够的空闲资源使该进程完成,消去该进程的边,释放资源</p></li><li><p>释放资源可以唤醒某些阻塞的进程,重复操作</p><p>若最终能消除所有边,就称这个图可以完全简化,此时一定没有死锁,否则就发生了死锁</p><p>死锁的解除:<br>一旦检测出死锁的发生,就应该立即解除死锁. 并不是系统中所有进程的死锁状态,<br>用死锁检测算法化简图后还连着边的进程就是死锁进程</p></li><li><p>资源剥夺法<br>挂起某些死锁进程,并抢占他的资源<br>但要防止被挂起后饥饿</p></li><li><p>撤销进程法(终止进程法)<br>强制撤销部分,甚至全部死锁进程,并剥夺资源<br>实现简单,但付出代价很大,可能已经运行快结束了,也要从头再来</p></li><li><p>进程回退法<br>让一个或多个死锁进程回退到足以避免死锁的地步</p><p>决定对哪个进程动手</p></li><li><p>进程优先级 低的先剥夺</p></li><li><p>已执行多长时间 短的先</p></li><li><p>还要多久完成 长的先</p></li><li><p>进程已经使用了多少资源 劫富济贫</p></li><li><p>进程是交互式的还是批处理式 优先杀批处理式的</p></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统第一章</title>
      <link href="/2021/04/29/cao-zuo-xi-tong/cao-zuo-xi-tong-di-yi-zhang/"/>
      <url>/2021/04/29/cao-zuo-xi-tong/cao-zuo-xi-tong-di-yi-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>Operating System 是指控制整个计算机系统的硬件和软件资源，<br>并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，<br>它是系统中最基本的系统软件。</p><p>进程：一个程序的执行过程。执行前需要将该程序放到内存中，才能被cpu处理</p><h3 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h3><p>操作系统提供的功能：处理机管理，存储器管理，文件管理，设备管理<br>向用户提供服务：命令接口：联机命令接口：说一句做一句，交互式<br>                          脱机命令接口：说一堆做一堆，批处理<br>                程序接口：由一组系统调用组成<br>对硬件机器的扩展：扩充机器</p><p>操作系统的特征：并发，共享，虚拟，异步</p><p>并发：指多个事件在同一时间间隔内发生<br>      宏观上同时，微观上交替<br>并行：指多个事件在同一时刻发生</p><p>一个单核处理器同一时刻只能执行一个程序，操作系统负责协调，多个程序交替执行</p><p>共享：资源共享有互斥共享：某些资源同一时间段内只允许一个进程访问<br>                同时共享：允许一个时间段内多个进行访问</p><p>虚拟：把物理上的实体变为若干个逻辑上的对应物，前者实际存在，后者是用户感受到的<br>    一个程序需要放入内存并给他分配cpu才能执行<br>    虚拟技术：时分复用/空分复用</p><p>异步：在多道程序环境下，允许多个程序并发执行，由于资源有限，进程不是一贯到底的，而是走走停停</p><h3 id="OS的发展与分类"><a href="#OS的发展与分类" class="headerlink" title="OS的发展与分类"></a>OS的发展与分类</h3><p>手工操作阶段：<br>    主要缺点：用户独占全机，人机速度矛盾导致资源利用率极低<br>批处理阶段：<br>    单道批处理系统：引入脱机输入/输出技术(用磁带完成)<br>                    并监督程序负责控制作业的输入输出<br>        主要优点:缓解了一定程度的人机速度矛盾,资源利用率有所提升<br>        主要缺点:内存中仅有一道程序运行,只有该程序运行结束后才能调入下一道程序运行.<br>                 cpu有大量的时间是在空闲等待I/O完成. 资源利用率依然很低</p><pre><code>多道批处理系统: 每次往内存中输入多道程序,流水线原理    主要优点: 多道程序并发执行,共享计算机资源. 资源利用率大幅提升,        cpu和其他资源保持"忙碌"状态,系统吞吐量增大.    主要缺点: 用户响应时间长,没有人机交互功能              (用户提交自己的作业后就只能等待计算机处理完成,中间不能控制自己的作业执行)</code></pre><p>分时操作系统: 计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互<br>    主要优点: 用户请求可以被及时响应,解决了人机交互问题. 允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人的存在<br>    主要缺点: 不能优先处理一些紧急任务. 操作系统对各个用户/作业都是完全公平的, 循环地为每个用户/作业服务一个时间片,不区分任务的紧急性.</p><p>实时操作系统: 计算机收到外部信号后及时进行处理,并且要在严格的时限内处理完事件.实时操作系统的主要特点是及时性和可靠性<br>    主要优点: 能够优先响应一些紧急任务,某些紧急任务不需要时间片排队<br>        硬实时系统: 必须在绝对严格的规定时间内完成处理<br>        软实时系统: 能接受偶尔违反时间规定</p><p>网络操作系统: 把网络中各个计算机有机地结合起来, 实现数据传送功能,实现网络中各种资源的共享和各台计算机之间的通信<br>分布式操作系统: 主要特点是分布性和并发性. 系统中的各台计算机地位相同, 任何工作都可以分布在这些计算机上,由他们并行、协同完成这个任务<br>个人计算机操作系统: 如Windows MacOS 方便个人使用</p><h3 id="操作系统的运行机制和体系结构"><a href="#操作系统的运行机制和体系结构" class="headerlink" title="操作系统的运行机制和体系结构"></a>操作系统的运行机制和体系结构</h3><p>运行机制{<br>    两种指令{<br>        特权指令<br>        非特权指令<br>    }<br>    两种处理器状态{<br>        核心态<br>        用户态<br>    }<br>    两种程序{<br>        内核程序<br>        应用程序<br>    }<br>}</p><p>操作系统内核{<br>    时钟管理<br>    中断处理<br>    原语<br>    对系统资源进行管理的功能{<br>        进程管理<br>        存储器管理<br>        设备管理<br>    }<br>}</p><p>操作系统的体系结构{<br>    大内核<br>    微内核<br>}</p><p>指令: 就是处理器能识别、执行的最基本命令<br>有的指令有很高的权限,如内存清零指令,如果用户程序可以将其他用户的内存数据随意清除,显然很危险<br>=&gt; 特权指令: 不允许用户程序使用<br>   非特权指令: 如普通的运算指令</p><p>cpu如何判断当前是否可以执行特权指令<br>=&gt; 用户态(目态) 只能使用非特权指令<br>   核心态(管态)</p><p>=&gt; 内核程序<br>   应用程序</p><p>内核是计算机上配置的底层软件,是操作系统最基本,最核心的部分</p><p>大内核: 将操作系统的主要功能模块都作为系统内核,运行在核心态<br>    优点: 高性能<br>    缺点: 内核代码庞大,结构混乱,难以维护</p><p>微内核: 只把最基本的功能保留在内核<br>    优点: 内核功能少,结构清晰,方便维护<br>    缺点: 需要频繁地在核心态和用户态之间切换,性能低</p><p>类比: 操作系统的体系结构问题与企业的管理问题很相似<br>      内核就是企业的管理层,负责一些重要的工作. 只有管理层才能执行特权指令,<br>      普通员工只能执行非特权指令. 用户态,核心态之间的切换相当于普通员工与管理层之间的工作交接</p><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>为了解决单道处理的问题,人们发明了操作系统,引入中断机制,实现了多道程序并发执行<br>本质: 发生中断就意味着需要操作系统介入,开展管理工作</p><ol><li>当中断发生时,cpu立即进入核心态</li><li>当中断发生后,当前运行的进程暂停运行,并由操作系统内核对中断进行处理</li><li>对于不同的中断信号,会进行不同的处理</li></ol><p>问题: 用户态,核心态之间的切换是怎么实现的<br>用户态切换到核心态是通过中断实现的,并且中断是唯一途径<br>核心态切换到用户态是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为”用户态”</p><p>中断分为内中断和外中断<br>内中断: 也称异常,例外,陷入. 信号的来源: CPU内部, 与当前执行的指令有关<br>    自愿中断: 指令中断<br>    强迫中断: 硬件中断/软件中断<br>外中断: 外设请求, 人工干预</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统作为用户和计算机硬件之间的接口,需要向上提供一些简单易用的服务.<br>主要包括命令接口和程序接口. 其中程序接口由一组系统调用组成</p><p>应用程序通过系统调用请求系统的服务. 系统中的各种共享资源都由操作系统统一掌管,<br>因此,在用户程序中,凡是与资源有关的操作(如存储分配,I/O操作,文件管理等)<br>都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成.<br>这样可以保证系统的稳定性和安全性,防止用户进行非法操作.</p><p>系统调用的相关处理需要在核心态下进行</p><p>凡是与资源有关的操作,会直接影响到其他进程的操作,一定需要操作系统的介入,即需要系统调用来实现</p><p>分类: 设备管理,文件管理,进程控制,进程通信,内存管理</p><p>系统调用的过程:</p><ol><li>传递系统调用参数</li><li>执行陷入指令(中断)</li><li>执行系统调用相应服务程序</li><li>返回用户程序</li></ol><p>系统调用发生在用户态,对系统调用的处理发生在核心态<br>执行陷入指令会产生内中断,使处理器从用户态进入核心态.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm</title>
      <link href="/2021/04/27/algorithm/"/>
      <url>/2021/04/27/algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="五大常用算法"><a href="#五大常用算法" class="headerlink" title="五大常用算法"></a>五大常用算法</h3><h2 id="一、分治"><a href="#一、分治" class="headerlink" title="一、分治"></a>一、分治</h2><p>分治策略：<br>    1、将原始问题划分或归结为规模较小的子问题。</p><pre><code>2、递归或者迭代求解每个子问题3、将子问题的解综合得到原问题的解注意：1、子问题与原问题的性质完全一样2、子问题之间可以彼此独立求解3、递归停止时，子问题可以直接求解。经典问题：Hanoi塔，归并排序，二分检索，芯片测试</code></pre><p>#案例1. Hanoi塔<br>设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，<br>由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将塔座a上的圆盘移到塔座c上，<br>并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：<br>规则1：每次只能移动1个圆盘；<br>规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；<br>规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一塔座上。<br>思路<br>如果只有 1 个圆盘，a –&gt; c<br>如果圆盘数大于1<br>将 n - 1 个圆盘，从 a 借助 c 移动到 b<br>将剩下 1 个圆盘从 a 移动到 c<br>将 n - 1 个圆盘，从 b 借助 a 移动到 c</p><pre><code>@param n 要移动多少个圆盘@param a 出发地点@param b 借助地点@param c 目标地点public static void move(int n,char a,char b,char c){    if (n&lt;1){        System.out.println("请输入正整数");    } else if (n == 1) {        System.out.println(a+"--&gt;"+c);    }else {        //先将n-1个盘从a借助c移动到b        move(n-1,a,c,b);        //此时,b有n-1个盘,a还剩一个盘,将此盘直接移到c        move(1,a,b,c);        //下一个子问题,如何将b的所有盘借助a移动到c        move(n-1,b,a,c);    }}</code></pre><p>#案例2. 芯片测试<br>有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。<br>　　每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。<br>    而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。<br>　　给出所有芯片的测试结果，问哪些芯片是好芯片。</p><p>输入格式<br>　　输入数据第一行为一个整数n，表示芯片个数。<br>　　第二行到第n+1行为n*n的一张表，每行n个数据。<br>    表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，<br>    1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。</p><p>输出格式<br>　　按从小到大的顺序输出所有好芯片的编号</p><p>样例输入<br>3<br>1 0 1<br>0 1 0<br>1 0 1</p><p>样例输出<br>1 3</p><pre><code>public static ArrayList&lt;Integer&gt; crip(int n, int[][] matrix){    /*     * 要点     * 本题要点：题目中说：已知好芯片比坏芯片多。     * 统计矩阵的每一列1的个数，也就是每个芯片被测试为好的次数（包括自己）     * 如果某芯片被测试为好的次数小于被测试为坏的次数，     * 如果该芯片为好的，则表示将它测试为坏的那些芯片其实都是坏的     * 这样坏芯片就比好芯片多，不符合题意     *     * 因此,如果被测试为坏的次数多于好,那此芯片指定是坏的     * 反之,如果测试为好的次数大于坏,那他指定不能是坏的.     */    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    //测试为好的次数    //j列表示芯片对第j个的测试,从j列开始循环读第i个芯片对j的测试    for (int j = 0;j&lt;n;j++){        int tmp = 0;        for (int i = 0;i&lt;n;i++){            if (matrix[i][j] == 1){                tmp++;            }        }        if (tmp&gt;n-tmp){            res.add(j+1);        }    }    return res;}</code></pre><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>用于解决具有重复子问题和最优子结构的最优化问题。<br>基本思想也是将待求解的问题分解成若干子问题，先求解子问题然后从这些子问题的解得到原问题的解<br>与分治法不同的是，动态规划分解得到的子问题往往不是相互独立的，<br>即上一个子问题的解可能为下一个子问题的条件(通常将结果填入表格)</p><p>经典问题：投资问题、背包问题、最长公共子序列</p><p>#案例1. 投资问题<br>问题：有m元钱，n项投资，fi(x)：将x元投入第i个项目的效益。求使得的总效益最大的投资方案。<br>建模：问题的解是向量&lt;x1,x2,…,xn&gt;<br>    xi是投给项目i的钱数,i=1,2,3,….,n<br>    目标函数F=max{f1(x1)+f2(x2)+…+fn(xn)}<br>    约束条件 x1+x2+…+xn=m,xi∈N</p><p>子问题界定:由参数k和x界定<br>k: 考虑对项目1,2,…,k的投资<br>x: 投资总钱数不超过x</p><p>原始输入: k=n,x=m<br>子问题计算顺序:<br>    k=1,2,…,n<br>    对于给定的k,x=1,2,…m</p><p>递推方程和边界条件<br>    Fk(x) = max{fk(xk)+Fk-1(x-xk)}<br>    F1(x) = f1(x)</p><pre><code>@param m m-1元钱@param n n个项目@param tempF 存放投资效益最大值 tempF[i][j]表示j个项目一共投资i元的最高效益@param d 存放标记解, d[i][j] 表示j个项目一共投i元时,第j个项目投多少元@param business 效益表 business[i][j] 表示第j个项目投i元的收益@return 最大利润public static int investBusiness(int m,int n,int[][] tempF,int[][] d,int[][] business){    int sum = 0;    //先考虑1个项目的情况（1个项目在0到m-1费用之间的效益）    for (int i = 0;i&lt;m;i++){        //只有一个项目时,最高效益表就等于输入效益表的第一列        tempF[i][0] = business[i][0];        //第一个项目投资i元        d[i][0] = i;    }    //考虑多个(&gt;=2)项目的情况（多个项目在0到m-1费用之间的效益）    for (int j = 1;j&lt;n;j++){ //从第二个项目开始        for (int i = 0;i&lt;m;i++){            //最后一个项目投0-i元钱求出最优解            for (int k = 0;k&lt;i;k++){                //Fk(x)=max{fk(xk)+Fk-1(x-xk)}                sum = business[k][j]+tempF[i-k][j-1];                if (sum&gt;tempF[i][j]){                    tempF[i][j] = sum;                    //j+1个项目一共i元的情况下,记下第j+1个项目应投资k元                    d[i][j] = k;                }            }        }    }    return tempF[m-1][n-1];}//解的追踪public static int[] tracingSolution(int m,int n,int[][] d){    //将解寄存在数组里    int tracing[] = new int[n];    int s = m-1;    //最后一个项目应该投资的钱数    tracing[n-1] = d[m-1][n-1];    for (int j = n-2;j&gt;=0;j--){        //后一个项目的钱投完后剩余的钱        s -= tracing[j+1];        //追踪前0-j个项目投s元的分配        tracing[j] = d[s][j];    }    return tracing;}</code></pre><p>#案例2. 背包问题<br>一个旅行者随身携带一个背包,可以放入背包的物品有n种,每种物品的重量和价值分别为wi,vi<br>如果背包的最大重量限制是b,每种物品可以放多个.<br>怎样选择使背包物品价值最大?<br>建模:<br>解是&lt;x1,x2,…xn&gt;, 其中xi是装入背包的第i种物品个数<br>目标函数: maxΣvixi<br>约束条件: Σwixi&lt;=b</p><p>子问题界定: 由参数k和y界定 dp[k][y]<br>k: 考虑对物品1,2,…,k的选择<br>y: 背包总重量不超过y</p><p>原始输入: k=n,y=b<br>子问题计算顺序: k = 1,2,…,n<br>                对于给定的k,y=1,2,…,b</p><p>Fk(y): 装前k种物品,总重不超过y,背包达到的最大价值  dp[k][y]<br>Fk(y) = max{Fk-1(y),Fk(y-wk)+vk}   dp[k][y] = max(dp[k-1][y],dp[k][y-wk])<br>(Fk(y-wk)递归,式子含义是不装第k种的最大价值和第k种至少装一件的最大价值比<br>初值: F0(y) = 0, 0&lt;=y&lt;=b, Fk(0) = 0,0&lt;=k&lt;=n<br>F1(y)=[y/w1]*v1,Fk(y) = -∞ y&lt;0</p><p>*第二种写法:<br>与投资问题类似,但时间复杂度比第一种高<br>Fk(y) = max{Fk-1(y-xkwk)+xkvk}, 0&lt;=xk&lt;=[y/wk]</p><p>*背包问题的推广:</p><ol><li><p>物品数受限的背包,0-1背包</p></li><li><p>多背包问题: m个背包,背包j装入最大重量为Bj,j = 1,2,…,m</p></li><li><p>二维背包问题: 每件物品有重量wi和体积ti,背包总重量不超过b,体积不超过V</p><p>  static class Materia{</p><pre><code> public int weight; public int value; public Materia(int weight, int value) {     this.weight = weight;     this.value = value; }</code></pre><p> }</p><p> @param materia 材料数组<br> @param maxWeight 背包最大承重<br> @param tempF 存放装包价值最大值 tempF[i][j]表示i种材料一共限制j重的最高价值<br> @param d 追踪结果表<br> @return<br> public static int maxLoadingValue(Materia[] materia,int maxWeight,int[][] tempF,int[][] d){</p><pre><code> int sum = 0,tempValue,num=d[0][0]; if (materia.length == 0 || maxWeight == 0){     return tempF[materia.length-1][maxWeight]; } //初始化 //只装第一个物品的装包情况,包的容量至少是1, //j 1~maxWeight for (int j=1;j&lt;=maxWeight;j++){     tempValue = (j/materia[0].weight)*materia[0].value;     if (tempValue&gt;sum){         num = 1;         sum = tempValue;     }     //最大价值表记下只有第一种材料的情况下,不同载重的最大价值     tempF[0][j] = sum;     //追踪表记下载重j只有第一种材料时,上一个放入的都是第一个材料     d[0][j] = num; }</code></pre></li></ol><pre><code>    //装2号之后的材料    //从i=1开始    for(int i=1;i&lt;materia.length;i++){        //装1~maxWeight重量        for (int j =1;j&lt;=maxWeight;j++){            //先把num赋为d[i-1][j], 表示目前先拿的材料和只有0~i-1种时相同            num=d[i-1][j];            //如果放不下新增的第i+1个材料,临时价值量=0            //临时价值量存的是至少装一个新材料的总价值            if (j-materia[i].weight&lt;0){                tempValue = 0;            }else {                //Fk(y):装前k种物品,总重不超过y,背包达到的最大价值                //Fk(y)=max{Fk-1(y),Fk(y-wk)+vk}                //装得下第i+1种材料,则要比较至少装一个和不装的价值                //Fk(y-wk)+vk                tempValue=tempF[i][j-materia[i].weight]+materia[i].value;            }            //和不装第i种材料的总价值比较            if (tempValue&gt;=tempF[i-1][j]){                if (j-materia[i].weight&gt;=0){                    //最新一步装第i+1种材料                    num = i+1;</code></pre><p>//                        num++;<br>                    }<br>                    //如果装第i+1种材料比不装的价值高,将tempF[i][j]赋成tempValue<br>                    tempF[i][j] = tem<br>                    pValue;<br>                } else{<br>                    //否则,最大价值依然是只用0~i-1种材料的最优解<br>                  tempF[i][j] = tempF[i-1][j];<br>                }<br>                //记录i+1种材料,背包载重j的情况下,最先放入的材料是第num号材料<br>                d[i][j] = num;<br>            }<br>        }<br>        //返回最大价值<br>        return tempF[materia.length-1][maxWeight];<br>    }</p><pre><code>public static int[] tracingSolution(int maxWeight,int[][] d,Materia[] materia){    //将解寄存在数组里    //一个k种材料,解的长度为k    int k = materia.length,count=0,y=maxWeight;    int[] tracing = new int[k];    int index = k-1;    while (y&gt;0&amp;&amp;k&gt;0){        //拿到解数组中的最后一个值,表示从最后一种材料开始,先取哪一种材料        k=d[k-1][y];        //若是能取到该物品，则对应数组下标中的值+1,表示放该材料的数目+1        tracing[k-1] = ++count;        y=y-materia[k-1].weight;        //如果要取的依然是第k种材料,先把k种材料的解遍历再找d[k-1][y]的解        while(y&gt;0&amp;&amp;d[k-1][y]==k) {            tracing[k-1]=++count;            y=y-materia[k-1].weight;        }        count=0;    }    return tracing;}设序列X,ZX = &lt;x1,x2,...,xm&gt;Z = &lt;z1,z2,...,zm&gt;若存在X的元素构成的严格递增序列使得zj = xij,j=1,2,...,k则称Z是X的子序列即: Z中的元素都是从X中选出来的,且前后次序一样,可以间隔着选问题: 最长公共子序列实例: X: A B C B D A B    Y: B D C A B A    最长公共子序列: B C B A, 长度4递推方程:    Xi = &lt;x1,x2,...,xi&gt;, Yj=&lt;y1,y2,...,yj&gt;    C[i,j]: Xi与Yj的LCS的长度C[i,j]= 0, 若 i=0 或 j=0    = C[i-1,j-1]+1, 若i,j&gt;0,xi = yj    = max{C[i,j-1],C[i-1,j]}, 若i,j&gt;0,xi != yj</code></pre><p>public class 最长公共子序列 {<br>    public static void main(String[] args) {<br>        //随机生成指定长度的字符串<br>        int size = 20;<br>        String x  = generateRandomStr(size);<br>        String y  = generateRandomStr(size);</p><pre><code>    int m = x.length();    int n = y.length();    //创建二维数组，也就是填表的过程    int[][] c = new int[m+1][n+1];    //初始化二维数组    for (int i = 0; i &lt; m+1; i++) {        c[i][0] = 0;    }    for (int i = 0; i &lt; n+1; i++) {        c[0][i] = 0;    }    //实现公式逻辑    int[][] path = new int[m+1][n+1];//记录通过哪个子问题解决的，也就是递推的路径    for (int i = 1; i &lt; m+1; i++) {        for (int j = 1; j &lt; n+1; j++) {            if(x.charAt(i-1) == y.charAt(j-1)){                c[i][j] = c[i-1][j-1] + 1;            }else if(c[i-1][j] &gt;= c[i][j-1]){                c[i][j] = c[i-1][j];                path[i][j] = 1;            }else{                c[i][j] = c[i][j-1];                path[i][j] = -1;            }        }    }    //输出查看c    System.out.println("c:");    for (int i = 0; i &lt; m+1; i++) {        for (int j = 0; j &lt; n+1; j++) {            System.out.print(c[i][j]+"\t");        }        System.out.println();    }    //输出查看path    System.out.println("path:");    for (int i = 0; i &lt; m+1; i++) {        for (int j = 0; j &lt; n+1; j++) {            System.out.print(path[i][j]+"\t");        }        System.out.println();    }    System.out.printf("%s与%s的最长公共子序列为：\n",x,y);    PrintLCS(path,x,m,n);}public static String generateRandomStr(int length) {    String base = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";    Random random = new Random();    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; length; i++) {        int number = random.nextInt(base.length());        sb.append(base.charAt(number));    }    return sb.toString();}public static void PrintLCS(int[][]b,String x,int i,int j){    if(i == 0 || j == 0){        return;    }    if(b[i][j] == 0){        PrintLCS(b,x,i-1,j-1);        System.out.printf("%c",x.charAt(i-1));    }else if(b[i][j] == 1){        PrintLCS(b,x,i-1,j);    }else{        PrintLCS(b,x,i,j-1);    }}</code></pre><h2 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h2><p>贪心算法可以获取到问题的局部最优解，不一定能获取到全局最优解<br>同时获取最优解的好坏要看贪心策略的选择<br>特点就是简单，能获取到局部最优解</p><p>经典问题：单源最短路径、最小生成树、哈夫曼算法、找零钱问题、最优装载问题、最小延迟调度、活动选择问题</p><p>#案例1. 单源最短路径(Dijkstra算法)</p><p>给定带权有向网络 G=(V,E,W),每条边 e=&lt;i,j&gt;的权w(e)为非负实数<br>表示从i到j的距离<br>求从s出发到达其它结点的最短路径</p><p>算法思想的简单描述：<br>要找出源到其他顶点的最短距离，首先将所有顶点划分成两个集合，S是已经到达的顶点，V是没有到达的顶点，显然S+V就是所有顶点。<br>初始，S集合中只包含源顶点（本例中是1号顶点），然后找出V中距离S集合最近的一个顶点<br>（即贪心选择，至于为什么是S集合，请务必理解该问题的最优子结构性质）。<br>那么显然，需要有个对象来记录每个顶点到源顶点的距离，这就是代码中的dist数组。<br>dist[2]=x就表示，顶点2到源顶点的最短距离是x。找到后，记录下路径。<br>如何记录，同样需要一个对象，即代码中的prev数组。prev[2]=y就表示，顶点2到源顶点的最短路径中，顶点2的前一个顶点是顶点y。<br>记录下路径的同时还需要将该顶点加入到S集合中,它就是s数组了。</p><p>初始: S={s},S=V时算法结束<br>从s到u相对于S的最短路径: 从s到u且仅经过S中顶点的最短路径<br>dist[u]: 从s到u相对于S最短路径的长度<br>short[u]: 从s到u的最短路径的长度<br>dist[u]&gt;=short[u]</p><p>输入:有向图输出:从s到每个顶点的最短路径</p><pre><code>static float max = Float.MAX_VALUE;@param v    源@param a    图@param dist 路径长度@param prev 路径public static void dijkstra(int v, float[][] a, float[] dist, int[] prev) {    // v是源，dist[i]表示当前从源到顶点i的最短特殊路径长度,prev[i]=j：最短路径中顶点i的前一个顶点是j，类似于链表    int n = dist.length - 1;// 节点个数    //如果出发源不在节点范围    if (v &lt; 0 || v &gt; n) {        return;    }    //S集合标记ture的在S中，false的不在    boolean[] s = new boolean[n + 1];    // 初始化    for (int i = 0; i &lt;= n; i++) {        //a[v][i] 从v到i的路径，没有边则是max        dist[i] = a[v][i];        //初始时节点不在集合S中        s[i] = false;        if (dist[i] == Float.MAX_VALUE)            //没有边相连时路径链表初始化为0            prev[i] = 0;        else            //有边直接相连的路径链表初始化为v            prev[i] = v;    }    dist[v] = 0;    //v点初始在S集合中    s[v] = true;    // 循环n+1次,直到所有点加进了S集合    for (int i = 0; i &lt;= n; i++) {        float temp = Float.MAX_VALUE;        int u = v;        //第一次循环找出距离集合最近的节点u        for (int j = 0; j &lt;= n; j++) {            // 寻找不在集合内且距离集合最近的节点j            if ((!s[j]) &amp;&amp; (dist[j] &lt; temp)) {                u = j;// 记录节点                temp = dist[j];// 记录最短特殊路径长度            }        }        s[u] = true;// 将节点u放入集合        //第二次循环找出经由u能够到达的节点        for (int j = 0; j &lt;= n; j++) {// 重新设置dist[]和prev[]的值            if ((!s[j]) &amp;&amp; (a[u][j] &lt; max)) {// 寻找不在集合内，且可达的节点                //新的距离等于从v到u的最短距离+从u到j的距离                float newdist = dist[u] + a[u][j];                if (newdist &lt; dist[j]) { // 与旧值进行比较，保留小的值                    dist[j] = newdist;                    prev[j] = u;                }            }        }    }}</code></pre><p></p><p>#案例2. 最小生成树<br>G的一棵生成树T是包含了G的所有顶点的树，树中各边的权之和W(T)称为树的权,具有最小权的生成树称为G的最小生成树</p><pre><code>#kruskal算法</code></pre><p> 设计思想:</p><ol><li><p>按照长度从小到大对边排序</p></li><li><p>依次考察当前最短边e,如果e与T的边不构成回路,则把e加入树T,否则跳过e.直到选择了n-1条边为止</p><p>算法实现:<br>建立FIND数组,FIND[i]是结点i的连通分支标记</p></li><li><p>初始FIND[i] = i</p></li><li><p>连通分支合并,较小分支标记更新为较大分支标记</p><p>应用:数据分组问题<br>一组数据要把它们按照相关性进行分类 单链聚类</p><p>具体步骤</p></li><li><p>将图的所有连接线去掉，只剩顶点</p></li><li><p>从图的边集数组中找到权值最小的边，将边的两个顶点连接起来</p></li><li><p>继续寻找权值最小的边，将两个顶点之间连接起来，如果选择的边使得最小生成树出现了环路，则放弃该边，选择权值次小的边</p></li><li><p>直到所有的顶点都被连接在一起并且没有环路，最小生成树就生成了。</p><p>使用并查集思路</p></li></ol><p>public class 最小生成树Kruskal算法 {<br>    public static void main(String[] args) {<br>        int[][] edges = {<br>//              begin, end, weight<br>                {0, 1, 6},<br>                {0, 2, 1},<br>                {0, 3, 5},<br>                {2, 1, 5},<br>                {2, 3, 5},<br>                {2, 4, 5},<br>                {2, 5, 4},<br>                {1, 4, 3},<br>                {4, 5, 6},<br>                {5, 3, 2}<br>        };</p><pre><code>    int n = 6;    int[][] mstEdges = kruskal(n, edges);    int totalCost = 0;    System.out.println("Edges of MST: [node1, node2, cost]");    //输出构树的边集    for (int i = 0; i &lt; mstEdges.length; i++) {        int[] edge = mstEdges[i];        for (int j = 0; j &lt; edge.length; j++) {            System.out.print(edge[j] + " ");        }        totalCost += edge[2];        System.out.println();    }    System.out.println("Total cost of MST: " + totalCost);}public static int[][] kruskal(int n, int[][] edges) {    /**     * @Description: 克鲁斯卡尔算法求最小生成树     * @Param: [n, edges] ==&gt; [结点个数， 边集]     * @return: int[] 构成最小生成树的边集     */    int[] pres = new int[n]; //并查集    int[] ranks = new int[n]; //结点的秩,树的层数?    // 初始化：pres一开始设置每个元素的上一级是自己，ranks一开始设置每个元素的秩为0    for (int i = 0; i &lt; n; i++) {        pres[i] = i;        ranks[i] = 0;    }    //用自己定义的MyEdge类里面的compareTo排序，按边权排序    ArrayList&lt;MyEdge&gt; edgesList = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; edges.length; i++) {        edgesList.add(new MyEdge(edges[i]));    }    // 边集从小到大排序    Collections.sort(edgesList);    //最小生成树的边    int[][] mstEdges = new int[n - 1][3];    int count = 0;    for (int i = 0; i &lt; edgesList.size(); i++) {        int[] arr = edgesList.get(i).array;        int a = arr[0], b = arr[1], c = arr[2];        //边的两个节点不在同一个集合里,合并        if (find(a, pres) != find(b, pres)) {            unionSet(a, b, pres, ranks);            //添加到结果集合中            mstEdges[count] = arr;            count++;        }        //如果两个节点的根节点相同,说明已经划在了结果集合里,这条边会构成闭环,不添加        //连接好了所有节点, 所有节点都在一个集合了        if (count == n) {            break;        }    }    //返回结果    return mstEdges;}//并查集//并：合并两个集合，按秩合并public static void unionSet(int n1, int n2, int[] pres, int[] ranks) {    int root1 = find(n1, pres);    int root2 = find(n2, pres);    //当两个元素不是同一组的时候才合并    //两个节点的连接根节点不同    if (root1 != root2) {        //把节点数少的一组划归大的一组        if (ranks[root1] &lt; ranks[root2]) {            pres[root1] = root2;        } else {            pres[root2] = root1;            //如果两组个数相等,结点层数+1            if (ranks[root1] == ranks[root2])                ranks[root1]++;        }    }}//查：查找元素的根节点public static int find(int x, int[] pres) {    int root = x;    //如果此结点上级结点不是自己,继续向上搜索    while (pres[root] != root)        root = pres[root];    //循环后,找到根节点为root    //路径压缩    int p = x;    while (pres[p] != p) {        //把所有结点的上级节点都设置成root        int t = pres[p];        pres[p] = root;        p = t;    }    return root;}</code></pre><p>}</p><p>// 边的排序类<br>class MyEdge implements Comparable {<br>    int[] array;</p><pre><code>MyEdge(int[] array) {    this.array = array;}@Overridepublic int compareTo(Object o) {    o = (MyEdge) o;    int[] arr = ((MyEdge) o).array;    if (array[2] &gt; arr[2]) {        return 1;    } else if (array[2] == arr[2]) {        return 0;    } else {        return -1;    }}</code></pre><p>}</p><pre><code>#prim算法</code></pre><p>prim设计思想<br>输入: 图G=(V,E,W),V 节点,E 边,W 权值, V={1,2,…,n}<br>输出: 最小生成树T<br>初始S = {1}<br>选择连接S与V-S集合的最短边e={i,j},其中i∈S,j∈V-S.将e加入树T,j加入S<br>继续执行上述过程,直到S=V</p><p>prim以点出发, kruskal以边出发</p><p>public class 最小生成树Prim算法 {<br>    public static void main(String[] args) {<br>//交互输入图的邻接矩阵表示，为方便测试，直接给定了邻接矩阵值<br>//        System.out.println(“请输入图定点个数： “);<br>//        Scanner sc = new Scanner(System.in);<br>//        String line = sc.nextLine();<br>//        int n = Integer.parseInt(line);<br>//        System.out.println(“请输入图的路径长度: “);<br>//        int[][] c = new int[n+1][n+1];<br>//        for(int i = 0; i &lt; n; i++) {<br>//            line = sc.nextLine();<br>//            String[] ds = line.split(“,”);<br>//            for(int j = 0;j &lt; ds.length; j++) {<br>//                c[i+1][i+1] = Integer.parseInt(ds[j]);<br>//<br>//            }<br>//        }<br>//        System.out.println(“一次构成树的边为： “);<br>        int n = 6;<br>        //c[i][j]表示从i到j的权，为了方便对应索引，ｃ[0][j]和c[i][0]都设置成0</p><p>//        自己到自己的权，以及不能直接到的值置-1，方便后面处理<br>        int[][] c = {<br>                {0,0,0,0,0,0},<br>                {0,-1,6,1,5,-1,-1},<br>                {0,6,-1,5,-1,3,-1},<br>                {0,1,5,-1,5,6,4},<br>                {0,5,-1,5,-1,-1,2},<br>                {0,-1,3,6,-1,-1,6},<br>                {0,-1,-1,4,2,6,-1}<br>        };<br>        prim(n,c);</p><pre><code>}public static void prim(int n, int[][] c) {    //lowcost[i] 表示 从1到i的最短权值    int[] lowcost = new int[n+1];    //closest[i]的表示：</code></pre><p>//        将整个节点空间定为V，已选的空间从S=1（只有第一个点）开始，<br>//        j在V-S中，找到S里离j最近的节点i ，就记录在closest[j]。<br>        int[] closest = new int[n+1];<br>        //哪些节点已经进入S空间<br>        boolean[] s = new boolean[n+1];<br>        //节点1进入S中，此为初始化<br>        s[1] = true;<br>        //初始化<br>        for(int i = 2; i &lt;= n; i++) {<br>            //初始化第一个节点到每个节点权值<br>            lowcost[i] = c[1][i];<br>            //初始化，因为S中只有1，所以每个V-S中的节点最近的S中的节点一定是1<br>            closest[i] = 1;<br>            //这些节点都初始化为不在S中的状态<br>            s[i] = false;<br>        }</p><pre><code>    //n-1次遍历，把S空间扩充成V    for(int i = 1;i &lt; n; i++) {        //记录一个当前最小权值，不断比较最终变为整个1次遍历过程的最小权值        int min = Integer.MAX_VALUE;        //初始化j，j其实代表的是V-S空间中被选进S的节点        //它的特征是，它到S（任何节点）的权值比其他节点到S（同样随便哪个节点）都小        //这里的思想就是贪心的概念，通过局部最优可以得到全局最优        int j = 1;        //遍历除了直接初始化在S中的1节点外的其他所有节点        for(int k = 2; k &lt;= n; k++) {            //不等于-1即，直接有权值，然后迭代出最小的lowcost，同时更新一些值。            //这里举例更容易说明，如lowcost[k]其实代表的是目前的S空间到k的最小权值，            // 迭代找到了这个k，那么 显然 j就应该是k            if(lowcost[k] != -1 &amp;&amp; lowcost[k] &lt; min &amp;&amp; !s[k]) {                min = lowcost[k];                j = k;            }        }        //输出这对连接，closest[j]记录的其实就是达成lowcost[k]这一最小权值时，S中具体是哪个节点        System.out.println(closest[j] + "-" + j);        //如此，把j纳入S空间        s[j] = true;        //j进入S空间后，更新除1节点外所有节点的状态，他们到S的最小权值还得看看他们到 新进入的j是否更小        for(int k = 2; k &lt;= n; k++) {            if(!s[k] &amp;&amp; c[j][k] != -1) {                //这里注意，如果lowcost[k]本来是-1                //说明本来都不相连直接可以更新了                //这里的逻辑要搞清楚，先判断有必要更新么？（c[j][k]!= -1),                // 然后判断 要么c[j][k]比之前的权值更小，                // 要么原来都不相连（c[j][k] &lt; lowcost[k] || lowcost[k] == -1) 此时进行更新！                if(c[j][k] &lt; lowcost[k] || lowcost[k] == -1) {                    //更新该节点最小的权值                    lowcost[k] = c[j][k];                    //更新该节点在S中最近的点                    closest[k] = j;                }            }        }    }}</code></pre><p>}</p><h2 id="四、回溯"><a href="#四、回溯" class="headerlink" title="四、回溯"></a>四、回溯</h2><p>回溯算法基本思想</p><ol><li>适用：求解搜索问题和优化问题</li><li>搜索空间：树，结点对应部分解向量，可行解在树叶上</li><li>搜索过程：采用系统的方法隐含遍历搜索树</li><li>搜索策略： 深度优先，宽度优先，函数优先，宽深结合等</li><li>结点分支判定条件： 满足约束条件-分支扩张解向量不满足约束条件，回溯到该结点的父结点</li><li>结点状态： 动态生成 白结点（尚未访问）  灰结点（正在访问该结点为根的子树） 黑结点（该结点为根的子树遍历完成）</li><li>存储： 当前路径</li></ol><p>经典问题：n后放置、图的着色、装载问题、货郎问题、零一背包</p><p>#案例1. 4后问题</p><p>在4*4的方格棋盘上放置4各皇后,使得没有两个皇后在同一行、同一列<br>也不在同一条45度斜线上<br>问有多少种可能的布局</p><p>解N皇后问题需要遍历解空间树，遍历中要随时判定当前结点棋盘布局是否符合要求，<br>符合要求则继续向下遍历，直至判断得到一个满足约束条件的叶子结点，从而获得一个满足要求的棋盘布局；<br>不符合要求的结点将被舍弃（称之为剪枝），并回溯到上一层的结点继续遍历。<br>当整棵树遍历结束时，已获得所有满足要求的棋盘布局。</p><p>public class n后放置 {<br>    static int resultCount = 0;<br>    /*<br>     * 皇后位置满足约束条件的判定函数<br>     */<br>    private static boolean place(int[] X,int s) {<br>        //判定s行X[s]列位置上的皇后，与1至s-1行上各皇后的位置是否满足约束条件<br>        for(int i = 0; i &lt; s; i++) {</p><pre><code>        if((X[i] == X[s]) || (Math.abs(i-s) == Math.abs(X[i]-X[s]))) { //行差i-s的绝对值 = 列差的绝对值            return false;        }    }    return true;}/* * 求解N皇后问题的回溯算法 * 棋盘为n*n，函数从第index行起求解皇后的布局，本函数初始调用为tria(queen, 0, n) * arr[n]为可行解 */public static void tria(int[] arr, int i, int n) {    //递归终止条件    //放完最后一个了    if(i &gt;= n) {        // TODO 输出X数组（也可以改写算法，比如记录满足约束的棋盘个数）        for(int in= 0;in&lt;arr.length;in++){            System.out.print(arr[in]+" ");        }        System.out.println();        ++resultCount;        return;    }    //dfs    for(int j = 0; j &lt; n; j++) {        //如果第i个皇后放在j位置满足要求,继续tria        arr[i] = j;        if(place(arr, i)) {            tria(arr, i+1, n);        }    }}public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    System.out.println("一共n个皇后");    int num = sc.nextInt();    int[] queen = new int[num];    tria(queen, 0, num);    System.out.println(resultCount);}</code></pre><p>}</p><p>#案例2. 图的着色问题<br>输入：<br>无向连通图G和m种颜色集合用这些颜色给图的顶点着色<br>每个顶点一种颜色。要求是： G的每条边的两个顶点着不同颜色<br>输出：<br>所有可能的着色方案<br>如果不存在着色方案，回答“No”</p><p>着色问题的应用会场分配问题： 有n项活动需要安排，对于活动i，j，如果i，j时间冲突就说i与j不相容。如何分配这些活动，使得每个会场相容且占用会场最少</p><p>public class 图的着色问题 {</p><pre><code>int n;//图的顶点数int m;//可用颜色数int[][] a;//图的邻接矩阵int[] x;//当前解long sum;//当前已找到的可着色方案数public long mcoloring(int mm, int nn, int[][] aa) {    n = nn;    a = aa;    x = new int[n + 1];    m = mm;    sum = 0;    tria(1);    return sum;}public void tria(int t) {    //递归终止条件    if (t &gt; n) {        //全部涂完的结果        sum++;        for (int i = 1; i &lt;= n; i++)            System.out.print(x[i] + " ");        System.out.println();        return;    }    for (int i = 1; i &lt;= m; i++) {        //给第t个点上第i种色        x[t] = i;        //涂色合法则继续涂下一个        if (ok(t))//剪枝函数            tria(t + 1);        //不合法则置为0，不合法的都是0,判断x[j] == x[k]时为false剔除        x[t] = 0;    }}//判断涂色是否合法的方法public boolean ok(int k) {    for (int j = 1; j &lt;= n; j++) {        //与k相连的点且两点颜色相同则判false        if (a[k][j] == 1 &amp;&amp; x[j] == x[k])//某条边的两个顶点着不同颜色；a[k][j]=1表示某条边（即边集E中的边）            return false;    }    return true;}public static void main(String[] args) {    int n = 5;    int m = 5;    int[][] a = {            {-1, -1, -1, -1, -1, -1},            {-1, 0, 1, 1, 1, 0},            {-1, 1, 0, 1, 1, 1},            {-1, 1, 1, 0, 1, 0},            {-1, 1, 1, 1, 0, 1},            {-1, 0, 1, 0, 1, 0}};    图的着色问题 c = new 图的着色问题();    System.out.println("着色方案如下：");    long sum = c.mcoloring(m, n, a);    System.out.println("可行的着色方案数目为：" + sum);}</code></pre><p>}</p><p>#案例3. 装载问题<br>有n个集装箱，需要装上两艘载重分别为c1，c2的轮船<br>wi为第i个集装箱的重量，且w1+w2+…+wn&lt;=c1+c2<br>问：是否存在一种合理的装载方案把这n个集装箱装上船？</p><p>输入：集装箱重量 向量，c1，c2<br>算法思想： 令第一艘船的装入量为W1</p><ol><li>用回溯算法求使得c1-W1达到最小的装载方案第一艘船尽可能多装</li><li>若满足 w1+w2+…+wn-W1&lt;=c2，看剩下的第二艘装不装得下，装得下则回答yes，否则回答no</li></ol><p>算法</p><ol><li>从大到小排序</li><li>B &lt;- c1; best &lt;- c1;i &lt;- 1         B为当前空隙，best为最小空隙</li><li>while i&lt;=n do</li><li>if 装入i后重量不超过c1</li><li>then B&lt;-B-wi;x[i]&lt;-1;i&lt;-i+1</li><li>else x[i]&lt;- 0;i&lt;-i+1;</li><li>if B&lt;best then 记录解;best &lt;- B;</li><li>Backtrack(i);   回溯</li><li>if i=1 then return 最优解</li><li>else goto 3</li></ol><p>回溯过程：Backtrack(i)<br>while i&gt;1 and x[i] = 0 do<br>     i &lt;- 1;<br>if x[i] = 1;<br>then x[i] &lt;- 0;<br>     B &lt;- B+wi<br>     i &lt;- i+1</p><p>public class 装载问题{</p><pre><code>static int c;//船的载重量static int n;//物品数量static int[] w;//物品的重量static int cw;//当前船的载重量static int bestw;//当前最优载重量（最大载重量）static int r;//剩余物品重量-----未考察过的物品的重量，并非没有装载的物品的重量，所以考察到就减去static int[] X;//是否装载当前深度的物品，装载则X[i]=1，不装载则X[i]=0static int[] Xbest;//记录最优解，最优路径public static void main(String[] args) {    int w[] = {0, 20, 30, 60, 40, 40};    int c = 100;    int n = w.length - 1;    System.out.print("货物重量为： ");    for (int i = 1; i &lt;= n; i++) {        System.out.print(w[i] + "  ");    }    System.out.println();    System.out.println("第一艘船载重量为： " + c);    System.out.println("第二艘船载重量为： " + c);    Initialize(w, c);    int weight2 = 0;    for (int i = 1; i &lt;= n; i++) {        weight2 += w[i] * (1 - Xbest[i]);    }    if (weight2 &gt; c)        System.out.println("无解！");    else {        System.out.println("第一艘船的货物载重为： " + bestw);        System.out.println("第二艘船的货物载重为： " + weight2);        for (int i = 1; i &lt;= n; i++) {            if (Xbest[i] == 1)                System.out.println("第" + i + "件物品装入第一艘船");        }        for (int i = 1; i &lt;= n; i++) {            if (Xbest[i] == 0)                System.out.println("第" + i + "件物品载入第二艘船");        }    }}public static int Initialize(int[] weight, int capacity) {    n = weight.length - 1;    w = weight;    c = capacity;    bestw = 0;    cw = 0;    r = 0;    X = new int[n + 1];    Xbest = new int[n + 1];    for (int i = 1; i &lt;= n; i++) {        r = r + w[i];    }//记录最大剩余物品重量，也就是总重量    Backtrack(1);    return bestw;}public static void Backtrack(int i) {    if (i &gt; n) {//i&gt;n，表示已经到叶子节点        if (cw &gt; bestw) {            for (int j = 1; j &lt;= n; j++)                Xbest[j] = X[j];//记录最优路径        }        bestw = cw;//若cw&lt;bestw，更新bestw=cw        return;    }    r = r - w[i];//计算剩余（未考察）的物品的重量，减去当前考察过的对象的重量    //剪枝函数    if (cw + w[i] &lt;= c) {//约束函数        cw = cw + w[i];//进入子树，则+        X[i] = 1;//左子树1，右子树0        Backtrack(i + 1);        cw = cw - w[i];//到这来表示已经从Backtrack(i+1)里出来，则要复原cw，所以前面+，这里则-，恢复原状。    }    if (cw + r &gt; bestw) {//限界函数，如果cw+r不大于bestw，则不用进入下一层了，因为进入也不大于bestw        //这里不用约束函数，因为不取X[i]=0则一定不会大于c        //因为r值是累计的(在Backtrack(i+1)里)，所以已经减了r=r-w[i]已经减去了w[i]，        // 当你退出Backtrack(i+1)后，返回上一层回溯，就得恢复r，所以有r=r+w[i]        X[i] = 0;        Backtrack(i + 1);    }    r = r + w[i];//递归回退返回上一层时，记得修改r的当前值，如果得不到最优解，    // 再取消当前考察的集装箱，标记为未选，因此剩余容量要再加上当前集装箱重量}</code></pre><p>}</p><p>#案例4. 货郎问题<br>有n个城市,已知任两个城市之间的距离,求一条每个城市恰好经过一次的回路<br>使得总长度最小</p><p>注意哈密顿回路和TSP之间的区别。哈密顿回路问题是要找出是否存在一个旅游线路，每个城市访问一次。这里我们知道哈密顿回路存在（因为图是完整的），事实上存在许多这样的回路，问题是找到一个最小权重的哈密顿回路。</p><p>public class 货郎问题 {<br>    static int INF = (int) 1e7;//设置无穷大的值为10的七次方<br>    static int N = 100;<br>    static int[][] g = new int[N][N];//地图的无向带权邻接矩阵<br>    static int[] x = new int[N];//记录当前路径<br>    static int[] bestx = new int[N];//记录当前最优路径<br>    static int cl;//当前路径长度<br>    static int bestl;//当前最短路径长度<br>    static int n, m;//城市个数n,边数m</p><pre><code>static void swap(int array[], int a, int b) {//交换函数    int temp;    temp = array[a];    array[a] = array[b];    array[b] = temp;}static void Traveling(int t) {    if (t &gt; n) {//到达叶子节点        /*        推销货物的最后一个城市与住地城市有边相连并且路径长度比当前最优值小，说明找到了一条更好的路径，记录相关信息         */        if (g[x[n]][1] != INF &amp;&amp; (cl + g[x[n]][1] &lt; bestl)) {            for (int j = 1; j &lt;= n; j++) {                bestx[j] = x[j];            }            bestl = cl + g[x[n]][1];        }    } else {//没有到达叶子节点        for (int j = t; j &lt;= n; j++) {//搜索扩展节点的所有分支            if (g[x[t - 1]][x[j]] != INF &amp;&amp; (cl + g[x[t - 1]][x[j]] &lt; bestl)) {                //如果第t-1个城市与第t个城市有边相连并且有可能得到更短的路线                swap(x, t, j);//交换两个元素的值                cl = cl + g[x[t - 1]][x[t]];                Traveling(t + 1);//从第t+1层的扩展结点继续搜索                //第t+1层搜索完毕，回溯到第t层原始状态                cl = cl - g[x[t - 1]][x[t]];                swap(x, t, j);            }        }    }}//初始化函数static void init() {    bestl = INF;    cl = 0;    for (int i = 1; i &lt;= n; i++)        for (int j = i; j &lt;= n; j++)            g[i][j] = g[j][i] = INF;    for (int i = 0; i &lt;= n; i++) {        x[i] = i;        bestx[i] = 0;    }}static void print() {    System.out.print("最短路径：");    for (int i = 1; i &lt;= n; i++) {        System.out.print(bestx[i] + "----&gt;");    }    System.out.println("1");    System.out.print("最短路径长度：" + bestl);}public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    int u, v, w;//u,v代表城市，w代表城市u,v之间的距离。    System.out.println("请输入城市数n：");    n = sc.nextInt();    init();    System.out.println("请输入城市之间的连线数：");    m = sc.nextInt();    System.out.println("请依次输入两个城市u,v以及之间的距离w:");    for (int i = 1; i &lt;= m; i++) {        u = sc.nextInt();        v = sc.nextInt();        w = sc.nextInt();        g[u][v] = g[v][u] = w;    }    Traveling(2);//根据排列树的图，从第二层开始    print();}</code></pre><p>}</p><p>//<br>//                { 0, 10, 15, 20 },<br>//                        { 10, 0, 35, 25 },<br>//                        { 15, 35, 0, 30 },<br>//                        { 20, 25, 30, 0 }</p><p>//请输入城市数n：<br>//        ４<br>//        请输入城市之间的连线数：<br>//        １２<br>//        请依次输入两个城市u,v以及之间的距离w:<br>//        １　２　１０<br>//        １　３　１５<br>//        １　４　２０<br>//        ２　１　１０<br>//        ２　３　３５<br>//        ２　４　２５<br>//        ３　１　１５<br>//        ３　２　３５　３　４　３０　４　１　２０　４　２　２５　４　３　３０<br>//        最短路径：1—-&gt;2—-&gt;4—-&gt;3—-&gt;1<br>//        最短路径长度：80<br>//        Process finished with exit code 0</p><p>#案例5. 零一背包<br>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，<br>这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><p>有n种物品，每种物品只有一个，第i种物品价值为vi，重量为wi，i=1，2，3…n<br>问如何选择放入背包的物品,使得总重量不超过B而价值达到最大</p><p>用回溯法实现0-1背包问题。<br>在回溯开始之前，首先对于背包中的物品按照单位重量价值进行排序，方便于后面右子树的剪枝操作。<br>在初始化物品的重量和价值时，已经按照单位重量的价值排好了序。<br>一个典型的子集树问题，对于背包中的每一个物品，可以选择放入（左子树）或者不放入（右子树）。<br>依次对每个节点进行搜索，得到最优解。</p><p>public class 零一背包 {<br>    /*<br>     * 物品 A B C D E F G<br>     * 重量 35 30 60 50 40 10 25<br>     * 价值  10  40  30  50  35  40  30<br>     *<br>     * */<br>    //物品数量<br>    int n=7;<br>    //背包容量<br>    int capacity=150;<br>    //物品重量数组<br>    double weight[]= {35,30, 60, 50, 40, 10, 25};<br>    //物品价值数组<br>    double value[]= {10,  40,  30,  50,  35,  40,  30};</p><pre><code>//最大价值int maxValue = 0;//当前最大价值int currentValue;//当前重量int currentWeight;// 装入方法数组int[] way = new int[n];//最佳装入方法数组int[] bestWay = new int[n];/* * 回溯算法设计 * */public void backTrack(int t) {    // 已经搜索到根节点    if (t &gt; n - 1) {        if (currentValue &gt; maxValue) {            maxValue = currentValue;            for (int i = 0; i &lt; n; i++)                bestWay[i] = way[i];        }        return;    }    // 搜索左边节点    if (currentWeight + weight[t] &lt;= capacity) {        currentWeight += weight[t];        currentValue += value[t];        way[t] = 1;        //回溯        backTrack(t + 1);        currentWeight -= weight[t];        currentValue -= value[t];        way[t] = 0;    }    // 不装入这个物品，直接搜索右边的节点    if (bound(t + 1) &gt;= maxValue) {        backTrack(t + 1);    }}// 用于计算剩余物品的最高价值上界public double bound(int k) {    double maxLeft = currentValue;    int leftWeight = capacity - currentWeight;    // 尽力依照单位重量价值次序装剩余的物品    while (k &lt;= n - 1 &amp;&amp; leftWeight &gt; weight[k]) {        leftWeight -= weight[k];        maxLeft += value[k];        k++;    }    // 不能装时，用下一个物品的单位重量价值折算到剩余空间。    if (k &lt;= n - 1) {        maxLeft += value[k] / weight[k] * leftWeight;    }    return maxLeft;}public static void main(String[] args) {    零一背包 knspsack2 = new 零一背包();    knspsack2.backTrack(0);    System.out.println("该背包能够取到的最大价值为:" + knspsack2.maxValue);    System.out.println("当前背包的重量为:" + knspsack2.capacity);    System.out.println("物品的取出方法为取出的方法为:");    for (int i : knspsack2.bestWay)        System.out.print(i + "  ");}</code></pre><p>}</p><h2 id="五、分支限界"><a href="#五、分支限界" class="headerlink" title="五、分支限界"></a>五、分支限界</h2><p>回溯算法是深度优先，而分支限界是广度优先的一个经典例子<br>回溯法一般遍历整个空间，获取问题的所有解，<br>而分支限界法则是获取一个解(一般来说要获取最优解)</p><p>分支限界是加快搜索速度的一种技术<br>代价函数:<br>    计算函数: 搜索书的结点<br>    值: 极大化问题是以该点为根的子树所有可行解的值的上界(极小化问题的下界)<br>    性质: 对极大化问题父节点代价不小于结点的代价(极小化问题相反)<br>停止分支回溯父结点的依据<br>    1. 不满足约束条件<br>    2. 对于极大化问题,代价函数值小于当前界(对于极小化问题是大于界)</p><p>界的更新:<br>    对极大化问题,如果一个新的可行解的优化函数值大于(极小化问题为小于)当前的界,则把界更新为该可行解的值</p><p>界: 当前得到的可行解的目标函数的最大值(极小化问题相反)<br>界初值: 极大化问题初值为0(极小化问题为最大值)</p><p>经典问题: 圆排列问题、最大团问题、连续邮资问题</p><p>#案例1. 圆排列问题<br>给定n个圆的半径序列，各圆与底线相切排列<br>假定每个圆占大于1的长度，求具有最小长度ln的圆的排列顺序</p><p>解： &lt;i1,i2,…,in&gt;为1，2，…，n的排列<br>部分解向量&lt;i1,i2,…,ik&gt;：表示前k个圆已经排好<br>令B={i1,i2,…,ik}<br>下一个圆选择ik+1</p><p>约束条件：ik+1 属于 {1,2,…,n}-B<br>界：当前得到的最小圆排列长度</p><p>代价函数：<br>     算法已选择好1～k个圆<br>     rk：第k个圆的半径<br>     dk：第k-1个圆到第k个圆的圆心水平距离<br>     xk：第k个圆的圆心坐标，规定x1=0<br>     lk：第1～k个圆的排列长度<br>     Lk：放好1～k个圆以后，对应结点的代价函数值  Lk &lt;= ln<br>xk = xk-1 + dk<br>部分排列长度： lk = xk+rk+r1<br>排列长度ln = xk+ dk+1 + dk+2 + … + dn + rn + r1<br>dk = 开方（（rk + rk-1）平方 - （rk - rk-1）平方）<br>   = 2开方（rk-1 × rk）<br>ln = xk + dk+1 + dk+2 +…+ rn + r1<br>Lk = xk + （2n -2k + 1）r + r1<br>r = min（rij，rk）</p><p>实例：<br>输入： R={1,1,2,2,3,5}<br>      排列 &lt;1，2，3，4，5，6&gt;</p><p>public class 圆排列问题 {</p><pre><code>public int n;//待排列圆的个数public float min;//当前最优值public float[] x;//当前圆排列圆心横坐标public float[] r;//当前圆排列public float circlePerm(int nn,float[] rr){    n=nn;    r=rr;    min=1000000;    x=new float[n+1];    backtrack(1);    return min;}public void backtrack(int t){    if(t&gt;n)        compute();    else{        for(int j=t;j&lt;=n;j++){            swap(r,t,j);            float centerx=center(t);            if(centerx+r[t]+r[1]&lt;min){//下界约束                x[t]=centerx;                backtrack(t+1);            }            swap(r,t,j);        }    }}public void swap(float[] r,int i,int j){    float temp=r[i];    r[i]=r[j];    r[j]=temp;}public float center(int t){//计算当前所选择圆的圆心横坐标    float temp=0;    for(int j=1;j&lt;t;j++){        float valuex=(float) (x[j]+2.0*Math.sqrt(r[t]*r[j]));        if(valuex&gt;temp)            temp=valuex;    }    return temp;}public void compute(){//计算当前圆排列的长度    float low=0;    float high=0;    for(int i=1;i&lt;=n;i++){        if(x[i]-r[i]&lt;low) low=x[i]-r[i];        if(x[i]+r[i]&gt;high) high=x[i]+r[i];    }    if(high-low&lt;min)        min=high-low;}public static void main(String[] args) {    int n=3;    float[] r={0,1,1,2};//r下标从1开始， 0无用，只是凑数    圆排列问题 c=new 圆排列问题();    float min=c.circlePerm(n, r);    System.out.println("最小圆排列长度为"+min);}</code></pre><p>}</p><p>/*<br>输出：<br>最小圆排列长度为7.656854<br>*/</p><p>#案例2. 最大团问题</p><p>问题： 无向图G=&lt;V,E&gt;，求G的最大团<br>G的子图： 点都属于V，边都属于E<br>补图： 原来没边的都有边，有边的没了边</p><p>团： G的完全子图， 即任意两个顶点之间都有边的子图<br>最大团： 顶点数最多的团<br>独立集： 任意两点都没边</p><p>解： &lt;x1,x2,…,xn&gt; 为0-1向量，xk=1表示顶点k属于最大团<br>约束条件： 该顶点与当前团内每个顶点都有边相连<br>界： 当前已检索到的极大团的顶点数<br>代价函数： F = Cn + n - K<br>Cn为目前团的顶点数， k为结点层数</p><p>public class 最大团问题 {</p><pre><code>public int[] x;//当前解（x[i]=1表示i点在最大团中，=0表示不在团中）public int n;//图G的顶点数public int cn;//当前顶点数public int bestn;//当前最大顶点数public int[] bestx;//当前最优解public int[][] a;//图G的邻接矩阵,0：不连通；1：连通public int count;//图G的最大团个数public void backtrack(int i){    if(i&gt;n){        for(int j=1;j&lt;=n;j++){            bestx[j]=x[j];            System.out.print(x[j]+" ");        }        System.out.println();        bestn=cn;        count++;        return;    }    else{        boolean ok=true;        for(int j=1;j&lt;i;j++){//检查顶点i是否与当前团全部连接            if(x[j]==1&amp;&amp;a[i][j]==0){                ok=false;                break;            }        }        if(ok){//从顶点i到已选入的顶点集中每一个顶点都有边相连            //进入左子树            x[i]=1;            cn++;            backtrack(i+1);            x[i]=0;            cn--;        }        if(cn+n-i&gt;=bestn){//当前顶点数加上未遍历的课选择顶点&gt;=当前最优顶点数目时才进入右子树;如果不需要找到所有的解，则不需要等于            //进入右子树            x[i]=0;            backtrack(i+1);        }    }}public int maxclique(int nn,int[][] aa){    //初始化    n=nn;    a=aa;    x=new int[n+1];    bestx=x;    cn=0;    bestn=0;    count=0;    backtrack(1);    return bestn;}public static void main(String[] args) {    int[][] a={{-1,-1,-1,-1,-1,-1},{-1,0,1,0,1,1},{-1,1,0,1,0,1},{-1,0,1,0,0,1},{-1,1,0,0,0,1},{-1,1,1,1,1,0}};//a的下标从1开始，-1的值无用    int n=5;    最大团问题 m=new 最大团问题();    System.out.println("图G的最大团解向量为：");    System.out.println("图G的最大团顶点数为："+m.maxclique(n, a));    System.out.println("图G的最大团个为："+m.count);}</code></pre><p>}</p><p>/*<br>输出：<br>图G的最大团解向量为：<br>1 1 0 0 1<br>1 0 0 1 1<br>0 1 1 0 1<br>图G的最大团顶点数为：3<br>图G的最大团个为：3<br>*/</p><p>#案例3. 连续邮资问题</p><p>连续邮资问题：<br>给定n种不同面值的邮票，每个信封至多贴m张<br>试给出邮票的最佳设计，使得从1开始<br>增量为1的连续邮资区间达到最大</p><p>实例： n=5， m=4<br>设计1： 面值 X = &lt;1，3，11，15，32&gt;<br>        邮资连续区间 {1,2,…,70}<br>设计2： 面值 X = &lt;1，6，10，20，30&gt;<br>        邮资连续区间{1,2,3,4}</p><p>约束条件：在结点x1…xi处，邮资最大连续区间为{1，…,ri}<br>xi+1 的取值范围是<br>{xi+1,…,ri+1}<br>若xi+1&gt;ri+1，ri+1的邮资无法支付<br>yi（j）： 用至多m张面值 xi的邮票加上x1，x2，…，xi-1面值的邮票贴j邮资时的最少邮票数<br>则：<br>yi（j） = min{t + yi-1(j - txi) }<br>y1(j) = j<br>ri = min{j|yi(j) &lt;= m, yi(j+1) &gt; m}</p><p>界： max， m张邮票连续付的最大邮资</p><p>public class 连续邮资问题 {<br>    int m;<br>    int n;<br>    int stamps[];<br>    int maxNum = 0;<br>    int[] tempset;<br>    int current;<br>    int rightPos;<br>    int base;<br>    public 连续邮资问题(int m,int n,int[] stamps){<br>        this.m = m;<br>        this.n = n;<br>        this.stamps = stamps;<br>        check();<br>        printResult();<br>    }</p><pre><code>public void check(){    tempset = new int[stamps[(stamps.length-1)]*4+1];    maxNum = m;//因为第一个确定是1，所以初始化最大的面值就是 1*m    for (int i=1;i&lt;5;i++){        int min = Math.max(stamps[i],maxNum)+1;;        int max = stamps[i]*m;        if (min &lt; stamps[i]+1){            return;        }        maxNum = min-1;        tempset[maxNum]=1;        if (!checkSpan(min,max,i)){            return;        }    }}public boolean checkSpan(int min,int max,int rightPos){    base = min;    current=stamps[rightPos];    this.rightPos = rightPos;    backtrace(0);    if (tempset[min] == 0){        return false;    }    for (int i=min;i&lt;max;i++){        if (tempset[i] == 0){            return true;        }        else{            maxNum++;        }    }    return true;}public void backtrace(int i){    if (i &gt;= (m-1)){        return;    }    else{        for (int j=0;j&lt;rightPos+1;j++){            current += stamps[j];            if (current &gt;= base){                tempset[current] = 1;            }            backtrace(i+1);            current -= stamps[j];        }    }}public void printResult(){    System.out.println(maxNum);}public static void main(String args[]){    int m=4;    int n=5;    int[] stamps={1,3,11,15,32};    new 连续邮资问题(m,n,stamps);}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SortSollutions.md</title>
      <link href="/2021/04/26/ji-chu-zheng-li/sortsollutions/"/>
      <url>/2021/04/26/ji-chu-zheng-li/sortsollutions/</url>
      
        <content type="html"><![CDATA[<h3 id="八大排序"><a href="#八大排序" class="headerlink" title="八大排序"></a>八大排序</h3><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><pre><code>冒泡排序原理：相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处</code></pre><p>public class 冒泡排序 {</p><pre><code>public void maoPaoSort(ArrayList&lt;Integer&gt; arrayList) {    for (int i = arrayList.size(); i &gt; 0; i--) {        for (int j = 0; j &lt; i - 1; j++) {            if (arrayList.get(j) &gt; arrayList.get(j + 1)) {                int tmp = arrayList.get(j);                arrayList.set(j, arrayList.get(j + 1));                arrayList.set(j + 1, tmp);            }        }    }}public static void main(String[] args) {    冒泡排序 mp = new 冒泡排序();    Scanner sc = new Scanner(System.in);    ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();    while (sc.hasNextInt()) {        arr.add(sc.nextInt());    }    mp.maoPaoSort(arr);    System.out.println(arr.toString());}</code></pre><p>}</p><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><pre><code>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处public void chooseSort(int[] arr){    for(int i = 0;i&lt;arr.length;i++){        //每一轮把后面最小的放到第i位上        for(int j=i;j&lt;arr.length;j++){            if(arr[j]&lt;arr[i]){                int temp = arr[j];                arr[j] = arr[i];                arr[i] = temp;            }        }    }}</code></pre><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><pre><code>原理：从1索引处开始，将后面的元素插入到之前的有序列表中，使之仍保持有序public int[] insertSort(int[] arr) {    for (int i = 1; i &lt; arr.length; i++) {        int tmp = arr[i];        for (int j = i-1; j &gt;= 0; j--) {            if (tmp &lt; arr[j]) {                //后移一位                arr[j+1] = arr[j];            }else{                //插入                arr[j+1] = tmp;                break;            }        }    }    return arr;}</code></pre><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><pre><code>希尔排序原理：他是对插入排序的一个优化，核心的思想就是合理的选取增量，经过一轮排序后，就会让序列大致有序，然后再不断地缩小增量，进行插入排序，直到增量为 1，那整个排序结束public int[] shellSort(int[] arr) {    //增量的大小最好定义为数组长度的一半，然后不断减半，直至为1    int len = arr.length;    for (int h = len / 2; h &gt; 0; h /= 2) {        //插入排序        for (int i = h; i &lt; arr.length; i+=h) {            int tmp = arr[i];            for (int j = i-h; j &gt;= 0; j-=h) {                if (tmp &lt; arr[j]) {                    //后移h位                    arr[j+h] = arr[j];                }else{                    //插入                    arr[j+h] = tmp;                    break;                }            }        }    }    return arr;}</code></pre><h2 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h2><pre><code>快速排序原理：分治法：比大小，再分区实现步骤：1.从数组中取出一个数，作为基准数2.分区：将比这个数大的数放在它的右边，比它小的数放在它的左边（挖坑填数的思想）挖坑填数思想：（1）：用基准数挖出形成第一个坑（2）：由后向前找比它小的数，找到后挖出此数填到前一个坑中（3）：由前向后找比它大或等于它的数，找到后挖出此数填到前一个坑中3.再对左右区间重复第二步，直到各区间只有一个数（用递归方法实现）public void quickSort(int[] arr,int start,int end){    if(start&gt;=end) return;    int key = arr[start];    int l = start,r = end-1;    while(l&lt;r){        while(l&lt;r&amp;&amp;arr[r]&gt;=key) r--;        while(l&lt;r&amp;&amp;arr[l]&lt;=key) l++;        if(l&lt;r){            int temp = arr[l];            arr[l] = arr[r];            arr[r] = temp;        }    }    arr[start] = arr[r];    arr[r] = key;    quickSort(arr,start,r);    quickSort(arr,r+1,end);}</code></pre><h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h2><pre><code>归并排序原理：假设初始序列有N个记录，则可以看成是N个有序的子序列（拆分思想，递归实现），每个子序列的长度是1，然后两两归并，得到N/2个长度为2或1的有序子序列，再两两归并.如此重复，直到一个长度为N的有序子序列为止mergeSort(array,0,array.length-1);public void mergeSort(int[] arr,int start,int end){    if(end&lt;=start) return;    //二分    int mid = start+(end-start)/2;    mergeSort(arr,start,mid);    mergeSort(arr,mid+1,end);    //归并    merge(arr,start,mid,end);}public void merge(int[] arr,int start,int mid,int end){    int[] temp = new int[arr.length];    for(int i=start;i&lt;=end;i++){        temp[i] = arr[i];    }    int l = start,r = mid+1;    for(int i=start;i&lt;=end;i++){        if(l&gt;mid){            arr[i] = temp[r];            r++;        }        else if(r&gt;end){            arr[i] = temp[l];            l++;        }        else if(temp[l]&lt;=temp[r]){            arr[i] = temp[l];            l++;        }        else{            arr[i] = temp[r];            r++;        }    }}</code></pre><h2 id="7-基数排序"><a href="#7-基数排序" class="headerlink" title="7. 基数排序"></a>7. 基数排序</h2><pre><code>基数排序原理：基数排序属于分配式排序，又称桶排序，通过分配再收集的方法进行排序，属于稳定式排序。1. 首先求出原数组中最大位数的位数,并建一个装数的二维数组和用来统计每个桶中有多少数的一维数组2. 最大数时几位数,则装桶几次(循环实现)3. 先将源数组的数装进桶中,再将装好的桶进行遍历,重新装回源数组//N位数桶排序public void bucketSort(ArrayList&lt;Integer&gt; arrayList){    //先找出最大数的位数,确定要做几次桶循环    int max = 0;    for (Integer integer:arrayList){        max=max&gt;integer?max:integer;    }    int len = String.valueOf(max).length();    //二维桶    for (int n = 0,x=1;n&lt;len;n++,x*=10){        //初始化一个二维的数组,一共十个桶,每个桶的列表存放该位下的数字        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;();        for (int k = 0;k&lt;10;k++){            arrayLists.add(new ArrayList&lt;Integer&gt;());        }        for (int i =0;i&lt;arrayList.size();i++){            //获取个十百位上的数确定放在第几个桶里: 模10的n次方余10            int key = arrayList.get(i) /x %10;            //存到对应得桶里            arrayLists.get(key).add(arrayList.get(i));        }        //把当前已排好的顺序放进临时列表        ArrayList&lt;Integer&gt; tmpArr = new ArrayList&lt;&gt;();        for (ArrayList&lt;Integer&gt; list : arrayLists) {            tmpArr.addAll(list);        }        //用临时list替换原先的列表        for (int t =0;t&lt;tmpArr.size();t++){            arrayList.set(t,tmpArr.get(t));        }    }}</code></pre><h2 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="8. 堆排序"></a>8. 堆排序</h2><pre><code>堆排序原理：堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。方法1. 利用最小堆存储,根节点为最小值,依次弹出,存放到临时数组里,但这需要额外的存储空间方法2. 利用最大堆,根节点是最大值,每次把根节点和末位交换,继续调整最大堆public static void heapSort(int[] arr) {    //求出最大非叶子结点的索引    int len = arr.length;    int startIndex = (len-1)/2;    //从最大非叶子节点开始调用最大堆函数,直到根节点为最大值    //根节点索引是0,i要&gt;=0,否则排最大堆时会忽视根节点    for (int i = startIndex; i &gt;= 0; i--) {        toMaxheap(arr, i, len);    }    // 以上的运行结果已经达到大顶堆的效果，    // 此时只需每次将根节点的元素与最后一个叶子节点的元素互换就行，并递归将剩余元素继续转化成大顶堆    for (int j = len - 1; j &gt; 0; j--) {        int max = arr[0];        arr[0] = arr[j];        arr[j] = max;        toMaxheap(arr, 0, j);    }}//生成最大堆的函数public static void toMaxheap(int[] arr, int start, int end) {    //先求出传入最大非叶子节点的左右节点索引    int leftIndex = start * 2 + 1;    int rightIndex = start * 2 + 2;    //比较这三个节点的值,得到最大值的索引    int maxIndex = start;    if(leftIndex&lt;end&amp;&amp;arr[leftIndex]&gt;arr[maxIndex]) maxIndex = leftIndex;    if(rightIndex&lt;end&amp;&amp;arr[rightIndex]&gt;arr[maxIndex]) maxIndex = rightIndex;    // 如果max不是在maxIndex，则调换位置，将最大节点放在大顶堆的根节点处    if(maxIndex!=start){        int temp = arr[start];        arr[start] = arr[maxIndex];        arr[maxIndex] = temp;        // 互换完之后可能会影响最大节点以下的大顶堆结构，即maxIndex下的子树,        // 所以这里需要递归调用方法，保证每个子树都是大顶堆结构        toMaxheap(arr, maxIndex,end);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springJPA</title>
      <link href="/2021/04/23/java-kuang-jia/springjpa/"/>
      <url>/2021/04/23/java-kuang-jia/springjpa/</url>
      
        <content type="html"><![CDATA[<p>day1：orm思想和hibernate以及jpa的概述和jpd的基本操作<br>day2：springdatajpa的运行原理以及基本操作<br>day3：多表操作，复杂查询</p><p>##day1<br>第一：orm（对象关系映射）思想<br>    主要目的：操作实体类就相当于操作数据库表<br>    需要建立两个映射思想：<br>        1. 建立实体类和表的关系<br>        2. 建立实体类中属性和表中字段的关系<br>    不再重点关注：sql语句</p><pre><code>实现了ORM思想的框架：mybatis（半自动orm）， hibernatetk.mybatis.mapper 插件</code></pre><p>第二：hibernate框架介绍<br>    hibernate是一个开源的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，<br>它将pojo与数据库表建立映射关系，是一个全自动的orm框架，可以自动生成SQL语句，自动执行。</p><p>第三：JPA规范<br>    内部由接口和抽象类构成，所有厂商实现jpa规范</p><p>第四：jpa的基本操作<br>    增删改查<br>    搭建环境的过程<br>        1. 创建maven工程导入坐标<br>        2. 需要配置jpa的核心配置文件<br>            配置到类路径下的META-INF的文件夹下<br>            命名：persistence.xml<br>        3. 编写客户的实体类<br>        4. 配置实体类和表，类中属性和表中字段的映射关系<br>        5. 保存客户到数据库中<br>    Jpa操作步骤：<br>        @Test<br>        public void testSave(){<br>            //1. 加载配置文件创建工厂（实体管理类工厂）对象<br>            EntityManagerFactory factory = Persistence.createEntityManagerFactory(“myJpa”);<br>            //2. 通过实体管理类工厂获取实体管理类<br>            EntityManager em = factory.createEntityManager();<br>            /*<br>                createEntityManager()方法内部维护了数据库信息，缓存信息，所有的实体管理类对象<br>                在创建EntityManagerFactory的过程中会根据配置创建数据库表<br>                EntityManagerFactory的创建过程比较浪费资源<br>                特点：线程安全的对象<br>                    多个线程访问同一个emfactory不会有线程安全问题<br>                    创建一个公共的emfactory的对象，使用静态代码块<br>            */<br>            //3. 获取事务对象，开启事务<br>            EntityTransaction tx = em.getTransaction();<br>            tx.begin();<br>            //4. 完成增删改查操作<br>            User user = new User();<br>            user.setUsername(“tsq”);<br>            user.setPassword(“lcc”);<br>            //保存<br>            em.persist(user);<br>            //5. 提交事务<br>            tx.commit();<br>            //6. 释放资源<br>            em.close();<br>            factory.close();<br>            }<br>        }</p><p>/**</p><ul><li><p>解决实体管理类工厂的浪费和耗时问题</p></li><li><p>通过静态代码块创建公共实体管理类工厂</p></li><li></li><li><p>第一次访问getEntityManager方法: 经过静态代码创建一个factory对象,再调用方法创建一个EntityManger对象</p></li><li><p>第二次访问: 直接通过已经创建好的factory对象创建EntityManager对象</p></li><li></li><li><p>/<br>public class JpaUtils {</p><p>  private static EntityManagerFactory factory;</p><p>  static{</p><pre><code>  factory = Persistence.createEntityManagerFactory("myJpa");</code></pre><p>  }</p><p>  public static EntityManager getEntityManager(){</p><pre><code>  return factory.createEntityManager();</code></pre><p>  }</p></li></ul><p>}</p><pre><code>/** * 根据id查询客户 */@Testpublic void testGetReference(){    //1. 通过工具类获取entityManager    EntityManager entityManager = JpaUtils.getEntityManager();    //2. 开启事务    EntityTransaction tx = entityManager.getTransaction();    //3. 增删改查    /**     * find: 根据id查询数据     *      class: 查询数据的结果需要包装的实体类类型字节码     *      id: 查询的主键的取值     *      1. 获取的对象就是当前客户对象本身     *      2. 在调用find方法的时候,就会发送sql语句查询数据库     *      立即加载     *     * getReference方法     *      1. 获取的对象是一个动态代理对象     *      2. 调用getReference方法不会立即发送sql语句查询数据库     *          延迟加载,当调用查询结果对象的时候,才会发送查询的sql语句: 什么时候用,什么时候发送sql语句查询数据库     *     */    User user = entityManager.getReference(User.class,1);    System.out.println(user);    //4. 提交事务    tx.commit();    //5. 释放资源    entityManager.close();}</code></pre><p>}</p><pre><code>/** * 查询全部 *  jpql: from com.sqtian.domain.User *  sql: select * from user */@Testpublic void testFindAll(){    //1. 获取em    EntityManager em = JpaUtils.getEntityManager();    //2. 开启事务    EntityTransaction tx = em.getTransaction();    tx.begin();    //3. 查询全部    String jpql = "from com.sqtian.domain.User";    Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jqpl的对象    //发送查询,并封装结果集    List resultList = query.getResultList();    for (Object o : resultList) {        System.out.println(o);    }    //4. 提交事务    tx.commit();    //5. 释放资源    em.close();}</code></pre><p>添加分页limit查询<br>        String jpql = “from com.sqtian.domain.User”;<br>        Query query = em.createQuery(jpql);//创建Query查询对象,query对象才是执行jqpl的对象</p><pre><code>    //对参数赋值: 分页参数    //起始索引    query.setFirstResult(0);    //每页查询条数    query.setMaxResults(2);    //发送查询,并封装结果集    List resultList = query.getResultList();    for (Object o : resultList) {        System.out.println(o);    }</code></pre><p>//对占位符参数赋值<br>String jpql = “from User where custName like ？”；<br>Query query = em.createQuery(jpql);<br>//占位符的索引位置, 取值<br>query.setParameter(1,”lcc%”);</p><h2 id="day2：springdatajpa的运行原理以及基本操作"><a href="#day2：springdatajpa的运行原理以及基本操作" class="headerlink" title="day2：springdatajpa的运行原理以及基本操作"></a>day2：springdatajpa的运行原理以及基本操作</h2><p>第一 springDataJpa的概述<br>    Spring Data JPA 是Spring 基于ORM框架, JPA规范的基础上封装的一套JPA应用框架<br>    可以让开发者解脱DAO层的操作,基本上所有的CRUD都可以依赖于它来实现,在实际的工作工程中<br>    推荐使用Spring Data JPA + ORM(hibernate)完成操作</p><p>第二 springDataJpa的入门操作<br>    搭建环境<br>        创建工程导入坐标<br>        配置spring的配置文件<br>        编写实体类(Customer), 使用jpa注解配置映射关系<br>    编写一个符合springDataJpa的dao层接口<br>        只需要编写dao层接口，不需要编写dao层接口的实现类<br>        dao层接口规范<br>            需要继承两个接口： JpaRepository，JpaSepecificationExecutor<br>            需要提供相应的泛型<br>            真正发挥作用的是接口的实现类，在程序执行的过程中，自动帮助我们动态的生成了接口的实现类对象<br>            动态代理<br>@RunWith(SpringJUnit4ClassRunner.class)//声明spring提供的单元测试环境<br>@ContextConfiguration(locations = “classpath:applicationContext.xml”)//指定spring容器的配置信息<br>public class UserDaoTest {<br>    @Autowired<br>    private UserDao userDao;</p><pre><code>/** * 根据id查询 */@Testpublic void testFindOne(){    User one = userDao.findOne(1);    System.out.println(one);}/** * save(user)： 保存或者更新 *  根据传递对象是否存在主键id *  如果没有id主键属性： 保存 *  存在id主键属性： 根据id查询数据，更新数据 * delete(id): 根据id删除 * findAll(): 查询所有 */</code></pre><p>}</p><p>第三 springDataJpa的运行过程和原理剖析<br>    1. 通过JdkDynamicAopProxy的invoke方法创建了一个动态代理对象<br>    2. SimpleJpaRepository当中封装了JPA的操作（借助JPA的api完成数据库的CRUD）<br>    3. 通过hibernate完成数据库操作（封装了jdbc）</p><p>第四 复杂查询<br>    1. 借助接口中定义的方法<br>    findOne(id): 根据id查询 立即加载<br>    getOne(id): 懒加载<br>    count(): 查询全部客户数量<br>    exists(id): 查询该id客户是否存在</p><pre><code>2. 需要将JPQL语句配置到接口方法上    特有的查询：需要在dao接口上配置方法    在新添加的方法上，使用@Query注解的形式配置jpql查询语句    对于多个占位符参数,赋值默认情况下占位符的位置需要和方法参数中的位置保持一致    可以指定占位符参数的位置, ?1 ?2 指定取值来源    更新数据     /**     * 更新操作     */    @Query(value = "update User set username = ?2 where id = ?1")    @Modifying    void updateUser(int id,String username);3. sql语句的查询    注解:    @Query(value="", nativeQuery = (false: 使用jpql查询, true: 使用sql查询))4. 方法名称规则查询    是对jpql查询更加深入的一层封装    无需注解添加语句,只需要按照SpringDataJpa提供的方法名称规则定义方法,不需要再去配置jpql语句,完成查询    findByXXX: 查询        对象中的属性名,查询条件        findByUsername        在springdataJpa运行阶段会根据方法名称进行解析    findBy + 属性名称 + 查询方式(Like|isnull)        findByXXXLike: 模糊查询    findBy + 属性名称 + 查询方式 + 多条件的连接符(and|or) + 属性名称 + 查询方式 </code></pre><h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><p>第一：Specifications动态查询<br>    方法<br>    T findOne(Specification<t> spec); //查询单个对象<br>    List<t> findAll(Specification<t> spec); //查询列表</t></t></t></p><pre><code>//查询全部, 分页 pageable: 分页参数//返回值: 分页pageBeanPage&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);//查询列表List&lt;T&gt; findAll(Specification&lt;T&gt; spec); //统计查询Specification: 查询条件    自定义我们自己的Specification实现类    实现         //root: 查询的根对象(查询的任何属性都可以从根对象中获取)        //CriteriaQuery: 顶层查询对象, 自定义查询方式(了解: 一般不用)        //CriteriaBuilder: 查询的构造器,封装了很多的查询条件        Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb); //封装查询条件@Testpublic void testSpec(){    /**     * 自定义查询条件     *      1. 实现Specification接口（提供泛型： 查询对象类型）     *      2. 实现toPredication方法（构造查询条件）     *      3. 需要借助方法参数中的两个参数（     *          root： 获取需要查询的对象属性     *          CriteriaBuilder： 构造查询条件， 内部封装了很多查询条件（模糊匹配，精准匹配）     *     */    Specification&lt;User&gt; spec = new Specification&lt;User&gt;() {        public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {            //1. 获取比较的属性            Path&lt;Object&gt; username = root.get("username");            //2. 构造查询条件　select * from user where username = "tsq"            Predicate predicate = criteriaBuilder.equal(username, "tsq");//进行精准匹配 （比较的属性，比较的属性的取值）            return predicate;        }    };    User one = userDao.findOne(spec);    System.out.println(one);}        /**         * 多条件查询         *         */        Specification&lt;User&gt; spec = new Specification&lt;User&gt;() {            public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) {                //1. 获取比较的属性                Path&lt;Object&gt; username = root.get("username");                Path&lt;Object&gt; password = root.get("password");                //2. 构造查询条件　select * from user where username = "tsq" and password = "123"                Predicate predicate1 = criteriaBuilder.equal(username, "tsq");//进行精准匹配 （比较的属性，比较的属性的取值）                Predicate predicate2 = criteriaBuilder.equal(username, "123");                //3. 组合多个查询条件　cb.and  cb.or                Predicate predicate = criteriaBuilder.and(predicate1, predicate2);                return predicate;            }        };        /**        * 模糊查询        */        equal: 直接得到path对象进行比较即可        gt, ge, le, like: 得到path对象之后,根据path指定比较的参数类型,再去进行比较 path.as(类型的字节码对象)        Predicate predicate = criteriaBuilder.like(username.as(String.class), "ts%");        //排序        Sort sort = new Sort(Sort.Direction.DESC,"id");        List&lt;USer&gt; list = userDao.findAll(spec,sort);        //分页查询        Pageable pageable = new PageRequest(0,2);</code></pre><p>第二：多表之间的关系和操作多表的操作步骤<br>    表关系:<br>        一对一<br>        一对多<br>            一的一方: 主表<br>            多的一方: 从表<br>            外键: 需要在从表上新建一列作为外键,他的取值来源于主表的主键</p><pre><code>    多对多实体类中的关系:    包含关系: 可以通过实体类中的包含关系描述表关系    继承关系分析步骤:    1. 明确表关系    2. 确定表关系 (描述 外键|中间表)    3. 编写实体类, 在实体类中描述表关系(包含关系)    4. 配置映射关系</code></pre><p>第三：完成多表操作</p><ol><li>一对多操作<pre><code> 一个客户可以有多个联系人 主表: 客户表 从表: 联系人表 在从表上添加外键</code></pre></li></ol><pre><code>/** * 在联系人类里配置联系人到客户的多对一关系 *      使用注解的形式配置多对一关系 *      1. 配置表关系 *      2. 配置外键 * */@ManyToOne(targetEntity = User.class)@JoinColumn(name = "lkm_usr_id",referencedColumnName = "id")private User user;//在客户类里配置客户和联系人之间的关系（一对多关系）/** * 使用注解形式配置多表关系 *      1. 声明关系 *          @OneToMany: 配置一对多的关系 *              targetEntity： 对方对象的字节码对象 * *      2. 配置外键（中间表） *          @JoinColum: 配置外键 *              name： 外键字段名称 *              referencedColumnName： 参照的主表的主键字段名称 * 在客户实体类上（一的一方）添加了外键配置， 所以对于客户而言，也具备了维护外键的作用 * */@OneToMany(targetEntity = LinkMan.class)@JoinColumn(name = "lkm_usr_id",referencedColumnName = "id")private Set&lt;LinkMan&gt; linkManSet = new HashSet&lt;LinkMan&gt;();测试方法@Test@Transactional@Rollback(false)public void testAdd(){    User user = new User();    user.setUsername("tian");    user.setPassword("tsq");    LinkMan linkMan = new LinkMan();    linkMan.setLkmName("lv");    linkMan.setLkmPhone("1314");    linkMan.setUser(user);    user.getLinkManSet().add(linkMan);    userDao.save(user);    linkManDao.save(linkMan);}//放弃外键维护权    mappedBy: 对方配置关系的属性名称@OneToMany(mappedBy = "user")private Set&lt;LinkMan&gt; linkManSet = new HashSet&lt;LinkMan&gt;();//级联操作在操作主体的实体类上配置cascade属性cascade: 配置级联 CascadeType.@OneToMany(mappedBy = "user", cascade = CascadeType.ALL)private Set&lt;LinkMan&gt; linkManSet = new HashSet&lt;LinkMan&gt;();</code></pre><ol start="2"><li>多对多操作<pre><code> 案例： 用户和角色     用户:      角色： 分析步骤：     1. 明确表关系         多对多     2. 确定表关系（描述 外键/中间表）         中间表     3. 编写实体类，在实体类中描述表关系（包含关系）         用户：包含角色的集合         角色：包含用户的集合     4. 配置映射关系</code></pre></li></ol><pre><code>    User.java    //声明关系    @MangToMany(targetEntity = Role.class) //多对多 targetEntity: 代表对方的实体类字节码    //配置中间表(包含两个外键)    @JoinTable(name = "sys_user_role",   //中间表的名字        //joinColums, 当前对象在中间表中的外键 name 外键名,即中间表中列的名字 referencedColumnName 参照的主表的主键名        joinColums ={@JoinColum(name="sys_user_id",referencedColumnName = "user_id")},        //inverseJoinColumns, 对方对象在中间表的外键        inverseJoinColumns = {@JoinColumn(name = "sys_role_id", referencedColumnName = "role_id")}    )    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();    Role.java    //声明关系    @MangToMany(targetEntity = User.class) //多对多 targetEntity: 代表对方的实体类字节码    //配置中间表(包含两个外键)    @JoinTable(name = "sys_user_role",   //中间表的名字        //joinColums, 当前对象在中间表中的外键 name 外键名 referencedColumnName 参照的主表的主键名        joinColums ={@JoinColum(name="sys_role_id",referencedColumnName = "role_id")},        //inverseJoinColumns, 对方对象在中间表的外键        inverseJoinColumns = {@JoinColumn(name = "sys_user_id", referencedColumnName = "user_id")}    )    private Set&lt;User&gt; users = new HashSet&lt;&gt;();    *多对多放弃维护权, 被动的一方放弃维护权    角色被用户选择, 所以角色放弃维护权    Role.java    //声明关系    @MangToMany(mappedBy = "roles")     private Set&lt;User&gt; users = new HashSet&lt;&gt;();    *级联操作    只操作User对象,因此在User上配置    User.java    //声明关系    @MangToMany(targetEntity = Role.class, cascade=CascadeType.ALL) //多对多 targetEntity: 代表对方的实体类字节码</code></pre><ol start="3"><li><p>多表查询</p><ol><li><p>对象导航查询<br> 查询一个对象的同时, 通过此对象查询他的关联对象</p><pre><code> //测试对象导航查询(查询一个对象的同时, 通过此对象查询他的关联对象)</code></pre><p>@Test<br>@Transactional  //解决java代码中 no session问题报错<br>public void testQuery1(){<br> //查询id为1的用户<br> User one = userDao.getOne(11);<br> //对象导航查询, 查询此用户下的所有联系人<br> Set<linkman> linkManSet = one.getLinkManSet();<br> for (LinkMan linkMan : linkManSet) {</linkman></p><pre><code> System.out.println(linkMan);</code></pre><p> }<br>}</p><p>对于对象导航查询, 默认使用的延迟加载的形式查询, 调用getLinkManSet方法并不会立即查询, 而是使用关联对象时才会查询<br>不想用延迟加载则需要修改配置fetch到@OneToMany()注解中<br>//EAGER: 立即加载  LAZY: 延迟加载<br>@OneToMany(fetch = FetchType.EAGER)</p><p>//从联系人对象导航查询所属联系人</p><p>//多查一, 默认立即加载<br>@Test<br>@Transactional  //解决java代码中 no session问题报错<br>public void testQuery2(){<br> //从联系人查询所属用户<br> LinkMan linkMan = linkManDao.findOne(1);<br> User user = linkMan.getUser();<br> System.out.println(user);</p></li></ol></li></ol><pre><code>}    </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringJPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow2</title>
      <link href="/2021/04/23/tensorflow2/"/>
      <url>/2021/04/23/tensorflow2/</url>
      
        <content type="html"><![CDATA[<p>##创建一个Tensor<br>    创建全为0的张量: tf.zeros(维度)<br>        维度: 一维 直接写个数<br>              二维 [行,列]<br>              多维 [n,m,j,k…]<br>    创建全为1的张量: tf.ones(维度)<br>    创建全为指定值的张量: tf.fill(维度,指定值)</p><pre><code>生成正态分布的随机数: 默认均值为0, 标准差为1    tf.random.normal(维度,mean=均值,stddev=标准差)生成截断式正态分布的随机数    tf.random.truncated_normal(维度,mean=均值,stddev=标准差)生成均匀分布随机数    tf.random.uniform(维度,minval=最小值,maxval=最大值)</code></pre><p>##tf2常用函数<br>    强制tensor转换为该数据类型<br>        tf.cast(张量名,dtype=数据类型)<br>    计算张量维度上的元素最小值<br>        tf.reduce_min(张量名)<br>    计算张量维度上的元素最大值<br>        tf.reduce_max(张量名)<br>    计算张量沿着指定维度的平均值<br>        tf.reduce_mean(张量名,axis=操作轴)<br>    计算张量沿着指定维度的和<br>        tf.reduce_sum(张量名,axis=操作轴)<br>        不指定axis则对所有元素操作<br>    将变量标记为”可训练”,被标记的变量会在反向传播中记录梯度信息<br>        tf.Variable(初始值)<br>        w = tf.Variable(tf.random.normal([2,2],mean=0,stddev=1))<br>    四则运算<br>        add  subtract  multiply  divide<br>        只有两个维度相同的张量才能进行四则运算<br>    矩阵乘<br>        tf.matmul(矩阵1,矩阵2)<br>    切分传入张量的第一维度,生成输入特征/标签对,构建数据集(即打标签)<br>        data = tf.data.Dataset.from_tensor_slices((输入特征,标签))<br>    with 结构记录计算过程,gradient求出张量的梯度<br>        with tf.GradientTape() as tape:<br>            若干个计算过程<br>        grad = tape.gradient(函数,对谁求导)<br>    enumerate是python的内建函数, 他可遍历每个元素 组合为: 索引 元素<br>        seq = [‘one’,’two’,’three’]<br>        for i, element in enumerate(seq):<br>            print(i,element)<br>    独热编码: 在分类问题中,常用独热码做标签<br>        tf.one_hot(待转换数据,depth=几分类)<br>    softmax<br>        tf.nn.softmax(x)<br>    赋值操作,更新参数的值并返回. 调用assign_sub前,先用tf.Variable定义变量w为可训练<br>        w.assign_sub(w要自减的内容)<br>    返回张量沿指定维度最大值的索引<br>        tf.argmax(张量名,axis=操作轴)</p><p>##预备知识<br>tf.where(条件语句,真返回A,假返回B)<br>    c=tf.where(tf.greater(a,b),a,b)<br>np.random.RandomState.rand(维度)<br>    返回一个[0,1]之间的随机数<br>np.stack(数组1,数组2)<br>    将两个数组按垂直方向叠加<br>np.mgrid[起始值:结束值:步长,起始值:结束值:步长]<br>x.ravel()<br>    将x变为一维数组, 即把x拉直<br>np.c_[数组1,数组2…]<br>    是返回的间隔数值点配对</p><p>用Tensorflow API: tf.keras搭建网络<br>    六步法<br>    1. import<br>    2. train, test<br>    3. model = tf.keras.models.Sequential<br>    4. model.compile<br>    5. model.fit<br>    6. model.summary</p><p>#描述各层网络<br>model = tf.keras.models.Sequential([网络结构])<br>#卷积层<br>tf.keras.layers.Conv2D(filters=巻积核个数,kernel_size=卷积核尺寸,strides=卷积步长,padding=”alid”or”same”)<br>#拉直层<br>tf.keras.layers.Flatten()<br>#全连接层<br>tf.keras.layers.Dense(神经元个数,activation=”激活函数”,kenel_regularizer=正则化方式)</p><p>#LSTM层<br>tf.keras.LSTM()</p><p>model.compile(optimizer=优化器,loss=损失函数,metrics=[“准确率”])<br>优化器可选: ‘sgd’, ‘adagrad’, ‘adadelta’, ‘adam’<br>loss可选: ‘mse’ / tf.keras.losses.Meanquaredrror(), ‘sparse_categorical_crossentropy’ / tf.keras.losses.SparseategoricalCrossentropy()<br>Metrics可选:<br>    ‘accuracy’: y_和y都是数值, 如y_=[1], y=[1]<br>    ‘categorical_accuracy’: y_和y都是独热码, 如y_=[0,1,0] y=[0.256,0.695,0.048]<br>    ‘sparse_categorical_accuracy’: y_是数值, y是独热码<br>model.fit(训练集的输入特征,训练集的标签,batch_size= ,epochs= ,<br>        validation_data=(测试集的输入特征,测试集的标签),<br>        validation_split=从训练集划分多少比例给测试集,<br>        validation_freq=多少次epoch测试一次)</p><p>模板:<br>import tensorflow as tf<br>from sklearn import datasets<br>import numpy as np</p><p>x_train = datasets.load_iris().data<br>y_train = datasets.load_iris().target</p><p>np.random.seed(116)<br>np.random.shuffle(x_train)<br>np.random.seed(116)<br>np.random.shuffle(y_train)<br>tf.random.set_seed(116)</p><p>model = tf.keras.models.Sequential([<br>    #编写具体模型<br>    tf.keras.layers.Dense(3, activation=’softmax’, kernel_regularizer=tf.keras.regularizers.l2())<br>])</p><p>model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),<br>              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),<br>              metrics=[‘sparse_categorical_accuracy’])</p><p>model.fit(x_train, y_train, batch_size=32, epochs=500, validation_split=0.2, validation_freq=20)</p><p>model.summary()</p><p>##模块化    六步法<br>    1. import<br>    2. train, test   (自制数据集, 数据增强)<br>    3. class Myodel(Model) model = MyModel<br>    4. model.compile<br>    5. model.fit   (断点续训)<br>    6. model.summary  (参数提取, acc/loss可视化)</p><p>#继承了Model类的Irisodel<br>class IrisModel(Model):<br>    def <strong>init</strong>(self):<br>        #构造函数<br>        super(IrisModel, self).<strong>init</strong>()<br>        #定义网络结构块<br>        #d1: 自定义的层名字<br>        self.d1 = Dense(3, activation=’softmax’, kernel_regularizer=tf.keras.regularizers.l2())</p><pre><code>def call(self, x):    #实现前向传播    y = self.d1(x)    return y</code></pre><p>model = IrisModel()</p><p>#保存模型<br>tf.keras.callbacks.Modelheckpoint(<br>filepath=路径文件名,<br>save_weights_only=True/False,<br>save_best_only=True/False)</p><p>#读取模型<br>load_weight(路径文件名)</p><p>#断点续训<br>checkpoint_save_path = “./checkpoint/mnist.ckpt”<br>if os.path.exists(checkpoint_save_path + ‘.index’):<br>    print(‘————-load the model—————–’)<br>    model.load_weights(checkpoint_save_path)</p><p>cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,<br>                                                 save_weights_only=True,<br>                                                 save_best_only=True)</p><p>history = model.fit(x_train, y_train, batch_size=32, epochs=5, validation_data=(x_test, y_test), validation_freq=1,<br>                    callbacks=[cp_callback])</p><p>#预测结果<br>result = model.predict(x_predict)</p><p>#感受野<br>卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小。</p><p>#卷积层<br>tf.keras.layers.Conv2D(filters=卷积核个数,kernel_size=卷积核尺寸#正方形写核长整数或(核高h,核宽w),strides=滑动步长,padding=”same”or”valid”,<br>    activation=”relu”or”sigmoid”or”tanh”or”softmax”,#如有BN此处不写<br>    input_shape=(高,宽,通道数) #输入特征图维度,可省略)</p><p>#标准化: 使数据符合0均值,1为标准差的分布<br>#批标准化: 对一小批数据(batch), 做标准化处理<br>BN层位于卷积层之后, 激活层之前</p><p>池化用于减少特征数据量. 最大值池化可提取图片纹理,均值池化可保留背景特征</p><p>卷积就是特征提取器 CBAPD</p><p> #模板<br> class LeNet5(Model):<br>    def <strong>init</strong>(self):<br>        super(LeNet5, self).<strong>init</strong>()<br>        self.c1 = Conv2D(filters=6, kernel_size=(5, 5),<br>                         activation=’sigmoid’)<br>        self.p1 = MaxPool2D(pool_size=(2, 2), strides=2)</p><pre><code>    self.c2 = Conv2D(filters=16, kernel_size=(5, 5),                     activation='sigmoid')    self.p2 = MaxPool2D(pool_size=(2, 2), strides=2)    self.flatten = Flatten()    self.f1 = Dense(120, activation='sigmoid')    self.f2 = Dense(84, activation='sigmoid')    self.f3 = Dense(10, activation='softmax')def call(self, x):    x = self.c1(x)    x = self.p1(x)    x = self.c2(x)    x = self.p2(x)    x = self.flatten(x)    x = self.f1(x)    x = self.f2(x)    y = self.f3(x)    return y</code></pre><p>model = LeNet5()</p><p>#循环网络<br>连续序列的预测</p><p>循环核：参数时间共享，循环层提取时间信息。<br>前向传播时：记忆体内存储的状态信息ht，在每个时刻都被刷新，<br>            三个参数矩阵wxh whh why自始至终都是固定不变的<br>反向传播时：三个参数矩阵wxh whh why被梯度下降法更新</p><p>yt=softmax（ht<em>why+by）<br>ht=tanh（xt</em>wxh+h（t-1）*whh+bh）</p><p>tf.keras.layers.SimpleRNN(记忆体个数,activation=’激活函数’,return_sequences=是否每个时刻输出ht到下一层)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2021/04/23/redis/"/>
      <url>/2021/04/23/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><pre><code>1. redis    1. 概念    2. 下载安装    3. 命令操作        1. 数据结构    4. 持久化操作    5. 使用java客户端操作redis</code></pre><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><pre><code>1. 概念：redis是一款高性能的NOSQL系列的非关系型数据库关系型数据库：mysql、oracle...    1. 数据之间有关联关系    2. 数据存储在硬盘的文件上非关系型数据库：redis、hbase...    存储key: value    name: 张三    age: 23    1. 数据之间没有关联关系    2. 数据存储在内存中经常查询一些不太经常变化的数据, 操作关系型数据库非常耗时, 缓存思想解决这个问题    1. 从缓存中获取数据        有缓存: 直接返回        没有数据: 从数据库中查询-&gt;放入缓存-&gt;返回数据redis可用作缓存2. 下载安装    1. 官网: https://redis.io    2. 中文网: https://www.redis.net.cn/    3. 解压直接可以使用        redis.windows.conf: 配置文件        redis-cli.exe: redis的客户端        redis-server.exe: redis服务器端3. 命令操作    1. redis的数据结构:        redis存储的是: key, value格式的数据, 其中key都是字符串, value有5种不同的数据结构            value的数据结构                1) 字符串类型: string                2) 哈希类型: hash map格式                3) 列表类型: list linkedlist格式                4) 集合类型: set                5) 有序集合类型: sortedset    2. 字符串类型: string        存储: set key value        获取: get key        删除: del key    3. 哈希类型: hash        存储: hset key field value        获取:             hget key field: 获取指定的field对应的值            hgetall key: 获取所有的field和value        删除: hdel key field    4. 列表类型: list        可以添加一个元素到列表的头部(左边) 或者尾部(右边)        添加:            lpush key value: 将元素加入列表左边            rpush key value: 将元素加入列表右边        获取:            lrange key start end: 范围获取        删除:            lpop key: 删除列表最左边的元素, 并将元素返回            rpop key: 删除列表最右边的元素, 并将元素返回    5. 集合类型: set        不允许重复元素        存储:             sadd key value        获取:             smembers key: 获取set集合中的所有元素        删除:            srem key value: 删除set集合中的某个元素    6. 有序集合类型: sortedset        不允许重复元素, 且元素有序, 赋值时要赋上分数由于从小到大排序        存储:            zadd key score value;        获取:            zrange key start end;        删除:            zrem key value    7. 通用命令        keys * : 查询所有的键        type key: 获取键对应的value的类型        del key: 删除指定的key value4. 持久化操作    1. redis是一个内存数据库,当redis服务器或者电脑重启, 数据会丢失,       我们可以将redis内存中的数据持久化保存到硬盘的文件中    2. redis持久化机制        1. RDB: 默认方式            在一定的间隔时间中, 检测key的变化情况, 然后持久化数据            编辑redis.windows.conf文件可以修改            重启redis服务器并指定配置文件名称        2. AOF: 日志记录的方式, 可以记录每一条命令的操作. 每一次命令操作后持久化数据            编辑redis.windows.conf文件                appendonly no(关闭aof) appendonly yes(开启aof) 5. Java客户端 Jedis    Jedis: 一款java操作redis数据库的工具            jedis操作各种redis中的数据结构        1) 字符串类型            get            set        2) 哈希类型             hset            hget            hgetall        3) 列表类型            lpush/rpush            lpop/rpop        4) 集合类型            sadd        5) 有序集合类型            zadd    使用步骤:            //1. 获取连接        Jedis jedis = new Jedis("localhost",6379);//如果使用空参构造,默认值就是"localhost",6379        //2. 操作            //存储String        jedis.set("username","张三");            //获取        String username = jedis.get("username");            //使用setex()方法存储可以指定过期时间的key value,可以用来存储激活码        jedis.setex("activatecode",20,"hehe"); //将activatecode: hehe键值对存入redis,并且20秒后自动删除该键值对            //存储hash        jedis.hset("user", "name", "lisi");        jedis.hset("user", "age", "23");        jedis.hset("user", "gender", "male");            //获取hash        String name = jedis.hget("user", "name");            //获取hash的所有map中的数据        Map&lt;String,String&gt; user = jedis.hgetAll("user");            //keyset        Set&lt;String&gt; keyset = user.keySet();        for(String key: keySet){            String value = user.get(key);            sout(key+ ":" + value);        }            //存储list        jedis.lpush("mlist","a","b","c"); //从左边存        jedis.rpush("mlist","a","b","c"); //从右边存            //范围获取        List&lt;String&gt; mylist = jedis.lrange("mylist", 0, -1);            //弹出        String element1 = jedis.lpop("mylist"); //c        String element2 = jedis.rpop("mylist"); //c            //存储 set        jedis.sadd("myset","java","php","c++"):            //获取set        Set&lt;String&gt; myset = jediis.smember("myset");            //存储 sortedset        jedis.zadd("mysortedset", 3, "剑心");        jedis.zadd("mysortedset", 5, "李白");        jedis.zadd("mysortedset", 10, "西门");            //获取        Set&lt;String&gt; mysortedset = jedis.zrange("mysortedset", 0, -1);        //3. 关闭连接        jedis.close();    jedis连接池: JedisPool        使用:            //0. 创建一个配置对象            JedisPoolConfig config = new JedisPoolConfig();            config.setMaxTotal(50);            config.setMaxIdle(10);            //1. 创建JedisPool连接池对象            JedisPool jedisPool = new JedisPool(config, "localhost", 6379);            //2. 调用方法 getResource()方法获取jedis连接            Jedis jedis = jedisPool.getResource();            //3. 使用            jedis.set("hehe", "haha");            //4. 关闭 归还到连接池中            jedis.close();    抽取Jedis连接池工具类    加载配置文件,配置连接池的参数    提供获取连接的方法    public class JedisPoolUtils{        private static JedisPool jedisPool;        static{            //读取配置文件            InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");            //创建Properties对象            Properties properties = new Properties();            //关联文件            try{                properties.load(is);            }catch(IOException e){                e.printStackTrace();            }            //获取数据, 设置到JedisPoolConfig中            JedisPoolConfig config = new JedisPoolConfig();            config.setMaxTotal(Integer.parseInt(properties.getProperty("maxTotal")));            config.setMaxIdle(Integer.parseInt(properties.getProperty("maxIdle")));            //初始化JedisPool            jedisPool = new JedisPool(config,properties.get("host"),Integer.parseInt(pro.getProperty("port")));        }        public static Jedis getJedis(){            return jedisPool.getResource();        }    }    jedis.properties    host=127.0.0.1    port=6379    maxTotal=50    maxIdle=10    //通过连接池工具类获取     Jedis jedis = JedisPoolUtils.getJedis();</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>    1. 提供index.html页面,页面中有一个省份 下拉列表    2. 当页面加载完成后 发送ajax请求,夹在所有省份注意: 使用redis缓存一些不经常发生变化的数据      数据库的数据一旦发生改变,则需要更新缓存        数据库的表执行 增删改的相关操作, 需要将redis缓存数据情况再次存入        在service对应的增删改方法中,将redis数据删除</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/04/21/hello-world/"/>
      <url>/2021/04/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>&#39;tk.mybatis.mapper&#39;</title>
      <link href="/2020/11/16/java-kuang-jia/tk-mybatis-mapper/"/>
      <url>/2020/11/16/java-kuang-jia/tk-mybatis-mapper/</url>
      
        <content type="html"><![CDATA[<p>Mybatis 与 Hibernate的一个很大的区别就是Mybatis所有的数据库操作语句都需要自己写，<br>对于简单的单表操作来说是比较烦琐的。因此有人就开发了tk.mybatis插件，通过这个插件，<br>可以省略许多简单的单表数据库操作语句而直接调用相对应的dao方法。</p><a id="more"></a><p>在项目中配置和使用tk.mybatis插件的用法如下：</p><ol><li>在pom.xml文件中引入依赖<br>SSM：<pre><code>&lt;dependency&gt;     &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;     &lt;artifactId&gt;mapper&lt;/artifactId&gt;     &lt;version&gt;3.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;javax.persistence&lt;/groupId&gt;     &lt;artifactId&gt;persistence-api&lt;/artifactId&gt;     &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt;</code></pre></li></ol><p>SpringBoot：<br>        <dependency><br>            <groupid>tk.mybatis</groupid><br>            <artifactid>mapper-spring-boot-starter</artifactid><br>            <version>1.2.4</version><br>        </dependency></p><ol start="2"><li><p>在spring的dao层配置中进行配置，将原本的配置扫描Dao接口包进行如下修改。(SpringBoot框架不需要此步)<br>修改前：</p><bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"> <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"></property> <property name="basePackage" value="xxx.xxx.xxx.dao"></property></bean>修改后：<bean class="tk.mybatis.spring.mapper.MapperScannerConfigurer"> <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"></property> <property name="basePackage" value="xxx.xxx.xxx.dao"></property></bean>    </li><li><p>书写一个基本dao接口（这个类不要放在xxx.xxx.xxx.dao包中），作用是供以后的dao接口继承。<br> 继承了这个基本dao接口的接口就具有大多数单表操作方法供service层调用。<br> import tk.mybatis.mapper.common.Mapper;<br> import tk.mybatis.mapper.common.MySqlMapper;</p><p> public interface BaseMapper<t> extends Mapper<t>,MySqlMapper<t>{<br> }</t></t></t></p></li><li><p>在xxx.xxx.xxx.pojo包中，进行数据库表和类的映射<br>（对于数据库表中不存在的变量要用@Transient注解进行忽略映射，否则会报在数据库表找不到对应字段的错误）</p><p> @Table(name = “admin_users”)<br> public class Admin {</p><pre><code> /**  * 使用了tk.mybatis插件后  * 在xxx.xxx.xxx.pojo包中，进行数据库表和类的映射  * （对于数据库表中不存在的变量要用@Transient注解进行忽略映射，否则会报在数据库表找不到对应字段的错误）  */ @Id private Integer id; @Column(name = "usertoken") private String usertoken; @Column(name = "username") private String username; @Column(name = "password") private String password; ......</code></pre><p> }</p></li><li><p>之后的xxx.xxx.xxx.mapper包中的mapper接口继承了上面的基本接口就可以拥有供service层调用的大多数单表操作方法了</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;github_upload&#39;</title>
      <link href="/2020/11/14/github-upload/"/>
      <url>/2020/11/14/github-upload/</url>
      
        <content type="html"><![CDATA[<p>github上传项目</p><a id="more"></a><ol><li><p>下载git工具<br> <a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p></li><li><p>右击本地文件夹选择Git Bash Here</p></li><li><p>github仓库clone or download里复制的地址<br> git clone  <a href="https://github.com/sqtian-hhu/shiqing.git" target="_blank" rel="noopener">https://github.com/sqtian-hhu/shiqing.git</a></p></li><li><p>本地文件夹中会多出一个与仓库名一样的文件夹<br> 把要上传的代码文件夹复制到该仓库文件夹中</p></li><li><p>进入本地仓库文件夹<br> cd shiqing</p></li><li><p>git add .</p></li><li><p>git commit  -m  “项目描述”</p></li><li><p>git push -u origin 自己当前的分支名<br> git push -u origin master</p></li><li><p>输入github用户名和密码</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;计算机网络复习&#39;</title>
      <link href="/2020/11/12/ji-suan-ji-wang-luo-fu-xi/"/>
      <url>/2020/11/12/ji-suan-ji-wang-luo-fu-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络之基础篇"><a href="#计算机网络之基础篇" class="headerlink" title="计算机网络之基础篇"></a>计算机网络之基础篇</h2><p>一、计算机网络概述<br>二、物理层<br>三、数据链路层<br>四、网络层<br>五、传输层<br>六、应用层</p><a id="more"></a><h3 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h3><p> 1.什么是计算机网络<br>  计算机网络主要由一些通用的、可编程的硬件互连而成，通过这些硬件，可以传送不同类型的数据，并且可以支持广泛和日益增长的应用。</p><p> 2.计算机网络的分类<br>  按照网络的作用范围：广域网（WAN）、城域网（MAN）、局域网（LAN）<br>  按照网络使用者：公用网络、专用网络</p><p> 3.计算机网络的发展历史<br>  互联网的发展历史：<br>    第一阶段：单个网络ARPANET，交换机+电脑<br>    第二阶段：三层结构互联网，主干网+地区网+校园网<br>    第三阶段：多层次ISP(Internet Service Provider，网络服务提供商)互联网，主干ISP+地区ISP+校园/公司/家庭…<br>  中国互联网的发展历史：<br>    1980年开始互联网实验，1989年第一个公立网络建立运行，1994年接入国际互联网。</p><p> 4.网络协议<br>  简称协议，是为了进行网络中的数据交换而建立的规则、标准或约定。<br>  网络协议的三要素<br>    语法：数据与控制信息的结构或格式<br>    语义：需要发出何种控制信息，完成何种动作以及做出何种响应<br>    同步：事件实现顺序的详细说明</p><p> 5.计算机网络的层次结构<br>  层次结构设计的基本原则：<br>    各层之间是相互独立的；<br>    每一层需要有足够的灵活性；<br>    各层之间完全解耦。<br>  OSI七层模型：并没有成为广泛使用的标准模型，标准制定周期过长，设计不合理。<br>    物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层<br>  TCP/IP四层模型：<br>    网络接口层-&gt;网络层-&gt;传输层-&gt;应用层</p><p>  通用五层模型:<br>    应用层：直接为用户的应用进程提供服务（HTTP、FTP等）<br>    传输层：向上一层的进行通信的两个进程之间提供一个可靠的端对端服务，使它们看不见运输层以下的数据通信的细节。（TCP、UDP）<br>    网络层：选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。<br>            网络层将运输层产生的报文或用户数据报封装成分组（IP数据报）或包进行传送。<br>    数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上”透明“的传送以帧为单位的数据。<br>                每一帧包括数据和必要的控制信息。在收到数据时，控制信息使收到端直到哪个帧从哪个比特开始和结束。<br>    物理层：物理层的任务就是透明地传送比特流。（注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面，当做第0 层。）<br>            物理层还要确定连接电缆插头的定义及连接法。</p><p> 6.计算机网络的性能指标<br>  速率：bps=bit/s<br>  时延：发送时延、传播时延、排队时延、处理时延<br>  往返时间RTT：数据报文在端到端通信中的来回一次的时间。</p><h3 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h3><p> 1.物理层的作用：物理层的任务就是透明地传送比特流。在计算机之间通过高低电频来传送0,1这样的电信号。<br>   （注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面，当做第0 层。）<br>    物理层还要确定连接电缆插头的定义及连接法。</p><p> 2.信道的基本概念：信道是往一个方向传输信息的媒体，一条通信电路包含一个发送信道和一个接受信道。<br>  单工通信信道：只能一个方向通信，没有反方向反馈的信道；<br>  半双工通信信道：双方都可以发送和接受信息，但不能同时发送也不能同时接收；<br>  全双工通信信道：双方都可以同时发送和接收。<br> 3.信道的分用-复用技术：大大提升信道的利用率，分为频分复用、时分复用、波分复用、码分复用。</p><h3 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h3><pre><code>数据链路层使用的信道主要有以下两种类型：点对点信道  广播信道</code></pre><p> 1.数据链路层的作用：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上”透明“的传送以帧为单位的数据。<br>    每一帧包括数据和必要的控制信息。<br>    在收到数据时，控制信息使收到端知道哪个帧从哪个比特开始和结束。</p><p> 2.使用点对点信道的数据链路层<br>    链路 ：从一个结点到相邻结点的一段物理线路<br>    数据链路 ：把实现这些协议的硬件和软件加载链路上<br>            现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p><pre><code>封装成帧：“帧”是数据链路层数据的基本单位，就是在一段数据的前后分别添加首部（帧开始符SOH 01）和尾部（帧结束符EOT 04），然后就构成了一个帧。         （数据部分&lt;=长度限制MTU）首部和尾部的一个重要作用就是进行帧定界。          帧定界是分组交换的必然要求          最大传输单元MTU(Maximum Transmission Unit)，数据链路层的数据帧不是无限大的，数据帧长度受MTU限制。透明传输：“透明”是指即使控制字符在帧数据中，但是要当做不存在去处理。          为了达到透明传输（即传输的数据部分不会因为包含SOH和EOT而出错），在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制1B)          透明传输避免消息符号与帧定界符号相混淆差错检测：现实通信链路中比特在传输中会产生差错，传输错误的比特占比称为误码率BER，为了保证可靠性，通常通过循环冗余检验CRC来做差错检测。          差错检测防止无效数据帧浪费后续路由上的传输和处理资源          循环冗余检验码：根据传输或保存的数据而产生固定位数校验码。点对点协议 PPP    PPP协议的组成部分：        一个将 IP 数据报封装到串行链路的方法        链路控制协议 LCP (Link Control Protocol)        网络控制协议 NCP (Network Control Protocol)    PPP 协议的工作状态：        链路静止-建立物理层-链路建立-pc发LCP-NCP分配IP地址-链路打开，网络层建立。（释放时倒过来）</code></pre><p> 3.使用广播信道的数据链路层<br>    广播信道是一种一对多的通信，局域网使用的就是广播信道</p><pre><code>局域网的数据链路层被拆分为了两个子层    逻辑链路控制LLC子层：与传输媒体无关    媒体接入控制MAC子层：和局域网都对LLC子层来说是透明的CSMA/CD 协议    以太网采用CSMA/CD协议的方式来协调总线上各计算机的工作。在使用CSMA/CD协议的时候，一个站不可能同时进行发送和接收，    因此使用CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工）。CSMA/CD是载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection）的缩写：    “多点接入”就是计算机以多点接入（动态媒体接入控制）的方式连接在一根总线上。    ”载波监听“就是”发送前先监听”，即每一个站在发送数据前先要检测一下总线是否有其他站在发送数据，如有则暂时不要发送数据，要等到信道为空闲。    “碰撞检测”就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况。当一个站检测到的信号电压摆动值超过一定的门限值时，              就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。              把总线上的单程端到端传播时延记为τ，A 发送数据后，最迟要经过2τ才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。</code></pre><p> 4.以太网<br>  以太网协议：是一种使用广泛的局域网技术，是一种应用于数据链路层的协议，使用以太网可以完成相邻设备的数据帧传输<br>  MAC地址：每一个设备都拥有唯一的MAC地址，共48位，使用十六进制表示。高位24位：厂家，低位24位由厂家自行指派<br>  MAC帧的格式：常用的以太网MAC帧格式有两种标准 ： DIX Ethernet V2 标准IEEE 的 802.3 标准。V2使用较多。<br>               以太网V2的MAC帧较为简单，有五个字段组成。前两个字段分别为6字长的目标地址和源地址字段。<br>               第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。<br>               后面数据字段46~1500字节，FCS字段4个字节。<br>  扩展的以太网：<br>        在物理层扩展—集线器：<br>            现在，双绞线以太网成为以太网的主流类型，扩展主机和集线器之间的距离的一种简单方法就是使用光纤(通常是一对光纤)和一对光纤调制解调器。<br>            光纤调制解调器的作用，是进行电信号和光信号的转换。<br>        在数据链路层扩展—网桥（自学习算法）：<br>            网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发或过滤。<br>            当网桥收到一个帧时，并不是向所有的接口转发这个帧，而是检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。<br>            最简单的网桥有两个接口，复杂些的网桥可能有更多的接口。两个以太网通过网桥连接起来后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就可以称为一个网段(segment)。<br>        虚拟局域网-交换机：<br>            多接口网桥即交换式集线器常称为以太网交换机。利用以太网交换机可以很方便地实现虚拟局域网，<br>            虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记。</p><h3 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h3><p> 1.网际协议IP<br>    网际协议IP是TCP/IP体系中两个最重要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套是用的四个协议：<br>        地址解析协议ARP：是解决同一个局域网上的主机或路由器的IP地址和硬件MAC地址的映射问题。<br>        逆地址解析协议RARP：是解决同一个局域网上的主机或路由器的硬件地址和IP地址的映射问题。<br>        网际控制报文协议ICMP：提供差错报告和询问报文，以提高IP数据交付成功的机会<br>        网际组管理协议IGMP：：用于探寻、转发本局域网内的组成员关系。</p><p>  2.虚拟互连网络<br>    因为没有一种单一的网络能够适应所有的用户需求，所以网络互连也变得困难，所以需要一些中间设备：<br>    物理层中间设备：中继器、集线器（Hub）<br>        中继器：<br>            用于扩展局域网网段的长度。由于中继器只在两个局域网网段间实现电器信号的恢复和整形，因此它仅用于连接相同的局域端。<br>            优点有：安装简便、使用方便、价格便宜<br>        集线器：<br>            可看作一种特殊的多路中继器，也具有信号放大功能。使用双绞线的以太网多用Hub扩大网络，同时也便于网络维护。<br>            以集线器为中心的网络优点是当网络系统中某条线路或某结点出现故障时，不会影响网上其他结点的正常工作。</p><pre><code>数据链路层中间设备：网桥或交换机    网桥：        网桥要分析帧地址字段，决定是否要把帧转发到另一个网络段上。        确切的说，网桥工作于MAC子层，只要两个网络MAC子层以上的协议相同，都可以用网桥互连。        网桥检查帧的源地址和目的地址，如果目的地址和源地址不在同一个网络段上，就把帧转发到另一个网络段上；        若两个地址在同一个网络段上，则不转发，所以网桥能起到过滤帧的作用。    交换机：        交换机是一个具有简化、低价、高性能和高端口秘籍特点的交换产品，它是按每一个包中的MAC地址相对简单地决策信息转发，        而这种转发决策一般不考虑包中隐藏的更深地其他信息。交换机转发数据的延迟很小，操作接近单个局域网性能，远超过了普通桥接的转发性能。        常见的交换机有存储转发、快速转发和碎片丢弃三种交换模式。网络层中间设备：路由器(router)    路由器：        用于连接多个逻辑上分开的网络。当数据从一个子网传输到另一个子网时，可通过路由器来完成。路由器具有很强的异种网互连能力。        通常把网络层地址信息叫做网络逻辑地址，把数据链路层地址信息叫做物理地址。路由器最主要的功能就是选择路径。        在路由的存储其中维护着一个路径表，记录各个网络的逻辑地址，用于识别其他网络。        路由器的功能还包括过滤、存储转发、流量管理和介质转换等。网络层以上的中间设备：网关(gateway)    网关：        在一个计算机网络中，当连接不同类型而协议差别又较大的网络时，则要选用网关设备。        网关的功能体现在OSI模型的最高层，他将协议进行转换，将数据数据重新分组，以便两个不同类型的网络系统之间进行通信。        一般来说，网关只进行一对一的转换，或者少数几个特定应用协议的转换，所以网关很难实现通用的协议转换。</code></pre><p> 3.IP地址<br>    IP 地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。由因特网名字与号码指派公司ICANN进行分配。<br>    IP地址编制方法的三个阶段：<br>        分类的IP地址<br>        子网的划分<br>        构成超网<br>    每一类地址都由 网络号 net-id和 主机号 host-id组成<br>    主机号中全0表示本地网络地址，全1表示广播地址    </p><pre><code>分类的IP地址    A类        由1字节的网络地址和3字节主机地址组成        网络地址的最高位必须是“0“，可指派的网络数为128-2，减2的原因是0.0.0.0对应“本网络”，另外一个是127.0.0.1是本地软件的回环地址，用于测试自己电脑IP地址是否可用。        地址范围1.0.0.0到126.255.255.255        最大主机数为2563-2=16777214台，减2的原因是全0的主机号字段代表该IP地址是"本主机“，全1表示”所有的“，表示该网络上的所有主机    B类        由2字节的网络地址和2字节主机地址组成        网络地址的最高位必须是“10”，可指派的网络数为 214 -1，因为最高位为10，所以不存在全0全1的情况，但是B类网络地址128.0.0.0是不指派的，可指派最小网络地址是128.1.0.0        地址范围128.0.0.0-191.255.255.255        最大主机数为2562-2=65534台，减2同样是全0全1情况。    C类        由3字节的网络地址和1字节主机地址组成        网络地址的最高位必须是“110”，可指派的网络数为221-1，192.0.0.0不指派，最小可指派网络地址是192.0.1.0        地址范围192.0.0.0-223.255.255.255        最大主机数为256-2=254台，减2同样是全0全1情况。    D类        D类是多播地址，“lll0”开始    E类        E类地址保留为今后使用，“llll0”开头硬件地址是数据链路层和物理层使用的地址IP地址是网络层和以上各层使用的地址，是一种逻辑地址    IP地址放在IP数据报的首部，而硬件地址放在MAC帧的首部。当数据报放入数据链路层的MAC帧中后，整个IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。</code></pre><p> 4.地址解析协议ARP<br>    ARP是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。<br>    每一个主机都设有一个ARP高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>    如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。    </p><p> 5.IP数据报<br>    一个IP数据报由首部（20 字节+可选字段）和数据两部分组成<br>    分成片段分别添加首部1，首部2，首部3… 称为分组<br>    分组转发<br>        (1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。<br>        (2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。<br>        (3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。<br>        (4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。<br>        (5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)<br>        (6) 报告转发分组出错。</p><p> 6.划分子网<br>    划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。<br>    划分子网的方法是从主机号借用若干个位作为子网号。<br>    路由器在收到IP数据报后，按目标网络号和子网号定位目标子网</p><p> 7.构造超网（无分类编址CIDR）<br>    CIDR消除了传统的A、B、C类地址以及划分子网的概念，用网络前缀代替网络号和子网号，后面的部分指明主机。<br>    因此，CIDR使IP地址从三级编址(使用子网掩码)，又回到了两级编址，但这已是无分类的两级编址。<br>    CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，<br>    就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。<br>    地址掩码：是一连串的1和0组成，而1的个数就是网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。<br>    构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。</p><p> 8.网际控制报文协议ICMP<br>    为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>    ICMP报文的种类：<br>        ICMP差错报告报文<br>            终点不可达<br>            源点抑制(Source quench)<br>            时间超过<br>            参数问题<br>            改变路由（重定向）(Redirect)<br>        ICMP询问报文<br>            回送请求和回答报文<br>            时间戳请求和回答报文<br>    具体应用：<br>        PING：使用ICMP回送请求和回答报文，测试两个主机之间的连通性<br>        Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</p><p> 9.路由选择协议<br>    两大类路由选择协议：<br>        内部网关协议IGP：一个自治系统内部使用的路由选择协议。有多种协议，如 RIP 和OSPF 协议。<br>        外部网关协议EGP：一个自治系统的边界，将路由选择信息传递到另一个自治系统中。目前使用的就是BGP</p><pre><code>RIP协议的优缺点：    RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。    RIP 协议最大的优点就是实现简单，开销较小。    RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。    路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。RIP是一种分布式的基于距离向量的路由选择协议，其主要特点：        仅和相邻路由器交换信息。    按固定的时间间隔交换路由信息，例如，每隔30秒。OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点：        使用洪泛法向本自治系统中所有路由器发送信息。    发送的信息是与本路由器相邻的所有路由器的链路状态。    只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。BGP是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议，其主要特点：        自治系统AS之间的路由选择必须考虑有关策略。    BGP只能力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</code></pre><h3 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h3><p> 1.传输层协议概述<br>    传输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）<br>    传输层还要对收到的报文进行差错检测<br>    传输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP<br>    两个主要协议<br>        用户数据报协议 UDP(User Datagram Protocol)<br>            UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。<br>            虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。<br>        传输控制协议 TCP(Transmission Control Protocol)<br>            TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。<br>            这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</p><pre><code>传输层的端口：    TCP/IP的运输层的端口用一个 16 位端口号进行标志    端口号只具备本地意义，即端口号只是为了标志本计算机应用层中的各进程。客户发起通讯请求时，必须先知道对方服务器的IP地址和端口号，传输层的端口号分为下面三大类：熟知端口号，数值一般为 0~1023。    一些常用的数值端口号：    FTP 21    LELNET 23    SMTP 25    DNS 53    TFTP 69    HTTP 80    SNMP 161    SNMP(trap) 162登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。</code></pre><p> 2.用户数据报协议 UDP<br>    UDP 是无连接的，即发送数据之前不需要建立连接。<br>    UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制<br>    UDP 是面向报文的<br>    UDP 没有拥塞控制，很适合多媒体通信的要求。<br>    UDP 支持一对一、一对多、多对一和多对多的交互通信<br>    UDP 的首部开销小，只有 8 个字节</p><p> 3.传输控制协议 TCP<br>    TCP 是面向连接的运输层协议<br>    每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）<br>    TCP 提供可靠交付的服务<br>    TCP 提供全双工通信<br>    面向字节流</p><pre><code>TCP的连接：     TCP连接是一条虚连接(逻辑连接)，并不是真正的物理连接    套接字：套接字=(IP地址：端口号)    IP地址拼接上端口号，例如(192.168.1.1:80)    每一条TCP连接唯一被通信两个端点(两个套接字)所确定：TCP连接::={socket1,socket2} = {(IP1:port1),(IP2:port2)}    TCP连接的端点不是进程，而是套接字    同一个IP地址可以由多个不同的TCP连接，而同一个端口也能出现在多个不同TCP连接中</code></pre><p> 4.可靠传输的工作原理：<br>    理想传输条件：<br>        传输信道不产生差错<br>        不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据<br>    （1）停止等待协议：<br>        停止等待：每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组<br>        出现差错时，A只要超过一段时间没收到确认，就默认发送的分组丢失而重传之前的分组，就是超时重传<br>        注意：<br>         (1)A发送完一个分组后，必须暂时保留已发送分组的副本，只有在收到相应确认后才删除<br>         (2)分组和确认都需要编号，才能明确哪个分组收到确认，哪个没收到<br>         (3)超时计时器的重传时间应比数据在分组传输的平均往返时间更长一些<br>        确认丢失：B返回的确认丢失时，A没有收到确认，超时重传，B丢弃重复的分组，再返回一次确认信息<br>        确认迟到：A超时重传了确认信息还没有收到，A重传，B收到后重新返回确认，A收到确认后传下一个，收到迟到的确认什么也不做</p><pre><code>（2）连续ARQ协议：    发送方维持发送窗口，位于发送窗口内的分组都可以连续发送出去，而不需要等待对方确认，这样信道利用率就提高了。    收到一个确认后发送窗口向前滑动。    ARQ规定，发送方每收到一个确认，就把发送窗口滑动一个分组位置，接收方采用累积确认方式，在收到几个分组后，对按序到达的最后一个分组发送确认    优点：容易实现，确认丢失也不必重传    缺点：不能向发送方反映出接收方已经正确收到的所有分组信息    </code></pre><p> 5.TCP报文段的首部格式<br>    (1)源端口和目的端口：各占2字节，分别是源端口号和目的端口号<br>    (2)序号：占4字节，TCP中传输的数据流中的每一字节都有一个编号。序号字段的值是本报文段所发送的数据的第一个字节的序号<br>    (3)确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号<br>    确认号=N，则表明到序号N-1为止所有数据都正确收到<br>    (4)数据偏移：占4位，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远<br>    (5)保留：占6位，保留为今后使用<br>    (6)紧急URG：当URG=1时，表明紧急指针字段有效，告诉系统此报文中有紧急数据，应尽快传送，而不采用原来的按排队顺序来传送<br>    (7)确认ACK：当ACK=1时确认号字段有效，TCP规定，在连接建立后所有数据报文段都把ACK置为1<br>    (8)推送PSH：当收到PSH=1的报文时，就尽快交付接收应用进程，而不再等到整个缓存都填满后再向上交付<br>    (9)复位RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立连接<br>    (10)同步SYN：在连接建立时用来同步序号；当SYN=1而ACK=0时，表明这是一个连接请求报文，对方若同一建立连接，则应在响应报文中使SYN=1，ACK=1<br>    (11)终止FIN：用来释放一个连接，当FIN=1时，表示此报文段的发送方已经发送完毕，并要求释放连接<br>    (12)窗口：占2字节，指的是发送本段报文段的一方的接收窗口，窗口值作为接收方让对方设置其发送窗口的依据；窗口字段明确指出了现在允许对方发送的数据量，窗口值经常动态变化<br>    (13)校验和：占2字节，检验和字段检验的范围包括首部和数据两部分<br>    (14)紧急指针：占2字节，在URG=1时才有意义，指出本报文段中的紧急数据的字节数<br>    (15)选项：长度可变，最长40字节</p><pre><code>最大报文段长度(MSS)：是每一个TCP报文段中的数据字段的最大长度，并不是整个TCP报文段的最大长度，是TCP报文段长度-TCP首部长度</code></pre><p> 6.TCP可靠传输的实现<br>    以字节为单位的滑动窗口：<br>        发送窗口表示：在没有收到B的确认时，A可以连续把窗口内的数据都发送出去<br>        发送窗口中的序号表示允许发送的序号，窗口越大，发送方就可以在收到对方确认前连续发送更多的数据，因此可能获得更高的传输效率<br>        收到新的确认后发送窗口前沿向前移动，没有收到新的确认或收到新的确认但对方通知的窗口缩小了，会使发送窗口前沿不动<br>        发送缓存存放：<br>            发送应用程序发送给发送方TCP准备发送的数据<br>            TCP已发送出但尚未收到确认的数据<br>        接收方缓存存放：<br>            按序到达的、但尚未被接受应用程序读取的数据<br>            未按序到达的数据</p><p> 7.TCP的流量控制<br>    （1）利用滑动窗口实现流量控制：<br>            流量控制：让发送方发送速率不要太快，让接收方来得及接收<br>            滑动窗口的单位：字节<br>            持续计时器：解决盲等死锁。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若计时器到期，就发送一个零窗口探测报文段，<br>                        而对方就在确认这个报文段时给出了现在的窗口值，若窗口值仍是零，那么收到报文的一方就重新设置持续计时器，若不是零，那么死锁就被打破<br>    （2）TCP的传输效率:<br>            Nagle算法：若发送应用进程要把发送的数据逐个字节地送到TCP发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。<br>                       当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文发送出去，同时继续对后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段<br>            糊涂窗口综合征：接收缓存每次只能释放出1字节空间，然后把窗口设为1，向发送方发送确认，发送方又发来1字节数据，接收方发回确认，仍将窗口设为1字节，这样会使网络效率降低<br>            解决方法：让接收方等待一段时间，使得接收缓存有足够空间容纳一个最大的报文段，或等接收缓存中有一半空闲空间。此时再发送确认报文</p><p> 8.TCP的拥塞控制<br>    拥塞：某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种现象称为拥塞<br>    TCP的拥塞控制方法：<br>        慢开始和拥塞避免：<br>            拥塞窗口：大小取决于网络的拥塞程度，并且动态的变化，发送方让自己的发送窗口等于拥塞窗口<br>            判断拥塞的依据：出现了超时<br>            发送方控制拥塞窗口的原则：只要没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多分组发送出去，提高网络利用率；<br>                                      只要发生拥塞，就把拥塞窗口减小一些，以减少注入到网络种的分组数，以缓解网络出现的拥塞<br>            拥塞的判断：重传定时器超时、收到三个相同的ACK<br>            慢开始算法：由小到大成倍增大拥塞窗口数值<br>             拥塞避免算法：让拥塞窗口缓慢的增大，每经过一个RTT就把发送方的拥塞窗口+1，而不是像慢开始加倍增长<br>            当拥塞窗口cwnd&lt;ssthresh时，使用慢开始算法<br>            当cwnd&gt;ssthresh时，停止使用慢开始而改用拥塞避免算法<br>        快重传算法：<br>            要求接收方不等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认<br>            发送方只要一连收到3个重复确认，就立即进行重传(即快重传)<br>        快恢复算法：<br>             发送方只是丢失个别报文，不启动慢开始而用快恢复算法，发送方调整门限值ssthresh=cwnd/2，同时设置拥塞窗口cwnd=ssthresh，并开始执行拥塞避免算法<br>             发送方窗口的上限值：发送方的发送窗口一定不能超过对方给出的接收方窗口值rwnd；上限值应取接收方窗口和拥塞窗口这两个变量中较小的一个，即发送方窗口的上限值= min(rwnd,cwnd)</p><p> 9.TCP的运输连接管理<br>     运输连接的三个阶段：连接建立、数据传送、连接释放<br>     客户-服务器方式：TCP连接建立采用客户服务器方式，主动发起连接建立的应用叫客户，而被动等待连接建立的应用进程叫服务器<br>     （1）TCP的连接建立：<br>        三次握手：<br>            最初两端TCP进程都处于关闭状态，开始时B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求，然后进入收听状态；</p><pre><code>        A的TCP客户进程也先创建TCB，然后打算建立TCP连接时，向B发送连接请求报文，这是首部中同步位SYN=1，同时选择一个初始序号seq=x，        TCP规定，SYN报文段不能携带数据，但要消耗一个序号，这时TCP客户进程进入同步已发送状态；        B收到连接请求报文后，若同意建立连接，则向A发送确认。在确认报文中将SYN位和ACK位都置1，确认号时ACK=x+1，        同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但同样消耗一个序号，这时TCP服务器进程进入同步收到状态        TCP客户进程收到B的确认后，还要向B给出确认。确认报文的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP规定，ACK报文段可以携带数据，        但如果不携带数据则不消耗序号，这种情况，下一个数据报文段序号仍是seq=x+1。这时TCP连接已经建立，A进入已建立连接状态        B收到A的确认后，也进入已建立连接状态 （2）TCP连接的释放：    四次挥手        起始时A和B都处于已建立连接状态        A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的终止控制位FIN置1，序号seq=u，它等于前面已传送过的数据的最后一个字节的序号+1。        这时A进入终止等待状态。FIN报文段即使不携带数据，也消耗一个序号        B收到连接释放报文后发出确认，确认号是ack=u+1，而这个报文自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号+1。        然后B进入关闭等待状态，TCP服务器进程通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受        A收到来自B的确认后，进入终止等待2状态，等待B发送的连接释放报文段        若B已经没有要向A发送的数据，应用进程就通知TCP释放连接，此时B发出的连接释放报文段FIN=1，假定现在B的序号为w，B还必须重复上次已发送过的确认号ack=u+1，此时B进入最后确认状态，等待A的确认        A在收到B的链接释放报文后，必须对此发出确认，在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号时seq=u+1，然后进入时间等待状态。        此时TCP连接还没有释放，必须经过时间等待计时器设置的时间2MSL后，A才进入关闭状态。        A等待2MSL(报文最大生存时间)时间的原因：            保证A发送的最后一个ACK报文段能够到达B               防止已失效的连接请求报文段出现在本连接中</code></pre><h3 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h3><p> 1.域名系统DNS<br>    概述：<br>        域名系统DNS：是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址<br>        许多应用层软件经常使用域名系统DNS，但计算机的用户只是间接而不是直接使用DNS<br>        互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS<br>        DNS使大多数名字都在本地进行解析，仅少量解析需要互联网上通信</p><pre><code>    域名的解析过程：当需要把主机名解析成IP地址时，应用进程调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，    以UDP用户数据报方式发给本地域名服务器，本地域名服务器查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的主机的IP地址后即可进行通信互联网的域名结构：    互联网采用了层次树状结构的命名方法    任何一个连接在互联网上的主机或路由器都有一个唯一的层次结构名字，即域名    域是名字空间中一个可被管理的划分，域还可以划分为子域，而子域还可继续划分    域名的组成：由标号序列组成，各标号之间用点隔开    标号的规定：域名中的标号由英文字母和数字组成，每一个标号不超过63个字符，也不区分大小写；级别低的域名写在左边，级别高的写在右边；由多个标号组成的完整域名总共不超过255个字符    域名是逻辑概念，并不代表计算机所在的物理地点    顶级域名的分类：        国家顶级域名：如cn、us        通用顶级域名：如com、net、org、edu        基础结构域名：只有arpa，用于反向域名解析，又称为反向域名    二级域名：        类别域名：ac、com、edu、gov        行政区域名：bj、js域名服务器：    目的：为每一级的域名都设置一个对应的域名服务器，数量太多，效率低下。因此DNS采用划分区的办法    区：一个服务器所负责的范围    权限域名服务器：每一个区都设有，用来保存区中所有主机的域名到IP地址的映射    分类：        根域名服务器：是层次最高的域名服务器，也是最重要的。所有根域名服务器都知道所有顶级域名服务器的域名和IP地址。                      任何本地域名服务器只要自己无法解析，就首先求助于根域名服务器        顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答          权限域名服务器：负责一个区的域名服务器。当权限域名服务器还不能给出回答时，就会告诉发出查询请求的DNS客户，下一步应找哪一个权限域名服务器                    本地域名服务器：并不属于域名服务器层次结构，但很重要。当主机发出DNS查询请求时，这个查询请求报文发给本地域名服务器    提高域名服务器可靠性：        DNS域名服务器把数据复制到几个域名服务器来保存，其中一个是主域名服务器，其余是辅助域名服务器。当主域名服务器出现故障时，辅助域名服务器就可以保证DNS的查询工作不会中断    域名的解析过程：        主机向本地域名服务器查询，采用递归查询：如果本地域名服务器不知道查询域名的IP，则本地域名服务器以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让主机自己进行下一步查询。                                                因此，递归查询返回的查询结构是查询的IP地址或报错，即无法查询到IP        本地域名服务器向根域名服务器查询，采用迭代查询：当根域名服务器收到本地域名服务器发出的查询请求报文时，要么给出要查询的IP地址，要么告诉本地域名服务器下一步应向哪个域名服务器查询，然后让本地域名服务器进行后续查询。                                                        根域名服务器通常把自己知道的顶级域名服务器的IP告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询</code></pre><p> 2.文件传送协议FTP<br>    文件传输协议FTP时互联网上使用最广泛的文件传送协议，提供交互式访问，允许客户指明文件的类型与格式，并允许文件具有存取权限<br>    要存取一个文件，必须先获得一个本地的文件副本，要修改文件，只能对副本进行修改，然后将修改后的文件副本传回原节点<br>    FTP的特点：只提供文件传送的基本服务，使用TCP可靠性传输服务，FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性<br>    FTP工作流程：FTP使用客户服务器方式，一个FTP服务器进程可同时为多个客户进程提供服务，FTP的服务进程分为两大部分：主进程，负责接受新的请求；若干从属进程，负责处理单个请求<br>    主进程的工作步骤：<br>         (1)打开熟知端口(21)，使客户进程能够连接<br>         (2)等待客户进程发出连接请求<br>         (3)启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建一些子进程<br>         (4)回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的<br>    FTP的两个TCP连接：<br>        控制连接：在整个会话期间一直打开，FTP客户发出的传送请求，通过控制连接发送给服务器端；端口号21<br>        数据连接：用于传输文件；端口号20<br>        由于FTP使用两个不同的端口号，所以数据连接与控制连接不会发生混乱<br>        服务器端控制进程收到FTP客户发来的文件传输请求后，就创建数据传送进程和数据连接，用来连接客户端和服务端的数据传送进程</p><p> 3.简单文件传送协议TFTP<br>    TFTP：是很小且易于实现的文件传送协议，使用客户服务器方式，但使用UDP数据报，因此，TFTP需要有自己的差错改正措施，TFTP只支持文件传输而不支持交互。<br>          TFTP没有庞大的命令集，没有列目录功能，不能对用户进行身份识别<br>    优点：TFTP可用于UDP环境；TFTP代码所占的内存小<br>    TFTP的主要特点：<br>        (1)每次传送的数据报文中有512字节的数据，但最后一次可不足512字节<br>        (2)数据报文按序编号，从1开始<br>        (3)支持ASCII码或二进制传送<br>        (4)可对文件进行读或写<br>        (5)使用很简单的首部<br>    TFTP工作流程：<br>        TFTP客户进程发送一个请求报文给TFTP服务器进程，其熟知端口号为69。TFTP服务器进程选择一个新的端口和TFTP客户进程通信。<br>        若文件长度恰好为512字节整倍数，则文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据报；<br>        若不是整倍数，则最后一个报文一定不足512字节，可作为文件结束的标志</p><p> 4.万维网WWW<br>    万维网是一个大规模联机式的信息储存所，用连接的方法能非常方便的从互联网上的一个站点访问另一个站点，从而主动按需获得信息；是一个分布式的超媒体系统，是超文本系统的扩充<br>    页面：在客户程序(浏览器)主窗口上显示出的万维网文档就是页面<br>    统一资源定位符URL：标志万维网上各种文档，使每个文档在互联网范围具有唯一标识符URL<br>        URL作用：用来表示从互联网上得到的资源位置和访问这些资源的方法<br>        URL的格式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;<br>            协议：指出使用什么协议来获得该文档，常用HTTP或FTP<br>            主机：指出文档在哪台主机上，主机就是指该主机在互联网上的域名<br>            端口和路径：为了进一步定位，有事可省略</p><pre><code>超文本传送协议HTTP：是一个应用层协议，使用TCP进行可靠传送    HTTP作用：定义了浏览器怎么向万维网服务器请求万维网文档，以及服务器怎么把文档传送给浏览器；是面向事物的应用层协议    HTTP的主要特点：        (1)HTTP本身是无连接的：虽然使用TCP连接，但通信双方在交换HTTP报文前不需要建立HTTP连接        (2)HTTP是无状态的：同一个客户第二次访问同一服务器上的页面时，服务器的响应与第一次被访问时相同    请求一个万维网文档所需时间是该文档的传输时间+两倍往返时间RTT    HTTP/1.0的主要缺点：每请求一个文档就要有两倍的RTT的开销；这种非持续连接会使万维网服务器负担很重    HTTP/1.1的改进：使用了持续连接；服务器在发送响应后仍在一段时间内保持连接，使同一个客户能继续在这条连接上传送后续HTTP请求报文和响应报文    HTTP/1.1持续连接的两种工作方式：        非流水线方式：客户在收到响应报文之后才能继续发送        流水线方式：客户收到响应报文之前也可以继续发送</code></pre><p> 5.动态主机配置协议DHCP<br>    主机如何获得IP地址？<br>    动态主机配置协议DHCP是应用层协议，基于UDP。<br>    DHCP作用：提供一种机制，称为即插即用连网，允许一台计算机加入网络和动态获取IP而不用手工参与<br>    协议配置：在协议软件中给参数赋值的动作叫做协议配置<br>    需要配置的项目：IP地址、子网掩码、默认路由器的IP地址、域名服务器的IP地址<br>    DHCP工作方式：<br>        (1)DHCP使用客户服务器方式<br>        (2)需要IP地址的主机在启动时向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户<br>        (3)本地网络上所有主机都能收到该报文，但只有DHCP服务器才回复此报文<br>        (4)DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器IP地址池中取一个地址分配给该计算机<br>        (5)DHCP服务器的回答报文叫提供报文，表示提供了IP地址等配置信息<br>    DHCP中继代理：并不是每个网络上都有DHCP服务器，因为这样会使DHCP服务器数量过多，因此现在是使每个网络至少有一个DHCP中继代理，它配置了DHCP服务器的IP地址信息<br>    DHCP中继代理工作流程：<br>        当DHCP中继代理收到主机A以广播形式发送的发现报文后，就以单播方式向DHCP服务器转发此报文，并等待其回答<br>        收到DHCP服务器回应的提供报文后，DHCP中继代理再把此提供报文发回给主机A<br>    DHCP工作流程：<br>        1：DHCP服务器被动打开UDP端口67，等待客户端发来的报文<br>        2：DHCP客户从UDP端口68发送DHCP发现报文<br>        3：所有收到DHCP发现报文的服务器都会发出DHCP提供报文，因此客户可能收到多个DHCP提供报文<br>        4：客户从几个DHCP服务器中选择一个，并向其发送DHCP请求报文<br>        5：被选中的服务器发送确认报文DHCPACK，此时客户就可以使用这个IP地址了，这种状态叫已绑定状态；<br>           DHCP客户现在要根据服务器提供的租用期T设置两个计时器T1和T2，它们的超时时间分别为0.5T和0.875T，当超时时间到了就要请求更新租用期<br>        6：租用期过半，DHCP发送请求报文，要求更新租用期<br>        7：服务器若同意，则发回确认报文。客户得到了新的租用期，重置计时器<br>        8：服务器若不同意，则发回否认报文。这是客户停止使用原来的IP地址，而重新申请新IP地址(回到步骤2)<br>        9：客户可以随时提前终止服务器所提供的租用期，这时只需向DHCP服务器发送释放报文即可</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;DataType&#39;</title>
      <link href="/2020/10/26/java-ji-chu/datatype/"/>
      <url>/2020/10/26/java-ji-chu/datatype/</url>
      
        <content type="html"><![CDATA[<p>数组,字符串,集合等等总结</p><a id="more"></a><p>import java.util.*;</p><p>public class 基础结构 {</p><pre><code>public static void main(String[] args) {    arrays();    System.out.println();    strings();    System.out.println();    collection();    System.out.println();    map();    System.out.println();    transfer();    System.out.println();}public static void arrays(){    //数组的初始化    /**     * 动态初始化（指定长度）     * 格式：     * 数据类型 [] 数组名称 = new 数据类型[数组长度]     */    int[] array1 = new int[5];    array1[0] = 1;    array1[1] = 2;    array1[2] = 3;    array1[3] = 4;    array1[4] = 5;    /**     * 静态初始化（指定内容）     * 格式：     * 数据类型 [] 数组名称 = new 数据类型[]{元素一，元素二，元素三，….}     */    String[] array2 = new String[]{"a","b","c"};    //省略格式    String[] array3 = {"a","b","c"};    /**     * 访问数组：数组名称[索引值]     * 获取数组长度：arrayA.length     * 数组一旦创建，程序运行期间，长度不可改变     * 想返回多个值时，需要用数组     */    for (int i = 0; i &lt; array1.length; i++) {        array1[i] += 1;        System.out.print(array1[i]+" ");    //2 3 4 5 6    }}public static void strings(){    /**     * 字符串内容永不可变     * 因此，字符串可以共享使用     * 字符串效果上相当于char[]     */    //创建字符串的方法    String str1 = "hello"; //直接创建    char[] charArray = {'A','B','C'};    String str2 = new String(charArray); //根据字符数组内容创建    byte[] byteArray = {97,98,99};    String str3 = new String(byteArray); //根据字节数组    System.out.print("str1:"+str1+" str2:"+str2+" str3:"+str3);     //str1:hello str2:ABC str3:abc    /**     * String中常用方法     * 长度： str.length()     *     * 拼接： str1.concat(str2) //str1不会变化，字符串是常量，返回全新的字符串     * ""+""     *     * 获取指定索引的字符： charAt()     * char ch = str.charAt(1);     *     * 查找参数字符串，第一次出现的索引，没有则返回-1     * int index = original.indexOf(“cc”);     *     * 截取： [ , )     * public String substring(int index); //截取指定位置到最后     * public String substring(int begin,int end);     *     * 转换成字符数组：     * char[] chars = “Hello”.toCharArray(); //变成数组     *     * 转换成字节数组：     * byte[] bytes = “abc”.getBytes()     *     * 替换：     * String lang2 = lang1.replace(charsequence oldstring,charsequence newstring);     *     * 分割：     * String str1 = “aaa,bbb,ccc”;     * String[] a1 = str1.split(“,”);     */    for (int i = 0;i&lt;str1.length();i++){        str2 += str1.charAt(i);    }    String newstring = str2.replace("ll","LL");    System.out.println();    System.out.print(newstring.substring(2,newstring.length()));     //CheLLo}public static void collection(){    /**     * Collection接口     * Collection 常用功能     * public boolean add(E e); 把给定对象添加到当前集合中     * public void clear(); 清空集合中所有元素     * public boolean remove(E e); 把给定对象在当前集合中删除     * public boolean contains(E e); 判断当前集合中是否包含给定对象     * public boolean isEmpty(); 判断当前集合是否为空     * public int size(); 返回集合中元素的个数     * public Object[] toArray(); 把集合中的元素存储到数组中     *     *     * Collection接口     *              -&gt;1. List接口   -&gt; Vecter集合     *                              -&gt; ArrayList集合     *                              -&gt; LinkedList集合     *              -&gt;2. Set接口    -&gt;TreeSet集合     *                              -&gt;HashSet集合     -&gt;LinkedHashSet集合     *     */    /**     * List接口     * 继承了Collection接口     * 特点：     * 1. 有序的集合，存储元素和取出元素的顺序是一致的(存储123，取出123)     * 2. 有索引，包含了一些带索引的方法     * 3. 允许存储重复的元素     * List接口中带索引的方法(特有)     * add(int index,E element): 将指定的元素添加到该集合指定位置上     * get(int index): 返回集合中指定位置的元素     * remove(int index): 移除列表中指定位置的元素，返回的是被移除的元素     * set(int index,E element): 用指定元素替换集合中指定位置的元素，返回更新前的元素     */    /**     * ArrayList集合：底层使用的是数组，因此增删慢，查找快     *     * &lt;&gt;代表泛型 装什么类型，只能放引用类型,不能放基本类型     * 想放基本类型，必须使用“包装类”     * 数组长度不可以改变     * 但ArrayList可以改变     * ArrayList直接打印得到的不是地址值，而是内容     * 增加：list.add();     * 获取：list.get(i);     * 删除：list.remove(i);//返回删除的值     * 尺寸：int size = list.size();     */    List&lt;Double&gt; doubles = new ArrayList&lt;&gt;();    doubles.add(100d);    doubles.add(99.99d);    for (int i = 0; i &lt; doubles.size(); i++) {        System.out.print(doubles.get(i)+" ");   //100.0 99.99    }    /**     * LinkedList集合：List接口的链表实现，查询慢，增删快     * 包含大量首尾元素方法     * 使用特有方法时，不能使用多态     * addFirst(E e): 将指定元素插入此列表开头     * addLast(E e): 将指定元素添加到此列表结尾     * push(E e): 将元素推入此列表表示的堆栈     * pop(): 从堆栈弹出一个元素     * getFirst(): 返回列表第一个元素     * getLast():返回此列表最后一个元素     * removeFirst(): 移除并返回此列表第一个元素     * removeLast(): 一处并返回此列表最后一个元素     * isEmpty(): 从此列表所表示的堆栈处弹出一个元素     */    System.out.println();    System.out.print("LinkedList");    LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();    for (int i = 0; i&lt;4;i++){        linkedList.addFirst(i*i);        linkedList.addLast(i);    }    for (Integer integer : linkedList) {        System.out.print(integer);       //LinkedList94100123    }    /**     * Set接口:     * 继承了Collection接口     * 不允许存储重复的元素     * 没有带索引的方法，也不能使用普通的for循环遍历,要使用迭代器Iterator遍历或者增强for循环     */    /**     * HashSet是一个无序的集合，存储元素与取出元素有可能不一致     * 底层是一个哈希表结构(散列表,查询速度非常快)     * 哈希表：采用数组+链表+红黑树实现，当链表长度超过阈值(8)时，将链表转换为红黑树，大大减少查找时间     * 存储数据到集合中，先计算元素的哈希值     * 数组结构把元素进行了分组，(相同哈希值的元素是一组)链表/红黑树结构把相同哈希值的元素连接到了一起     */    System.out.println();    System.out.print("HashSet:");    HashSet hashSet = new HashSet&lt;&gt;();    for (int i = 0;i&lt;5;i++){        hashSet.add(i);    }    hashSet.add("h");    hashSet.add("a");    hashSet.add("s");    hashSet.add("h");    //Set集合遍历第一种方式:使用迭代器遍历    Iterator it = hashSet.iterator();    while (it.hasNext()){        System.out.print(it.next()+ " ");   //HashSet:0 1 a 2 3 s 4 h   无序    }    /**     * LinkedHashSet集合: 继承了HashSet     * 底层是一个哈希表+链表，多了一条链表记录元素的存储顺序，保证元素有序     * 有序的，也不允许重复元素     */    //不加泛型时默认什么都能存    LinkedHashSet linkedHashSet = new LinkedHashSet();    for (int i = 0;i&lt;5;i++){        linkedHashSet.add(i);    }    linkedHashSet.add("h");    linkedHashSet.add("a");    linkedHashSet.add("s");    linkedHashSet.add("h");    System.out.println();    System.out.print("LinkedHashSet:");    //Set集合的第二种遍历方式: 使用增强for循环遍历    for (Object o:linkedHashSet){        System.out.print(o +" ");  //0 1 2 3 4 h a s   顺序与输入时一致    }}public static void map(){    /**     * Map集合     * Map&lt;K,V&gt;     * 将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射一个值     *     * 1. Map集合是一个双列集合，一个元素包含两个值(一个是key,一个是value)     * 2. Map集合中的元素,key和value的数据类型可以相同,也可以不同     * 3. Map集合中的元素,key不允许重复,value是可以重复的     * 4. Map集合中的元素,key和value是一一对应的     *     * 常用方法     * put(K key,V value): 把指定的键与指定的值添加到Map集合中     *                      返回值：V     *                      存储键值对时，key不重复，返回值V是null。key重复，会使用新的value替换map中重复的value，返回被替换的value值     * remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除,返回被删除元素的值     *     * get(Object key): 根据指定的键,在Map集合中获取对应的值     *                  返回值:     *                  key存在,返回对应值,key不存在则返回null     *     *     */    /**     * HashMap&lt;K,V&gt;集合: Map接口的常用实现类     * HashMap集合底层是哈希表;查询速度特别快.     * HashMap集合是一个无序的集合,存储元素和取出元素的顺序可能不一致     *     */    Map&lt;String,Integer&gt; hashMap = new HashMap&lt;&gt;();    hashMap.put("武力",36);    hashMap.put("智力",91);    hashMap.put("统率",87);    hashMap.put("政治",93);    hashMap.put("魅力",99);    //遍历方式一:hashMap.keySet() 把Map集合中所有的key取出来存储在Set集合中    //          -&gt; 使用迭代器/增强for遍历set集合获取每一个key -&gt; get(key)获取键值    Set&lt;String&gt; ability = hashMap.keySet();    System.out.println();    System.out.print("hashMap第一种遍历: ");    for (String key : ability) {        System.out.print(key+":"+hashMap.get(key)+" ");  //hashMap第一种遍历: 政治:93 魅力:99 统率:87 武力:36 智力:91    无序的    }    hashMap.remove("魅力");    hashMap.put("武力",60);    //遍历方式二:Entry键值对对象：Map.Entry&lt;K,V&gt;    //在Map接口中有一个内部接口Entry    //作用：当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象,键与值的映射关系)    //entrySet(): 把Map集合内部的多个entry对象取出来存储到一个Set集合中 -&gt; 遍历Set集合中的每一个Entry对象    //Entry对象中的两个方法:getKey()获取所有key,getValue()获取所有value    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = hashMap.entrySet();    System.out.println();    System.out.print("hashMap第二种遍历: ");    for (Map.Entry&lt;String, Integer&gt; entry : entries) {        System.out.print(entry.getKey()+":"+entry.getValue()+" ");  //hashMap第二种遍历: 政治:93 统率:87 武力:60 智力:91   无序的    }    /**     * LinkedHashMap&lt;K,V&gt;     * extends HashMap&lt;K,V&gt;     * 有序的,存储abc,打印abc     */    LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;();    linked.put("a","A");    linked.put("c","C");    linked.put("b","B");    System.out.println();    System.out.println(linked);   //{a=A, c=C, b=B},key不允许重复,    有序的    /**     * HashTable&lt;K,V&gt;     * HashMap:底层是一个哈希表,是一个线程不安全的集合,多线程,速度快     * Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢     *     * HashMap集合(之前学的所有集合):可以存储null值,null键     * Hashtable集合,不能存储null值,null键     *     * Hashtable和vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了     * Hashtable的子类Properties依然活跃在历史舞台     * Properties集合是一个唯一和IO流相结合的集合     */    Hashtable properties = new Properties();    properties.put("用户名","letter");    properties.put("密码","letter");    System.out.println();    System.out.println(properties);  //{用户名=letter, 密码=letter}}public static void transfer(){    //数组变字符串 连带数组的[]和,全转了    String[] strings = {"h","e","l","l","o"};    String str = Arrays.toString(strings); //就长这样的字符串 [h, e, l, l, o]    System.out.println("数组转换成字符串,strings:"+strings+" str:"+str);    //数组转换成字符串,strings:[Ljava.lang.String;@4554617c str:[h, e, l, l, o]    //想变成hello  str不会改变而是再创,因此消耗内存,用StringBuilder    String str2 = "";    for (String string : strings) {        str2 += string;    }    System.out.println("直接String拼接:"+str2);     //直接String拼接:hello    /**     * String类是常量，创建之后不可改变。进行字符串相加，内存中就会有多个字符串，占用空间多，效率低下     * StingBuilder类 字符串缓冲区，可以提高字符串的操作效率底层是一个数组，但没有被final修饰，可以改变长度     * StringBuilder在内存中始终是一个数组，占用空间少，效率高。初始长度16，如果超出容量，会自动扩容     *     * 拼接: .append()     * 获取： .charAt()     * 转为字符串: .toString()     */    StringBuilder str3 = new StringBuilder();    for (String string : strings) {        str3.append(string);    }    System.out.println("StringBuilder实现:" + str3);  //StringBuilder实现:hello    //字符串变数组    char[] strings2 = str3.toString().toCharArray();    for (char c : strings2) {        System.out.print(c+"-");           // h-e-l-l-o-    }    System.out.println();    //集合变数组    List&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add("a");    list.add("b");    list.add("c");    Object[] listToArray = list.toArray();    System.out.print("集合变数组:");    for (Object o : listToArray) {        System.out.print(o);                //集合变数组:abc    }}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_SpringMVC_Day03&#39;</title>
      <link href="/2020/07/08/java-kuang-jia/javanote-ssm/"/>
      <url>/2020/07/08/java-kuang-jia/javanote-ssm/</url>
      
        <content type="html"><![CDATA[<h2 id="Day3-SSM三大框架整合"><a href="#Day3-SSM三大框架整合" class="headerlink" title="Day3 SSM三大框架整合"></a>Day3 SSM三大框架整合</h2><p>第一步：搭建整合环境<br>SSM整合可以使用多种方式，我们选用XML+注解的方式</p><p>整合思路：<br>    1. 搭建环境<br>    2. 搭建Spring配置<br>    3. 使用Spring整合SpringMVC框架<br>    4. 使用Spring整合MyBatis框架</p><a id="more"></a><p>服务器开发，分成3层</p><p>表现层<br>    SpringMVC框架</p><p>业务层<br>    Spring框架</p><p>持久层<br>    MyBatis框架</p><p>一定是用Spring去整合另外两个框架</p><hr><pre><code>1.导入依赖坐标&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;!-- 版本锁定  锁定版本后，一改全改非常高效--&gt;    &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;    &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;    &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;    &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;    &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--Spring--&gt;    &lt;!--AOP相关jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.7&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--context容器--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--SpringMVC需要的jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--事务相关jar包--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--jdbc--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;</code></pre><!--servlet--><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;        &lt;version&gt;2.5&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;        &lt;version&gt;2.0&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><!--连接数据库--><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;${mysql.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><!--写页面表达式需要用--><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;jstl&lt;/groupId&gt;        &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;</code></pre><!--日志打印--><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;${log4j.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;        &lt;version&gt;${slf4j.version}&lt;/version&gt;    &lt;/dependency&gt;</code></pre><!--mybatis框架jar包--><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;${mybatis.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;version&gt;1.3.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><!--c3p0连接池--><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;c3p0&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.1.2&lt;/version&gt;        &lt;type&gt;jar&lt;/type&gt;        &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><hr><pre><code>2. 创建封装类</code></pre><p>public class Account implements Serializable {</p><pre><code>private Integer id;private String name;private Double money;@Overridepublic String toString() {    return "Account{" +            "id=" + id +            ", name='" + name + '\'' +            ", money=" + money +            '}';}public Integer getId() {    return id;}public void setId(Integer id) {    this.id = id;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public Double getMoney() {    return money;}public void setMoney(Double money) {    this.money = money;}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><pre><code>3. 创建dao接口应用mybatis框架，只需要写接口，框架会帮我们生成代理对象去执行，不需要自己写实现类</code></pre><p>/**</p><ul><li><p>@author sqtian</p></li><li><p>@create 2020-07-13-10:09</p></li><li><p>/<br>public interface IAccountDao {</p><p>  //查询所有<br>  public List<account> findAll();</account></p></li></ul><pre><code>//保存账户信息public void saveAccount(Account account);</code></pre><p>}</p><hr><pre><code>4. 创建Service接口与实现类</code></pre><p>public interface IAccountService {</p><pre><code>//查询所有public List&lt;Account&gt; findAll();//保存账户信息public void saveAccount(Account account);</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>public class AccountServiceImpl implements IAccountService {<br>    @Override<br>    public List<account> findAll() {<br>        System.out.println(“业务层: 查询所有”);<br>        return null;<br>    }</account></p><pre><code>@Overridepublic void saveAccount(Account account) {    System.out.println("业务层: 保存账户");}</code></pre><p>}</p><hr><pre><code>5. 创建controller类</code></pre><p>/**<br> *</p><ul><li>账户web层</li><li>@author sqtian</li><li>@create 2020-07-13-10:17</li><li>/<br>public class AccountController {</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>环境和骨架搭建完成</p><p>要用spring去整合其他框架<br>第二步：搭建spring环境<br><!--?xml version="1.0" encoding="UTF-8"?--><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemalocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p><pre><code>&lt;!--开启扫描,希望处理service和dao. controller不需要spring框架去处理--&gt;&lt;context:component-scan base-package="com.sqtian"&gt;    &lt;!--配置哪些注解不扫描--&gt;    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt;</code></pre><hr><p>通过测设方法检查配置<br>package com.sqtian.test;</p><p>import com.sqtian.service.IAccountService;<br>import org.junit.Test;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p><p>/**</p><ul><li>@author sqtian</li><li>@create 2020-07-13-11:15</li><li>/</li></ul><p>public class TestSpring {</p><pre><code>@Testpublic void run1() {    //加载配置文件    ApplicationContext ac = new ClassPathXmlApplicationContext("spring.xml");    //获取对象    IAccountService accountService = (IAccountService) ac.getBean("accountService");    //调用方法    accountService.findAll();}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><p>在resources里添加log4j.properties让日志正常打印<br>log4j.rootLogger=INFO,CONSOLE</p><p>log4j.addivity.org.apache=true</p><h1 id="console"><a href="#console" class="headerlink" title="console"></a>console</h1><p>log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender</p><p>log4j.appender.CONSOLE.Threshold=INFO</p><p>log4j.appender.CONSOLE.Target=System.out</p><p>log4j.appender.CONSOLE.Encoding=UTF-8</p><p>log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout</p><p>log4j.appender.CONSOLE.layout.ConversionPattern=[demo] %-5p %d{yyyy-MM-dd HH:mm:ss} - %C.%M(%L)[%t] - %m%n</p><h1 id="all"><a href="#all" class="headerlink" title="all"></a>all</h1><p>log4j.logger.com.demo=INFO, DEMO</p><p>log4j.appender.DEMO=org.apache.log4j.RollingFileAppender</p><p>log4j.appender.DEMO.File=${catalina.base}/logs/demo.log</p><p>log4j.appender.DEMO.MaxFileSize=50MB</p><p>log4j.appender.DEMO.MaxBackupIndex=3</p><p>log4j.appender.DEMO.Encoding=UTF-8</p><p>log4j.appender.DEMO.layout=org.apache.log4j.PatternLayout</p><p>log4j.appender.DEMO.layout.ConversionPattern=[demo] %-5p %d{yyyy-MM-dd HH:mm:ss} - %C.%M(%L)[%t] - %m%n</p><hr><p>第三步：编写SpringMVC框架</p><pre><code>在web.xml中配置前端控制器</code></pre><!--?xml version="1.0" encoding="UTF-8"?--><web-app>    <display-name>Archetype Created Web Application</display-name><pre><code>&lt;!--配置前端控制器--&gt;&lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!--加载springmvc.xml配置文件--&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--启动服务器就创建该servlet--&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--解决中文乱码的过滤器--&gt;&lt;filter&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre></web-app><hr><p>pringmvc.xml</p><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd"></beans></p><pre><code>&lt;!--开启注解扫描,只扫描controller注解--&gt;&lt;context:component-scan base-package="com.sqtian"&gt;    &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt;&lt;!--配置视图解析器对象--&gt;&lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;    &lt;property name="prefix" value="/WEB-INF/pages/"/&gt;    &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt;&lt;!--过滤静态资源--&gt;&lt;mvc:resources mapping="/js/**" location="/js/"/&gt;&lt;mvc:resources mapping="/images/**" location="/images/"/&gt;&lt;mvc:resources mapping="/css/**" location="/css/"/&gt;&lt;!--开启SpringMVC注解的支持--&gt;&lt;mvc:annotation-driven/&gt;</code></pre>--------------------------------------------------------------------------------------------------------------------<p>测试springmvc搭建环境</p><p>index.jsp</p><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>Title</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><pre><code>&lt;a href="account/findAll"&gt;测试&lt;/a&gt;</code></pre><hr><p>AccountController</p><p>/**</p><ul><li>账户web层</li><li></li><li>@author sqtian</li><li>@create 2020-07-13-10:47</li><li>/</li></ul><p>@Controller<br>@RequestMapping(“/account”)<br>public class AccountController {</p><pre><code>@RequestMapping("/findAll")public String findAll(){    System.out.println("表现层:查询所有账户");    return "list";}</code></pre><p>}</p><hr><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>list</title><pre><code>&lt;h3&gt;查询所有账户&lt;/h3&gt;</code></pre><hr><p>springmvc的环境搭建完成</p><p>第四步: Spring整合SpringMVC</p><pre><code>启动tomcat服务器的时候,需要加载spring的配置文件servletContext域对象服务器启动的时候创建ServletContext对象服务器关闭才销毁有一类监听器,监听ServletContext域对象的创建和销毁. 执行一次,服务器启动执行监听器去加载Spring的配置文件创建WEB版本的工厂,存储ServletContext对象1. 在web.xml中配置监听器&lt;!--配置Spring的监听器,默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--设置配置文件的路径--&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;&lt;/context-param&gt;</code></pre><hr><pre><code>2. 表现层调用业务层</code></pre><p>@Controller<br>@RequestMapping(“/account”)<br>public class AccountController {</p><pre><code>@Autowiredprivate IAccountService accountService;@RequestMapping("/findAll")public String findAll(){    System.out.println("表现层:查询所有账户");    //调用service方法    accountService.findAll();    return "list";}</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><h2 id="整合成功"><a href="#整合成功" class="headerlink" title="整合成功"></a>整合成功</h2><p>第五步: 编写mybatis框架</p><pre><code>1. dao中添加注解</code></pre><p>public interface IAccountDao {</p><pre><code>//查询所有@Select("select * from account")public List&lt;Account&gt; findAll();//保存账户信息@Insert("insert into account (name,money) values (#{name},#{money})")public void saveAccount(Account account);</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title="}"></a>}</h2><pre><code>2. 添加mybatis核心配置文件 SqlMapConfig.xml</code></pre><!--?xml version="1.0" encoding="UTF-8"?--><!--mybatis的主配置文件--><configuration>    <!--配置环境-->    <environments default="mysql">        <!--配置mysql环境-->        <environment id="mysql">            <!--配置事务类型 -->            <transactionmanager type="JDBC"></transactionmanager>            <!--配置数据源(连接池)-->            <datasource type="POOLED">                <!--配置连接数据库的4个基本信息-->                <property name="driver" value="com.mysql.jdbc.Driver">                <property name="url" value="jdbc:mysql://localhost:3306/ssm?characterEncoding=utf8">                <property name="username" value="root">                <property name="password" value="root"><pre><code>        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;!--指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件--&gt;&lt;mappers&gt;    &lt;mapper class="com.sqtian.dao.IAccountDao"/&gt;&lt;/mappers&gt;</code></pre></property></property></property></property></datasource></environment></environments></configuration><hr><p>测试框架环境<br>public class testMybatis {</p><pre><code>//测试查询方法@Testpublic void run1() throws Exception {    //加载配置文件    InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");    //创建SqlSessionFactory对象    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);    //创建SqlSession对象    SqlSession sqlSession = factory.openSession();    //获取代理对象    IAccountDao dao = sqlSession.getMapper(IAccountDao.class);    //查询所有数据    List&lt;Account&gt; all = dao.findAll();    for (Account account : all) {        System.out.println(account);    }    //关闭资源    sqlSession.close();    in.close();}//测试保存方法@Testpublic void run2() throws Exception {    Account account = new Account();    account.setName("西门吹雪");    account.setMoney(10000d);    //加载配置文件    InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");    //创建SqlSessionFactory对象    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);    //创建SqlSession对象    SqlSession sqlSession = factory.openSession();    //获取代理对象    IAccountDao dao = sqlSession.getMapper(IAccountDao.class);    //保存    dao.saveAccount(account);    //增删改需要自己管理事务    sqlSession.commit();    //关闭资源    sqlSession.close();    in.close();}</code></pre><p>}</p><hr><p>出现中文添加失败的问题,需要改表的编码: ALTER TABLE account CONVERT TO CHARACTER SET utf8;</p><p>mybatis环境搭建完成</p><p>第六步: spring整合mybatis</p><p>把dao的代理对象存到容器中,利用spring IOC注入</p><p>在spring.xml中进行配置</p><!--spring整合Mybatis框架--><pre><code>&lt;!--配置连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm?characterEncoding=utf8"/&gt;    &lt;property name="user" value="root"/&gt;    &lt;property name="password" value="root"/&gt;&lt;/bean&gt;&lt;!--配置SqlSessionFactory工厂--&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!--配置AccountDao接口所在包--&gt;&lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;    &lt;property name="basePackage" value="com.sqtian.dao"/&gt;&lt;/bean&gt;</code></pre><hr><p>有了以上配置,SqlMapConfig就可以删除了</p><p>mybatis整合完成</p><p>IAccountDao添加注解@Repository</p><p>AccountServiceImpl 添加dao注入</p><p>@Service(“accountService”)<br>public class AccountServiceImpl implements IAccountService {</p><pre><code>@Autowiredprivate IAccountDao accountDao;@Overridepublic List&lt;Account&gt; findAll() {    System.out.println("业务层: 查询所有");    return accountDao.findAll();}@Overridepublic void saveAccount(Account account) {    System.out.println("业务层: 保存账户");    accountDao.saveAccount(account);}</code></pre><h2 id="-6"><a href="#-6" class="headerlink" title="}"></a>}</h2><p>存到request域输出到页面</p><p>@Controller<br>@RequestMapping(“/account”)<br>public class AccountController {</p><pre><code>@Autowiredprivate IAccountService accountService;@RequestMapping("/findAll")public String findAll(Model model){    System.out.println("表现层:查询所有账户");    //调用service方法    List&lt;Account&gt; list = accountService.findAll();    //存入model    model.addAttribute("list",list);    return "list";}</code></pre><p>}</p><hr><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” isELIgnored=”false” %&gt;<br>&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core"</a> %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>list</title><pre><code>&lt;h3&gt;查询所有账户&lt;/h3&gt;&lt;c:forEach items="${list}" var="account"&gt;    ${account.name}&lt;/c:forEach&gt;</code></pre><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><hr><p>保存账户<br>增删改需要自己管理事务</p><p>在spring.xml中配置声明式事务管理</p><pre><code>&lt;!--配置spring框架声明式事务管理--&gt;&lt;!--配置事务管理--&gt;&lt;bean id="transactionManger" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManger"&gt;    &lt;tx:attributes&gt;        &lt;tx:method name="find*" read-only="true"/&gt;        &lt;tx:method name="*" read-only="false"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP增强--&gt;&lt;aop:config&gt;    &lt;!--配置切入点表达式--&gt;    &lt;aop:pointcut id="pt1" expression="execution(* com.sqtian.service.impl.*.*(..))"/&gt;    &lt;aop:advisor pointcut-ref="pt1" advice-ref="txAdvice"/&gt;&lt;/aop:config&gt;</code></pre><hr><pre><code>@RequestMapping("/save")public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws Exception {    System.out.println("表现层:保存账户");    accountService.saveAccount(account);    //重定向去查询    response.sendRedirect(request.getContextPath() +"/account/findAll");    return;}</code></pre><p>}</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_SpringMVC_Day02&#39;</title>
      <link href="/2020/07/08/java-kuang-jia/javanote-springmvc-day02/"/>
      <url>/2020/07/08/java-kuang-jia/javanote-springmvc-day02/</url>
      
        <content type="html"><![CDATA[<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><ol><li>搭建环境</li></ol><p>第一章： 响应数据与结果视图</p><ol><li>响应的返回值是String类型<br>发送请求-&gt;查出对象-&gt;model对象将数据存入request域中-&gt;页面显示</li></ol><pre><code>&lt;a href="user/testString"&gt;testString&lt;/a&gt;&lt;br/&gt;@RequestMapping("/testString")public String testString(Model model){    System.out.println("testString方法执行了");    //模拟从数据库中查询出user对象    User user = new User();    user.setUsername("呈呈");    user.setAge(18);    user.setPassword("1201");    //model对象存数据    model.addAttribute("user",user);    return "success";}</code></pre><a id="more"></a><ol start="2"><li><p>响应返回值是void类型<br>什么不写默认会跳转到pages里的testVoid.jsp</p><p> <a href="user/testVoid">testVoid</a><br></p></li></ol><pre><code>//没有返回值的情况//请求转发是一次请求,不用编写项目的名称//重定向是两次请求,需要写项目名称@RequestMapping("/testVoid")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    System.out.println("testVoid方法执行了");</code></pre><p>//        //第一种:手动写转发时系统不会再自动经过视图解析器找到路径,需要自己写路径<br>//        request.getRequestDispatcher(“/WEB-INF/pages/success.jsp”).forward(request,response);</p><p>//        //第二种:如果要重定向,要加上项目名字.<br>//        //重定向是重发了一次请求,是不能直接访问web-inf下的页面的<br>//        response.sendRedirect(request.getContextPath()+”/index.jsp”);</p><pre><code>    //设置中文乱码    response.setCharacterEncoding("UTF-8");    response.setContentType("text/html;charset=UTF-8");    //第三种:直接进行响应,通过流打印    response.getWriter().print("你好");    return;}</code></pre><ol start="3"><li><p>响应返回值是ModelAndView类型</p><p> <a href="user/testModelAndView">testModelAndView</a><br></p></li></ol><pre><code>@RequestMapping("/testModelAndView")public ModelAndView testModelAndView(){    System.out.println("testModelAndView方法执行了");    //创建一个ModelAndView对象    ModelAndView mv = new ModelAndView();    //模拟从数据库中查询出user对象    User user = new User();    user.setUsername("呈呈");    user.setAge(18);    user.setPassword("1021");    //把user对象存储到mv对象中,其底层也会把user对象存入到request对象中    mv.addObject("user",user);    //跳转页面    mv.setViewName("success");    return mv;}</code></pre><ol start="4"><li><p>使用forward和redirect进行页面跳转<br>用得较少</p><p> <a href="user/testForwardOrRedirect">testForwardOrRedirect</a><br></p></li></ol><pre><code>//使用关键字的方式进行转发或者重定向@RequestMapping("/testForwardOrRedirect")public String testForwardOrRedirect(Model model){    System.out.println("testForwardOrRedirect方法执行了");</code></pre><p>//        //请求的转发<br>//        return “forward:/WEB-INF/pages/success.jsp”;</p><pre><code>    //重定向,使用关键字的方式可以不用加项目名称,关键字方法自动做好了    return "redirect:/index.jsp";}</code></pre><ol start="5"><li>响应json数据之过滤静态资源</li></ol><p>ResponseBody响应json数据</p><pre><code>1. 在webapp.js下配置jquery.min.js文件2. 在response.jsp中引用&lt;head&gt;    &lt;title&gt;response&lt;/title&gt;    &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;3. button事件&lt;button id="btn"&gt;发送ajax的请求&lt;/button&gt;</code></pre><hr><pre><code>4. 设置点击事件</code></pre><meta name="generator" content="Hexo 3.9.0">    <title>response</title>    <script src="js/jquery.min.js"></script><pre><code>&lt;script&gt;    //页面加载,绑定单机事件   $(function(){      $("#btn").click(function () {            // alert("hello btn");          //发送ajax请求          $.ajax({             //编写json格式,设置属性和值              url:"user/testAjax",              contentType:"application/json;charset=UTF-8",              data:'{"username":"呈呈","password":"1201","age":18}',              dataType:"json",              type:"post",              success:function (data) {                    //data是服务器端响应的json的数据,进行解析              }          });      });   });&lt;/script&gt;</code></pre><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><hr><pre><code>5. 在sprinfmvc.xml中设置不要拦截静态资源jquery.min.js&lt;!--告诉前端配置器,哪些静态资源不拦截--&gt;&lt;mvc:resources mapping="/js/**" location="/js/"/&gt;&lt;mvc:resources mapping="/images/**" location="/images/"/&gt;&lt;mvc:resources mapping="/css/**" location="/css/"/&gt;6. 编写响应方法testAjax//模拟异步请求响应@RequestMapping("/testAjax")public void testAjax(@RequestBody String body){    System.out.println("testAjax方法执行了");    System.out.println(body);}</code></pre><hr><p>把客户端发来的json数据封装到user对象<br>    7. 添加导入坐标</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;8. 编写方法//模拟异步请求响应@RequestMapping("/testAjax")//前端发送的是json数据,RequestBody注解将json串转成了user//后端返回的是user类型,ResponseBody注解将user转成了json串public @ResponseBody User testAjax(@RequestBody User user){    System.out.println("testAjax方法执行了");    //客户端发送ajax的请求,传的是json字符串,后端把json字符串封装到user对象中    System.out.println(user);    //做响应,模拟查询数据库    user.setUsername("大呈呈");    user.setAge(20);    //响应    return user;}9. 弹出窗口                  success:function (data) {                    //data是服务器端响应的json的数据,进行解析                  alert(data);                  alert(data.username);                  alert(data.password);                  alert(data.age);</code></pre><h2 id="第二章-SpringMVC实现文件上传"><a href="#第二章-SpringMVC实现文件上传" class="headerlink" title="第二章: SpringMVC实现文件上传"></a>第二章: SpringMVC实现文件上传</h2><p>文件上传的必要前提<br>A form表单的enctype取值必须是: multipart/form-data<br>                        enctype: 是表单请求正文的类型</p><p>B method 属性必须是 Post</p><p>C 提供一个文件选择域&lt;input type=”file/&gt;</p><ol><li>传统方式</li></ol><pre><code>&lt;form action="user/fileUpload1" method="post" enctype="multipart/form-data"&gt;    选择文件:&lt;input type="file" name="upload"/&gt;&lt;br/&gt;    &lt;input type="submit" value="上传"&gt;&lt;/form&gt;</code></pre><hr><ol start="2"><li><p>添加导入坐标</p><pre><code> &lt;dependency&gt;     &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;     &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;     &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;commons-io&lt;/groupId&gt;     &lt;artifactId&gt;commons-io&lt;/artifactId&gt;     &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt;</code></pre></li><li><p>保存</p></li></ol><p>提交表单所有内容都会被封装到request里</p><pre><code>/** * 文件上传 */@RequestMapping("/fileUpload1")public String fileUpload(HttpServletRequest request) throws Exception {    System.out.println("传统方式文件上传");    //使用fileupload组件完成文件上传    //上传的位置    String path = request.getSession().getServletContext().getRealPath("/uploads/");    //判断该路径是否存在    File file = new File(path);    if (!file.exists()){        //创建文件夹        file.mkdirs();    }    //解析request对象,获取上传文件项    DiskFileItemFactory factory = new DiskFileItemFactory();    ServletFileUpload upload = new ServletFileUpload(factory);    //解析request    List&lt;FileItem&gt; items = upload.parseRequest(request);    //遍历    for (FileItem item : items) {        //进行判断,当前item对象是否是上传文件项        if (item.isFormField()){            //说明是普通表单项        }else {            //说明是上传文件项            //获取上传文件的名称            String fileName = item.getName(); //得到的是全路径C:\Users\HASEE\Desktop\2.jpg,保存有问题            //切分字符串,以\切分            String[] strings = fileName.split("\\\\");            fileName = strings[strings.length-1];            //把文件名称设置为唯一值,uuid            String uuid = UUID.randomUUID().toString().replace("-", "");            fileName = uuid+"_"+fileName;            //完成文件上传            item.write(new File(path,fileName));            //删除临时文件            item.delete();        }    }    return "success";}</code></pre><hr><p>最终保存在D:\Tomcat\apache-tomcat-8.5.54\webapps\com_sqtian_SpringMVCDay02_02fileUpload_war\uploads</p><p>============================================================================================================</p><h2 id="SpringMVC上传文件方式"><a href="#SpringMVC上传文件方式" class="headerlink" title="SpringMVC上传文件方式"></a>SpringMVC上传文件方式</h2><p>原理:<br>上传文件–&gt;request–&gt;前端控制器–&gt;配置文件解析器 解析request–&gt;返回上传文件对象给前端控制器–&gt;把上传文件项传给controller方法</p><p>上传方法中的参数名字必须和表单中的一样</p><p>配置文件解析器对象的id必须是multipartResolver</p><ol><li><p>添加表单</p> <h3>SpringMVC文件上传</h3> <form action="user/fileUpload2" method="post" enctype="multipart/form-data">     选择文件:<input type="file" name="upload"><br>     <input type="submit" value="上传"> </form></li><li><p>在springMVC.xml里配置文件解析器</p> <!--配置文件解析器--> <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">     <!--设置上传文件大小-->     <property name="maxUploadSize" value="10485760"> </property></bean></li><li><p>编写方法<br>/**</p><ul><li><p>SpringMVC文件上传</p></li><li><p>/</p><p>@RequestMapping(“/fileUpload2”)<br>//MultipartFile 的名字必须和表单中upload一样<br>public String SpringMVCFileUpload(HttpServletRequest request, MultipartFile upload) throws Exception {<br>  System.out.println(“springMVC方式文件上传”);</p><p>  //使用fileupload组件完成文件上传<br>  //上传的位置<br>  String path = request.getSession().getServletContext().getRealPath(“/uploads/“);<br>  //判断该路径是否存在<br>  File file = new File(path);<br>  if (!file.exists()){</p><pre><code>  //创建文件夹  file.mkdirs();</code></pre><p>  }</p></li></ul></li></ol><pre><code>    //获取上传文件的名称    String filename = upload.getOriginalFilename();//得到的是全路径C:\Users\HASEE\Desktop\2.jpg,保存有问题    //把文件名称设置为唯一值,uuid    String uuid = UUID.randomUUID().toString().replace("-", "");    filename = uuid+"_"+filename;    //完成文件上传    upload.transferTo(new File(path,filename));    return "success";}</code></pre><hr><h2 id="springmvc跨服务器方式的文件上传"><a href="#springmvc跨服务器方式的文件上传" class="headerlink" title="springmvc跨服务器方式的文件上传"></a>springmvc跨服务器方式的文件上传</h2><p>有一个应用服务器springmvc, 一个文件上传服务器fileuploadserver<br>用户发送了上传文件请求给springmvc服务器,应该把他存到fileupload服务器里</p><ol><li><p>新建一个module,部署在fileupload服务器里</p></li><li><p>第三种上传表单</p> <h3>跨服务器文件上传</h3> <form action="user/fileUpload3" method="post" enctype="multipart/form-data">     选择文件:<input type="file" name="upload"><br>     <input type="submit" value="上传"> </form></li><li><p>添加新的坐标</p><pre><code> &lt;dependency&gt;     &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;     &lt;artifactId&gt;jersey-core&lt;/artifactId&gt;     &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt;     &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;     &lt;version&gt;1.18.1&lt;/version&gt; &lt;/dependency&gt;</code></pre></li><li><p>编写方法</p></li></ol><pre><code>/** * SpringMVC文件上传 */@RequestMapping("/fileUpload3")//MultipartFile 的名字必须和表单中upload一样public String fileUpload3(MultipartFile upload) throws Exception {    System.out.println("跨服务器文件上传");    //定义上传文件服务器路径    String path = "http://localhost:8080/com_sqtian_SpringMVC_fileuploadserver_war/uploads/";    //获取上传文件的名称    String filename = upload.getOriginalFilename();//得到的是全路径C:\Users\HASEE\Desktop\2.jpg,保存有问题    //把文件名称设置为唯一值,uuid    String uuid = UUID.randomUUID().toString().replace("-", "");    filename = uuid+"_"+filename;    //完成文件上传,跨服务器上传    //创建客户端对象    Client client = Client.create();    //和上传服务器进行连接    WebResource webResource = client.resource(path + filename);    //上传文件,要字节数组    webResource.put(upload.getBytes());    return "success";}</code></pre><hr><p>总是报错,发现是tomcat配置文件里拒绝了http的put,要把tomcat/conf/web.xml里的readonly改成false<br>添加代码</p><!-- 使得服务器允许文件写入。--><pre><code>    &lt;init-param&gt;        &lt;param-name&gt;readonly&lt;/param-name&gt;        &lt;param-value&gt;false&lt;/param-value&gt;    &lt;/init-param&gt;</code></pre><hr><p>另外,要在D:\Tomcat\apache-tomcat-8.5.54\webapps\com_sqtian_SpringMVC_fileuploadserver_war下自己建一个uploads文件夹</p><h2 id="第三章-SpringMVC的异常处理"><a href="#第三章-SpringMVC的异常处理" class="headerlink" title="第三章 SpringMVC的异常处理"></a>第三章 SpringMVC的异常处理</h2><ol><li><p>异常处理思路<br>Controller调用service，service调用dao，异常但是向上抛出的，最终由DispatcherServlet找异常处理器进行异常的处理</p></li><li><p>SpringMVC的异常处理</p></li></ol><p>浏览器 –请求–&gt; 前端控制器 –请求–&gt; web –请求–&gt; service –请求–&gt; dao</p><p>dao –抛出异常–&gt; service –抛出异常–&gt; web –抛出异常–&gt; 前端控制器异常处理器组件 –&gt; 异常处理器处理异常 –&gt; 跳转到错误提示页面</p><pre><code>1. 编写自定义异常类(做提示信息的)</code></pre><p>package com.sqtian.exception;</p><p>/**<br> *</p><ul><li><p>自定义的一个异常类</p></li><li><p>@author sqtian</p></li><li><p>@create 2020-07-10-10:50</p></li><li><p>/<br>public class SysException extends Exception {</p><p>  //存储提示信息<br>  private String message;</p><p>  public SysException(String message) {</p><pre><code>  this.message = message;</code></pre><p>  }</p><p>  public String getMessage() {</p><pre><code>  return message;</code></pre><p>  }</p><p>  public void setMessage(String message) {</p><pre><code>  this.message = message;</code></pre><p>  }<br>}</p></li></ul><hr><pre><code>2. 编写异常处理器</code></pre><p>public class SysExceptionResolver implements HandlerExceptionResolver {</p><pre><code>/** * 处理异常业务逻辑 * @param httpServletRequest * @param httpServletResponse * @param o * @param e * @return */@Overridepublic ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {    //获取到异常对象    SysException se = null;    if (e instanceof SysException){        se = (SysException) e;    }else{        se = new SysException("系统正在维护");    }    //创建ModelAndView对象    ModelAndView mv = new ModelAndView();    mv.addObject("errorMsg",e.getMessage());    mv.setViewName("error");    return mv;}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><pre><code>3. 配置一次处理器(跳转到提示页面)在springmvc.xml中配置&lt;!--配置异常处理器,正常bean对象的配置方法--&gt;&lt;bean id="sysExceptionResolver" class="com.sqtian.exception.SysExceptionResolver"&gt;&lt;/bean&gt;</code></pre><hr><pre><code>error.jsp</code></pre><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” isELIgnored=”false” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>error</title><pre><code>${errorMsg}</code></pre>    <hr><pre><code>&lt;h3&gt;异常处理&lt;/h3&gt;&lt;a href="user/testException"&gt;异常处理&lt;/a&gt;</code></pre><hr><p>测试异常的方法</p><p>@Controller<br>@RequestMapping(“/user”)<br>public class UserController {</p><pre><code>@RequestMapping("/testException")public String testException() throws SysException {    System.out.println("testException执行了");    try {        //模拟异常        int a = 10/0;    } catch (Exception e) {        //打印异常信息        e.printStackTrace();        //抛出自定义异常信息        throw new SysException("查询所有的用户出现了错误...");    }    return "success";}</code></pre><p>}</p><hr><h2 id="第四章-springMVC拦截器"><a href="#第四章-springMVC拦截器" class="headerlink" title="第四章 springMVC拦截器"></a>第四章 springMVC拦截器</h2><p>spring MVC 的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理<br>用户可以自己定义一些拦截器来实现特定的功能</p><p>过滤器是servlet规范中的一部分，任何java web 工程都可以用<br>拦截器是SpringMVC框架自己的。只有使用了SpringMVC框架的工程才能用</p><p>过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截<br>拦截器只会拦截访问的控制器方法，如果访问的是jsp，html，css，image或js是不会进行拦截的</p><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>interceptor</title><pre><code>&lt;h3&gt;拦截器&lt;/h3&gt;&lt;a href="user/testInterceptor"&gt;拦截器&lt;/a&gt;</code></pre><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script>--------------------------------------------------------------<p>/**</p><ul><li>@author sqtian</li><li>@create 2020-07-10-14:21</li><li>/</li></ul><p>@Controller<br>@RequestMapping(“/user”)<br>public class UserController {</p><pre><code>@RequestMapping("/testInterceptor")public String testInterceptor(){    System.out.println("testInterceptor方法执行了");    return "success";}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><ol><li>编写拦截器类, 实现HandlerInterceptor接口<br>package com.sqtian.interceptor;</li></ol><p>import org.springframework.web.servlet.HandlerInterceptor;<br>import org.springframework.web.servlet.ModelAndView;</p><p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p><p>/**</p><ul><li>自定义拦截器</li><li>@author sqtian</li><li>@create 2020-07-10-14:34</li><li>/</li></ul><p>public class MyInterceptor1 implements HandlerInterceptor {</p><pre><code>/** * 预处理,controller方法执行前 * @param request * @param response * @param handler * @return true 放行,执行下一个拦截器.如果没有下一个,则执行controller中的方法 *          false 不放行 * @throws Exception */@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {    System.out.println("MyInterceptor1执行了----前1111");</code></pre><p>//        return false; 拦截请求,可以手动跳转<br>//        request.getRequestDispatcher(“/WEB-INF/pages/error.jsp”).forward(request,response);<br>        return true;<br>    }</p><pre><code>/** * 后处理方法, controller方法执行后,success.jsp执行之前 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    System.out.println("MyInterceptor1执行了----后1111");}/** * success.jsp页面执行后,该方法会执行 * 释放资源,关闭流 * @param request * @param response * @param handler * @param ex * @throws Exception */@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    System.out.println("MyInterceptor1执行了----最后1111");}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><ol start="2"><li><p>springmvc.xml中配置拦截器</p> <!--配置拦截器--><p> <a href="mvc:interceptors" target="_blank" rel="noopener">mvc:interceptors</a></p><pre><code> &lt;!--配置第一个--&gt; &lt;mvc:interceptor&gt;     &lt;!--         mapping是要拦截的方法         exclude-mapping是不要拦截的方法         --&gt;     &lt;mvc:mapping path="/user/*"/&gt;     &lt;!--配置拦截器对象--&gt;     &lt;bean class="com.sqtian.interceptor.MyInterceptor1"/&gt; &lt;/mvc:interceptor&gt; &lt;!--配置第二个--&gt; &lt;mvc:interceptor&gt;     &lt;!--         mapping是要拦截的方法         exclude-mapping是不要拦截的方法         --&gt;     &lt;mvc:mapping path="/**"/&gt;     &lt;!--配置拦截器对象--&gt;     &lt;bean class="com.sqtian.interceptor.MyInterceptor2"/&gt; &lt;/mvc:interceptor&gt;</code></pre><p> </p></li></ol><hr><p>执行顺序</p><p>MyInterceptor1执行了—-前1111<br>MyInterceptor1执行了—-前2222<br>testInterceptor方法执行了<br>MyInterceptor1执行了—-后2222<br>MyInterceptor1执行了—-后1111<br>success.jsp执行了<br>MyInterceptor1执行了—-最后2222<br>MyInterceptor1执行了—-最后1111</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_SpringMVC_Day01&#39;</title>
      <link href="/2020/07/08/java-kuang-jia/javanote-springmvc-day01/"/>
      <url>/2020/07/08/java-kuang-jia/javanote-springmvc-day01/</url>
      
        <content type="html"><![CDATA[<h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><p>第一章：SpringMVC的基本概念<br>开发架构一般基于两种形式：C/S架构和B/S架构。JavaEE开发中几乎全都是基于B/S架构的开发。<br>B/S架构中，标准的三层架构包括：表现层、业务层、持久层</p><p>服务器端分成三层框架</p><p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚，低耦合”的思想。</p><p>表现层（user interface layer）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。</p><p>业务逻辑层（business logic layer）:针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。</p><p>数据访问层（data access layer）:该层直接操作数据库，针对数据的增添、删除、修改、查找等。</p><a id="more"></a><p>在Java web 项目中：</p><p>dao层：数据访问层,操作数据库，对数据进行增删改查<br>service层：业务逻辑层,对数据进行处理<br>web层：表示层，给页面传递数据</p><p>表现层：<br>SpringMVC框架</p><p>业务层：<br>Spring框架</p><p>持久层：<br>Mybatis框架</p><p>SpringMVC和Struts2的优略分析</p><h2 id="第二章：springMVC的入门"><a href="#第二章：springMVC的入门" class="headerlink" title="第二章：springMVC的入门"></a>第二章：springMVC的入门</h2><p>需求：<br>index.jsp 超链接标签-&gt;发送请求-&gt;编写类,编写方法,转发到成功jsp页面</p><ol><li>搭建开发环境</li></ol><p>选择webapp项目<br>创建时添加键值对<br>archetypeCatalog<br>internal</p><p>导入依赖坐标<br>  <properties><br>    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br>    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;<br>    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;<br>    <!-- 版本锁定  锁定版本后，一改全改非常高效--><br>    &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;<br>  </properties></p>  <dependencies>    <dependency><pre><code>  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;${spring.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;  &lt;version&gt;2.5&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;  &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;  &lt;version&gt;2.0&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre>  </dependency></dependencies><p>在web.xml中配置前端控制器<br><web-app><br>  <display-name>Archetype Created Web Application</display-name></web-app></p>  <servlet>    <servlet-name>dispatcherServlet</servlet-name>    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  </servlet>  <servlet-mapping>    <servlet-name>dispatcherServlet</servlet-name>    <url-pattern>/</url-pattern>  </servlet-mapping><p>在resources中添加配置文件</p><ol start="2"><li><p>编写入门程序</p><ol><li><p>编写index.jsp<br>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0"><title>Title</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><h3>入门程序</h3><p>//超链接标签- 连接到sayhello方法<br><a href="hello">入门程序</a></p></li></ol></li></ol><hr><pre><code>2. 编写hello类</code></pre><p>package com.sqtian.controller;</p><p>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.RequestMapping;</p><p>/**</p><ul><li>控制器的类</li><li>@author sqtian</li><li>@create 2020-07-07-11:10</li><li>/</li></ul><p>@Controller<br>public class HelloController {</p><pre><code>//请求映射,添加请求路径@RequestMapping(path="/hello")public String sayHello(){    System.out.println("Hello StringMVC");    //跳转到success页面,在webapp.pages下    return "success";}</code></pre><p>}    </p><hr><pre><code>3. 在springmvc.xml中配置（相当于之前的bean.xml）</code></pre><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd"></beans></p><pre><code>&lt;!--开启注解扫描--&gt;&lt;context:component-scan base-package="com.sqtian"/&gt;</code></pre>------------------------------------------------------------------------<pre><code>4. 在web.xml中前端控制器里配置加载springmvc.xml配置文件</code></pre>  <servlet>    <servlet-name>dispatcherServlet</servlet-name>    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><pre><code>&lt;init-param&gt;  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code></pre>  </servlet>    ------------------------------------------------------------------------------<pre><code>5. webapp.pages中存放其他页面</code></pre><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>Title</title>    <h3>成功</h3><hr><pre><code>5. 部署到tomcat+artifact -&gt;war</code></pre><p>流程总结:</p><ol><li><p>启动服务器, 加载一些配置文件</p><ul><li>DispatcherServlet对象被创建, 前端控制器</li><li>springmvc.xml被加载</li><li>HelloController创建对象</li></ul></li><li><p>发送请求,后台处理</p></li></ol><p><a href="hello">入门程序</a> –&gt; DispatcherServlet 控制作用,指挥中心 –&gt; sayhello方法,控制台打印Hello StringMVC,返回”success” –&gt;DispatcherServlet</p><p>–&gt; 找到视图解析器 InternalResourceViewResolver –&gt;跳转到success.jsp页面 –&gt; DispatcherServlet –&gt; 结果返回</p><p>@RequestMapping(path=”/hello”)注解的作用<br>用于建立请求URL和处理请求方法之间的对应关系<br>可以加在类上也可以在方法上<br>    属性:<br>        value: 用于指定请求的URL,他和path属性作用是一样的<br>        method: 用于指定请求的方式<br>            method={RequestMethod.POST}: 只能响应post请求方式<br>        params: 用于指定限制请求参数的条件.它支持简单的表达式.要求请求参数的key和value必须和配置一模一样.<br>            params={“username”} 必须要传入username的属性<br>            <a href="user/testRequestMapping?username=hehe">RequestMapping注解</a><br>            params={“username=heihei”} 必须传入username=heihei才能请求<br>        headers:发送的请求当中必须包含请求头<br>            headers={“Accept”} </p><p>加在类上时,要改路径<br>@Controller<br>@RequestMapping(“/user”)<br>public class HelloController {</p><pre><code>//请求映射,添加请求路径@RequestMapping(path="/hello")public String sayHello(){    System.out.println("Hello StringMVC");    return "success";}@RequestMapping("/testRequestMapping")public String teatRequestMapping(){    System.out.println("测试RequestMapping注解");    return "success";}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p><a href="user/hello">入门程序</a></p><p><a href="user/testRequestMapping">RequestMapping注解</a></p><hr><h2 id="第三章：请求参数的绑定"><a href="#第三章：请求参数的绑定" class="headerlink" title="第三章：请求参数的绑定"></a>第三章：请求参数的绑定</h2><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>Title</title>    &lt;%--请求参数绑定--%&gt;<pre><code>&lt;a href="param/testParam?username=hehe&amp;password=123"&gt;请求参数绑定&lt;/a&gt;</code></pre><!--%--请求参数绑定--%--><hr><p>/**</p><ul><li>请求参数绑定</li><li>@author sqtian</li><li>@create 2020-07-08-9:35</li><li>/</li></ul><p>@Controller<br>@RequestMapping(“/param”)<br>public class ParamController {</p><pre><code>@RequestMapping("/testParam")public String testParam(String username,String password){    System.out.println("执行了");    System.out.println("用户名:"+username);    System.out.println("密码:"+password);    return "success";}</code></pre><p>}</p><hr><p>封装到java bean中<br>封装类：<br>public class Account implements Serializable {<br>    private String username;<br>    private String password;<br>    private Double balance;</p><pre><code>private User user;private List&lt;User&gt; list;private Map&lt;String,User&gt; map;getter&amp;settertoString</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>public class User implements Serializable {<br>    private String uname;<br>    private Integer age;</p><pre><code>getter&amp;settertoString</code></pre><p>}</p><hr><p>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><meta name="generator" content="Hexo 3.9.0">    <title>Title</title>    &lt;%--请求参数绑定--%&gt;<pre><code>&lt;a href="param/testParam?username=hehe&amp;password=123"&gt;请求参数绑定&lt;/a&gt;&lt;form action="param/saveAccount" method="post"&gt;    &lt;%--数据的name要和封装类的属性名一样--%&gt;    姓名:&lt;input type="text" name="username" placeholder="请输入用户名"/&gt; &lt;br/&gt;    密码:&lt;input type="text" name="password" placeholder="请输入密码"/&gt; &lt;br/&gt;    金额:&lt;input type="text" name="balance" placeholder="请输入金额"/&gt; &lt;br/&gt;    &lt;%--封装account中的user属性--%&gt;    user姓名:&lt;input type="text" name="user.uname" placeholder="请输入用户姓名"/&gt; &lt;br/&gt;    user年龄:&lt;input type="text" name="user.age" placeholder="请输入用户年龄"/&gt; &lt;br/&gt;    &lt;%--类中存在List和Map集合--%&gt;    list中user姓名:&lt;input type="text" name="list[0].uname" placeholder="请输入用户姓名"/&gt; &lt;br/&gt;    list中user年龄:&lt;input type="text" name="list[0].age" placeholder="请输入用户年龄"/&gt; &lt;br/&gt;    map中user姓名:&lt;input type="text" name="map['one'].uname" placeholder="请输入用户姓名"/&gt; &lt;br/&gt;    map中user年龄:&lt;input type="text" name="map['one'].age" placeholder="请输入用户年龄"/&gt; &lt;br/&gt;    &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;</code></pre><!--%--请求参数绑定--%--><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><hr><p>解决中文乱码问题：在web.xml中配置过滤器</p>  <!--配置解决中文乱码的过滤器-->  <filter>    <filter-name>characterEncodingFilter</filter-name>    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>    <init-param>      <param-name>encoding</param-name>      <param-value>UTF-8</param-value>    </init-param>  </filter>  <filter-mapping>    <filter-name>characterEncodingFilter</filter-name>    <url-pattern>/*</url-pattern>  </filter-mapping><h2 id="自定义类型转换器演示异常"><a href="#自定义类型转换器演示异常" class="headerlink" title="自定义类型转换器演示异常"></a>自定义类型转换器演示异常</h2><p>例：输入日期写yyyy/mm/dd支持，写yyyy-mm-dd时报错<br>需要添加自定义类型转换器</p><pre><code>&lt;%--自定义类型转换器--%&gt;&lt;form action="param/saveUser" method="post"&gt;    用户姓名:&lt;input type="text" name="uname"&gt;&lt;br/&gt;    用户年龄:&lt;input type="text" name="age"&gt;&lt;br/&gt;    用户生日:&lt;input type="text" name="date"&gt;&lt;br/&gt;    &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;</code></pre><hr><pre><code>@RequestMapping("/saveUser")public String saveUser(User user){    System.out.println("执行了");    System.out.println(user);    return "success";}</code></pre><hr><p>在springmvc.xml中配置<br>    <!--配置自定义类型转换器--><br>    <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"><br>        <property name="converters"><br>            <set><br>                <bean class="com.sqtian.utils.StringToDateConverter"></bean><br>            </set><br>        </property></bean></p><pre><code>&lt;/bean&gt;&lt;!--开启springmvc框架注解支持--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;</code></pre><hr><p>public class StringToDateConverter implements Converter&lt;String, Date&gt; {</p><pre><code>/** * * @param s 传入进来的字符串 * @return */@Overridepublic Date convert(String s) {    //判断    if(s == null){        throw new RuntimeException("请您传入数据");    }    DateFormat df = new SimpleDateFormat("yyyy-MM-dd");    //把字符串转换成日期    try {        return df.parse(s);    } catch (Exception e) {        throw new RuntimeException("数据类型转换出现了错误");    }    }</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><h2 id="获取原生的api"><a href="#获取原生的api" class="headerlink" title="获取原生的api"></a>获取原生的api</h2><pre><code>&lt;a href="param/testServlet"&gt;servlet原生的api&lt;/a&gt;//想要获取什么,就传入什么参数@RequestMapping("/testServlet")public String testServlet(HttpServletRequest request, HttpServletResponse response){    System.out.println("执行了");    System.out.println(request);    HttpSession session = request.getSession();    System.out.println(session);    ServletContext servletContext = session.getServletContext();    System.out.println(servletContext);    System.out.println(response);    return "success";}</code></pre><h2 id="第四章：常用注解"><a href="#第四章：常用注解" class="headerlink" title="第四章：常用注解"></a>第四章：常用注解</h2><ol><li>RequestParam<br> 作用：把请求中指定名称的参数给控制器中的形参赋值<br> 属性：<pre><code> value：请求参数中的名称 required：请求参数中是否必须提供此参数，默认值true</code></pre></li></ol><p><a href="anno/testRequestParam?name=哈哈">RequestParam</a><br>请求中的参数是name，方法中的形参是username，可以通过(@RequestParam(name = “name”)赋值</p><p>@Controller<br>@RequestMapping(“/anno”)<br>public class AnnoController {</p><pre><code>@RequestMapping("/testRequestParam")public String testRequestParam(@RequestParam(name = "name") String username){    System.out.println("执行了");    System.out.println(username);    return "success";}</code></pre><p>}</p><ol start="2"><li>RequestBody<br> 作用：用于获取请求体内容。直接使用得到是key=value&amp;key=value。。。结构的数据<br> get请求方式不适用<br> 属性：    <pre><code> required：是否必须有请求体 默认true。true时get请求方式会报错，false时，get请求得到的是null</code></pre></li></ol><pre><code>&lt;form action="anno/testRequestBody" method="post"&gt;    用户姓名:&lt;input type="text" name="username"/&gt;&lt;br/&gt;    用户年龄:&lt;input type="text" name="age"/&gt;&lt;br/&gt;    &lt;input type="submit" value="提交"&gt;&lt;br/&gt;&lt;/form&gt;</code></pre><hr><pre><code>@RequestMapping("/testRequestBody")public String testRequestBody(@RequestBody String body){    System.out.println("执行了");    System.out.println(body);    return "success";}</code></pre><hr><ol start="3"><li><p>PathVaribale<br> 作用：用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是url占位符</p><p> 属性：    </p><pre><code> value：用于指定url中占位符名称 required：是否必须提供占位符</code></pre><p> <a href="anno/testPathVariable/10">PathVariable</a></p><p> @RequestMapping(“/testPathVariable/{sid}”)<br> public String testPathVariable(@PathVariable(name = “sid”) String id) {</p><pre><code> System.out.println("执行了"); System.out.println(id); return "success";</code></pre><p> }</p></li></ol><hr><p>restful编程风格<br>    原来方式<br>    UserController类</p><pre><code>path="/user/save"savepath="/user/update"updatepath="/user/findAll"findAllrestful方式UserController类path="/user"  postsavepath="/user"  putupdatepath="/user"  getfindAllpath="/user/{id}"   getfindById(id)</code></pre><hr><ol start="4"><li>RequestHeader<br>用的较少<br> 作用: 用于获取请求消息头<br> 属性:<pre><code> value: 提供消息头名称 required: 是否必须有此消息头</code></pre></li></ol><pre><code>&lt;a href="anno/testRequestHeader"&gt;RequestHeader&lt;/a&gt;</code></pre><hr><pre><code>@RequestMapping("/testRequestHeader")public String testRequestHeader(@RequestHeader(value = "Accept") String header) {    System.out.println("执行了");    System.out.println(header);    return "success";}    </code></pre><hr><ol start="5"><li>CookieValue注解<br> 作用: 把指定cookie名称的值传入控制器方法参数<br> 属性: <pre><code> value: 指定cookie的名称 required: 是否必须有此cookie</code></pre>用的较少<br> <a href="anno/testCookieValue">CookieValue</a></li></ol><hr><pre><code>@RequestMapping("/testCookieValue")public String testCookieValue(@CookieValue(value = "JSESSIONID") String cookieValue) {    System.out.println("执行了");    System.out.println(cookieValue);    return "success";}</code></pre><hr><ol start="6"><li><p>ModelAttribute<br> 作用: 出现在方法上,表示当前方法会在控制器的方法执行前先执行</p><pre><code>   出现在参数上,获取指定的数据给参数赋值</code></pre><p> 属性:</p><pre><code> value: 用于获取数据的key. key可以是POJO的属性名称,也可以是map结构的key</code></pre><p> 应用场景:</p><pre><code> 当表单提交数据不是完整的实体类数据时,保证没有提交数据的字段使用数据库对象原来的数据</code></pre> <form action="anno/testModelAttribute" method="post">     用户姓名:<input type="text" name="uname"><br>     用户年龄:<input type="text" name="age"><br><pre><code> &lt;input type="submit" value="提交"&gt;&lt;br/&gt;</code></pre> </form></li></ol><hr><pre><code>有返回值,放在方法上时@RequestMapping("/testModelAttribute")public String testModelAttribute(User user) {    System.out.println("testModelAttribute执行了");    System.out.println(user);    return "success";}//放方法上优先执行,showUser打印在testModelAttribute前//有返回值@ModelAttributepublic User showUser(String uname){    System.out.println("showUser执行了");    //先通过uname查到数据库中的数据    User user = new User();    user.setUname(uname);    user.setAge(20);    user.setDate(new Date());    return user;}</code></pre><hr><pre><code>没有返回值时@RequestMapping("/testModelAttribute")public String testModelAttribute(@ModelAttribute("abc") User user) {    System.out.println("testModelAttribute执行了");    System.out.println(user);    return "success";}//没有返回值@ModelAttributepublic void showUser(String uname, Map&lt;String,User&gt; map){    System.out.println("showUser执行了");    //先通过uname查到数据库中的数据    User user = new User();    user.setUname(uname);    user.setAge(20);    user.setDate(new Date());    map.put("abc",user);}</code></pre><hr><ol start="7"><li>SessionAttributes<br> 作用: 用于多次执行控制器方法间的参数共享<br> 属性:<pre><code> value: 用于指定存入的属性名称 type: 用于指定存入的数据类型</code></pre></li></ol><hr><pre><code>&lt;a href="anno/testSessionAttributes"&gt;SessionAttributes&lt;/a&gt;&lt;br/&gt;&lt;a href="anno/getSessionAttributes"&gt;getSessionAttributes&lt;/a&gt;&lt;br/&gt;&lt;a href="anno/delSessionAttributes"&gt;delSessionAttributes&lt;/a&gt;&lt;br/&gt;</code></pre><hr><pre><code>@RequestMapping("/testSessionAttributes")public String testSessionAttributes(Model model) {    System.out.println("执行了");    //底层会存储到request域对象中    model.addAttribute("msg","妹妹");    return "success";}//从session域中取值@RequestMapping("/getSessionAttributes")public String getSessionAttributes(ModelMap modelMap) {    System.out.println("执行了");    String msg = (String) modelMap.get("msg");    System.out.println(msg);    return "success";}//清除session域中的数据@RequestMapping("/delSessionAttributes")public String delSessionAttributes(SessionStatus status) {    System.out.println("执行了");    status.setComplete();    return "success";}</code></pre><hr><pre><code>只能作用在类上</code></pre><p>@Controller<br>@RequestMapping(“/anno”)<br>@SessionAttributes(value=”msg”) //把msg=妹妹存入到session域对中<br>public class AnnoController {<br>…<br>}</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaNote_Spring_Day04</title>
      <link href="/2020/06/29/java-kuang-jia/javanote-spring-day04/"/>
      <url>/2020/06/29/java-kuang-jia/javanote-spring-day04/</url>
      
        <content type="html"><![CDATA[<h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p>spring中的JDBCTemlate以及Spring事务控制</p><ol><li>spring中的JdbcTemplate<pre><code> JdbcTemplate的作用：     他就是用于和数据库交互的，实现对表的CRUD操作 如何创建该对象： 对象中的常用方法</code></pre></li></ol><a id="more"></a>    <p>导入依赖坐标<br><!--?xml version="1.0" encoding="UTF-8"?--><br><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelversion>4.0.0</modelversion></project></p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;com.sqtian.springDay04_JdbcTemplate&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.6&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre>--------------------------------------------------------------------------------<p>package com.sqtian.jdbctemplate;</p><p>import org.springframework.jdbc.core.JdbcTemplate;<br>import org.springframework.jdbc.datasource.DriverManagerDataSource;</p><p>/**</p><ul><li><p>JdbcTemplate的最基本用法</p></li><li><p>/<br>public class JdbcTemplateDemo1 {<br>  public static void main(String[] args) {</p><pre><code>  //准备数据源,spring的内置数据源  DriverManagerDataSource ds = new DriverManagerDataSource();  ds.setDriverClassName("com.mysql.jdbc.Driver");  ds.setUrl("jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8");  ds.setUsername("root");  ds.setPassword("root");  //1. 创建JdbcTemplate对象  JdbcTemplate jdbcTemplate = new JdbcTemplate();  //给jt设置数据源  jdbcTemplate.setDataSource(ds);  //2. 执行操作  jdbcTemplate.execute("insert into account(name,balance,uid)values('陆游',1000,30)");</code></pre></li></ul><pre><code>}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>其中含有new和大量set方法<br>可以通过spring的ioc进行配置</p><pre><code>配置bean.xml</code></pre><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd"></beans></p><pre><code>&lt;!--配置jdbcTemplate--&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;    &lt;property name="url" value="jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8"&gt;&lt;/property&gt;    &lt;property name="username" value="root"&gt;&lt;/property&gt;    &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- more bean definitions go here --&gt;</code></pre><hr><p>package com.sqtian.jdbctemplate;</p><p>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>import org.springframework.jdbc.core.JdbcTemplate;</p><p>/**</p><ul><li><p>JdbcTemplate的最基本用法</p></li><li><p>/<br>public class JdbcTemplateDemo2 {<br>  public static void main(String[] args) {</p><pre><code>  //1. 获取容器  ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");  //2. 获取对象  JdbcTemplate jt = ac.getBean("jdbcTemplate",JdbcTemplate.class);  //3. 执行操作  jt.execute("insert into account(name,balance,uid)values('凌雪',2000,31)");</code></pre><p>  }</p></li></ul><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>增删改查</p><p>package com.sqtian.jdbctemplate;</p><p>import com.sqtian.domain.Account;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>import org.springframework.jdbc.core.BeanPropertyRowMapper;<br>import org.springframework.jdbc.core.JdbcTemplate;<br>import org.springframework.jdbc.core.RowMapper;</p><p>import java.sql.ResultSet;<br>import java.sql.SQLException;<br>import java.util.List;</p><p>/**</p><ul><li>JdbcTemplate的CRUD操作</li><li>/<br>public class JdbcTemplateDemo3 {<br>  public static void main(String[] args) {<pre><code>  //1. 获取容器  ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");  //2. 获取对象  JdbcTemplate jt = ac.getBean("jdbcTemplate",JdbcTemplate.class);  //3. 执行操作</code></pre>//        //保存<br>//        jt.update(“insert into account(name,balance,uid)values(?,?,?)”,”屈心”,10000,32);<br>//        //更新<br>//        jt.update(“update account set name = ?,balance = ?, uid = ? where id = ?”,”楚留香”,100000,5,4);<br>//        //删除<br>//        jt.update(“delete from account where id = ?”,5);</li></ul><pre><code>    //查询所有    //需要一个参数RowMapper(),定义封装策略</code></pre><p>//        List<account> accounts=jt.query(“select * from account where balance &gt; ?”,new AccountRowMapper(),5000);<br>        //使用spring中提供的实现类<br>        List<account> accounts=jt.query(“select * from account where balance &gt; ?”,new BeanPropertyRowMapper<account>(Account.class),5000);</account></account></account></p><pre><code>    for (Account account : accounts) {        System.out.println(account);    }    //查询一个    List&lt;Account&gt; acc=jt.query("select * from account where id = ?",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),2);    System.out.println(acc.isEmpty()?"没有内容":acc.get(0));    //查询返回一行一列(使用聚合函数,但不增加group by 子句)    Long count = jt.queryForObject("select count(*) from account where balance &gt; ? ",Long.class,5000);    System.out.println(count);}</code></pre><p>}</p><p>/**<br> *</p><ul><li><p>定义Account的封装策略</p></li><li></li><li><p>/<br>class AccountRowMapper implements RowMapper<account>{<br>  /**</account></p><ul><li><p>把结果集中的数据封装到Account中,然后由spring把每个Account加到集合中</p></li><li><p>@param resultSet</p></li><li><p>@param i</p></li><li><p>@return</p></li><li><p>@throws SQLException</p></li><li><p>/</p><p>@Override<br>public Account mapRow(ResultSet resultSet, int i) throws SQLException {<br>  Account account = new Account();<br>  account.setId(resultSet.getInt(“id”));<br>  account.setName(resultSet.getString(“name”));<br>  account.setBalance(resultSet.getDouble(“balance”));<br>  account.setUid(resultSet.getInt(“uid”));<br>  return account;<br>}<br>}</p></li></ul></li></ul><hr><p>DAO实现</p><p>package com.sqtian.dao.impl;</p><p>import com.sqtian.dao.IAccountDao;<br>import com.sqtian.domain.Account;<br>import org.springframework.jdbc.core.BeanPropertyRowMapper;<br>import org.springframework.jdbc.core.JdbcTemplate;</p><p>import java.util.List;</p><p>public class AccountDaoImpl implements IAccountDao {<br>    private JdbcTemplate jdbcTemplate;</p><pre><code>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {    this.jdbcTemplate = jdbcTemplate;}@Overridepublic Account findAccountById(Integer accountId) {    List&lt;Account&gt; accounts = jdbcTemplate.query("select * from Account where id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId);    return accounts.isEmpty() ? null:accounts.get(0);}@Overridepublic Account findAccountByName(String accountName) {    //写法不同,因为名字可能相同    List&lt;Account&gt; accounts = jdbcTemplate.query("select * from Account where name = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountName);    if (accounts.isEmpty()){        return null;    }else if(accounts.size()&gt;1){        throw new RuntimeException("结果集不唯一");    }else {        return accounts.get(0);    }}@Overridepublic void updateAccount(Account account) {    jdbcTemplate.update("update account set name=?,balance=?,uid=? where id=?",account.getName(),account.getBalance(),account.getUid(),account.getId());}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>package com.sqtian.jdbctemplate;</p><p>import com.sqtian.dao.IAccountDao;<br>import com.sqtian.domain.Account;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p><p>/**</p><ul><li><p>JdbcTemplate的最基本用法</p></li><li><p>/<br>public class JdbcTemplateDemo4 {<br>  public static void main(String[] args) {</p><pre><code>  //1. 获取容器  ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");  //2. 获取对象  IAccountDao accountDao = ac.getBean("accountDao", IAccountDao.class);  //3. 执行操作  System.out.println(accountDao.findAccountById(7));  System.out.println(accountDao.findAccountByName("西门吹雪"));  Account account = new Account();  account.setUid(33);  account.setName("南宫问天");  account.setBalance(50000);  account.setId(8);  accountDao.updateAccount(account);</code></pre><p>  }</p></li></ul><p>}</p><hr><pre><code>&lt;!--配置账户的持久层--&gt;&lt;bean id="accountDao" class="com.sqtian.dao.impl.AccountDaoImpl"&gt;    &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><p>如果有多个DAO实现类,则存在许多重复代码<br>比如:<br>    private JdbcTemplate jdbcTemplate;</p><pre><code>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {    this.jdbcTemplate = jdbcTemplate;}</code></pre><p>需要抽取重复代码</p><p>public class JdbcDaoSupport {<br>    private JdbcTemplate jdbcTemplate;</p><pre><code>public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {    this.jdbcTemplate = jdbcTemplate;}public JdbcTemplate getJdbcTemplate() {    return jdbcTemplate;}public void setDataSource(DataSource dataSource){    if(jdbcTemplate == null){        jdbcTemplate = createJdbcTemplate(dataSource); //可以不用注入template了直接注入datasource    }}private JdbcTemplate createJdbcTemplate(DataSource dataSource) {    return new JdbcTemplate(dataSource);}</code></pre><p>}</p><hr><p>实际上,spring中提供了JdbcDaosupport类</p><p>区别,用自己的类可以加注解自动注入, 用提供的类因为是只读的,不能加注解了</p><ol start="2"><li><p>作业：</p><pre><code> 利用spring基于AOP的事务控制对account案例改进</code></pre><ol><li><p>基于xnl的方法</p><p>在bean.xml中添加AOP配置</p><!--配置AOP--><p><a href="aop:config" target="_blank" rel="noopener">aop:config</a></p> <!--配置通用的切入点表达式--><p> &lt;aop:pointcut id=”pt1” expression=”excution(* com.sqtian.service.impl.<em>.</em>(..))”&gt;<br> &lt;aop:aspect id=”txAdvice” ref=”txManager”&gt;</p><pre><code> &lt;!--配置前置通知 开启事务--&gt; &lt;aop:before method="beginTransaction" pointcut-ref="pt1"&gt;&lt;/aop:before&gt; &lt;!--配置后置通知 提交事务--&gt; &lt;aop:after-returning method="afterReturningTransaction" pointcut-ref="pt1"&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知 回滚事务--&gt; &lt;aop:after-throwing method="afterThrowingTransaction" pointcut-ref="pt1"&gt;&lt;/aop:after-throwing&gt; &lt;!--配置最终通知 释放连接--&gt; &lt;aop:after method="release" pointcut-ref="pt1"&gt;&lt;/aop:after&gt;</code></pre><p> <br></p></li></ol></li></ol><pre><code>2. 基于注解的方法    1. 给Service加上注解,删除不必要的set方法,删除bean.xml中对应配置</code></pre><p>@Service(“accountService”)<br>public class AccountServiceImpl implements IAccountService {</p><pre><code>//自动注入就不需要set方法了@Autowiredprivate IAccountDao accountDao;</code></pre><p>……</p><hr><pre><code>    2. 给Dao加上注解,并删除多余配置</code></pre><p>@Repository(“accountDao”)<br>public class AccountDaoImpl implements IAccountDao {</p><pre><code>@Autowiredprivate QueryRunner runner;//不再希望通过queryRunner里取连接,而是通过connectionUtils取//删去原来的注入&lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt;//自己写的类加上注解后可以在bean中删掉配置@Autowiredprivate ConnectionUtils connectionUtils;</code></pre><hr><pre><code>    3. 连接工具类</code></pre><p>@Component(“connectionUtils”)<br>public class ConnectionUtils {<br>    private ThreadLocal<connection> tl = new ThreadLocal<connection>();</connection></connection></p><pre><code>@Autowiredprivate DataSource dataSource;</code></pre><h2 id="…"><a href="#…" class="headerlink" title="…."></a>….</h2><pre><code>    4. 事务管理器</code></pre><p>**</p><ul><li><p>和事务管理相关的工具类,它包含了,开启事务,提交事务,回滚事务和释放连接</p></li><li><p>/<br>@Component(“txManager”)<br>//切面注解<br>@Aspect<br>public class TransactionManager {</p><p>  @Autowired<br>  private ConnectionUtils connectionUtils;</p><p>  //配置切入点<br>  @Pointcut(“excution(* com.sqtian.service.impl.<em>.</em>(..))”)<br>  private void pt1(){}</p></li></ul><pre><code>/** * 开启事务 */@Before("pt1()")public void beginTransaction(){    try {        connectionUtils.getThreadConnection().setAutoCommit(false);    } catch (SQLException e) {        e.printStackTrace();    }}/** * 提交事务 */@AfterReturning("pt1()")public void commit(){    try {        connectionUtils.getThreadConnection().commit();    } catch (SQLException e) {        e.printStackTrace();    }}/** * 回滚事务 */@AfterThrowing("pt1()")public void rollback(){    try {        connectionUtils.getThreadConnection().rollback();    } catch (SQLException e) {        e.printStackTrace();    }}/** * 释放连接 */@After("pt1()")public void release(){    try {        connectionUtils.getThreadConnection().close();//换回连接池中        connectionUtils.removeConnection();    } catch (SQLException e) {        e.printStackTrace();    }}</code></pre><p>}</p><hr><p>然而,aop注解的四种通知运行顺序是存在问题的,以上代码并不能满足需求<br>需要通过环绕通知来实现</p><pre><code>/** * 通过环绕通知注解控制事务 * @param pjp * @return */@Around("pt1")public Object aroundAdvice(ProceedingJoinPoint pjp){    Object retuenValue = null;    try{        //1. 获取参数        Object[] args = pjp.getArgs();        //2. 开启事务        this.beginTransaction();        //3. 执行方法        retuenValue = pjp.proceed();        //4. 提交事务        this.commit();        //返回结果        return retuenValue;    }catch (Throwable t){        //5. 回滚事务        this.rollback();        throw new RuntimeException(t);    }finally {        //6. 释放资源        this.release();    }}    </code></pre><ol start="3"><li>spring中的事务控制<pre><code> 基于xml 基于注解</code></pre></li></ol><hr><p>进入 mysql -u -p;</p><p>show databases;  </p><p>show tables; 显示所有表</p><p>use 库名； 操作数据库</p><p>打开服务 cmd services.msc</p><p>事件查看器 eventvwr</p><p>创建库 create database mydb;</p><p>导入数据 use mydb;</p><pre><code>     source d:/wc.sql;</code></pre><p>修改数据库root密码</p><p>mysql -u root</p><p>　　mysql&gt; use mysql;</p><p>　　mysql&gt; UPDATE user SET Password = PASSWORD(‘newpass’) WHERE user = ‘root’;</p><p>　　mysql&gt; FLUSH PRIVILEGES;</p><p>在丢失root密码的时候，可以这样</p><p>　　mysqld_safe –skip-grant-tables&amp;</p><p>　　mysql -u root mysql</p><p>　　mysql&gt; UPDATE user SET password=PASSWORD(“new password”) WHERE user=’root’;</p><p>　　mysql&gt; FLUSH PRIVILEGES;</p><hr><h2 id="spring基于xml的声明式事务控制"><a href="#spring基于xml的声明式事务控制" class="headerlink" title="spring基于xml的声明式事务控制"></a>spring基于xml的声明式事务控制</h2><ol><li><p>导入依赖坐标</p><!--?xml version="1.0" encoding="UTF-8"?--><p>&lt;project xmlns=”<a href="http://maven.apache.org/POM/4.0.0&quot;" target="_blank" rel="noopener">http://maven.apache.org/POM/4.0.0"</a></p><pre><code>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;</code></pre><p> <modelversion>4.0.0</modelversion></p><p> <groupid>org.example</groupid><br> <artifactid>comsqtian.springDay04.tx</artifactid><br> <version>1.0-SNAPSHOT</version></p> <build>     <plugins>         <plugin>             <groupid>org.apache.maven.plugins</groupid>             <artifactid>maven-compiler-plugin</artifactid>             <configuration>                 <source>6                 <target>6</target>             </configuration>         </plugin>     </plugins> </build> <packaging>jar</packaging> <dependencies>     <dependency>         <groupid>org.springframework</groupid>         <artifactid>spring-context</artifactid>         <version>5.0.2.RELEASE</version>     </dependency><pre><code> &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;     &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;     &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.aspectj&lt;/groupId&gt;     &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;     &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;junit&lt;/groupId&gt;     &lt;artifactId&gt;junit&lt;/artifactId&gt;     &lt;version&gt;4.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-test&lt;/artifactId&gt;     &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre> </dependencies></li></ol><hr><ol start="2"><li>配置bean.xml</li></ol><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p><pre><code>&lt;!--配置账户的持久层--&gt;&lt;bean id="accountDao" class="com.sqtian.dao.impl.AccountDaoImpl"&gt;    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;    &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;    &lt;property name="url" value="jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8"&gt;&lt;/property&gt;    &lt;property name="username" value="root"&gt;&lt;/property&gt;    &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- spring基于xml的声明式事务控制    1. 配置事务管理器    2. 配置事务的通知        导入约束 tx的名称空间和约束,同时也需要aop的约束        使用tx:advice标签配置事务通知            属性:                id: 给事务通知起一个唯一标识                transaction-manager: 给事务通知提供一个事务管理器引用    3. 配置AOP中的通用切入点表达式    4. 建立事务通知的切入点表达式的对应关系    5. 配置事务的属性            是在事务的通知tx:advice标签的内部--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置事务的通知--&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;    &lt;!--配置事务的属性        isolation: 用于指定事务的隔离级别.DEFAULT使用数据库默认级别        propagation: 用于指定事务的传播行为,默认是REQUIRED,表示一定会有事务,增删改的选择.查询可以选择SUPPORTS        read-only: 用于指定事务是否只读.只有查询方法才能设置为true.        timeout: 用于指定事务的超时时间,默认值-1,表示永不超时        rollback-for: 用于指定一个异常,当产生该异常时事务回滚.产生其他异常时事务不回滚.没有值表示任何异常都回滚        no-rollback-for: 用于指定一个异常,当产生该异常时事务不回滚.产生其他异常时事务回滚.没有值表示任何异常都不回滚    --&gt;    &lt;tx:attributes&gt;        &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt;        &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP--&gt;&lt;aop:config&gt;    &lt;!--配置切入点表达式--&gt;    &lt;aop:pointcut id="pt1" expression="execution(* com.sqtian.service.impl.*.*(..))"/&gt;    &lt;aop:advisor pointcut-ref="pt1" advice-ref="txAdvice"/&gt;&lt;/aop:config&gt;</code></pre><hr><h2 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h2><pre><code>1. 配置事务管理器2. 开启spring对注解事务的支持    &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;3. 在需要事务支持的地方使用@Transactional注解    @service("accountService")    @Transactional</code></pre><h2 id="基于纯注解的声明式事务控制"><a href="#基于纯注解的声明式事务控制" class="headerlink" title="基于纯注解的声明式事务控制"></a>基于纯注解的声明式事务控制</h2><ol><li>ServiceImpl</li></ol><p>/**</p><ul><li><p>账户的业务层实现类</p></li><li></li><li><p>事务控制应该都是在业务层</p></li><li><p>/<br>@Service(“accountService”)<br>//支持事务的注解<br>@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)<br>public class AccountServiceImpl implements IAccountService {</p><p>  @Autowired<br>  private IAccountDao accountDao;</p></li></ul><pre><code>public Account findAccountById(Integer accountId) {    return accountDao.findAccountById(accountId);}@Transactional(propagation = Propagation.REQUIRED,readOnly = false)public void transfer(String sourceName, String targetName, Double money) {    //2.1. 根据名称查询转出账户    Account source = accountDao.findAccountByName(sourceName);    //2.2. 根据名称查询转入账户    Account target = accountDao.findAccountByName(targetName);    //2.3. 转出账户减钱    source.setBalance(source.getBalance()-money);    //2.4. 转入账户加钱    target.setBalance(target.getBalance()+money);    //2.5. 更新转出账户    accountDao.updateAccount(source);    //2.6. 更新转入账户    accountDao.updateAccount(target);    System.out.println("转账成功");}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><ol start="2"><li><p>DAOIImpl<br>@Repository(“accountDao”)<br>public class AccountDaoImpl implements IAccountDao {</p><p> @Autowired<br> private JdbcTemplate jdbcTemplate;</p></li></ol><pre><code>@Overridepublic Account findAccountById(Integer accountId) {    List&lt;Account&gt; accounts = jdbcTemplate.query("select * from Account where id = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountId);    return accounts.isEmpty() ? null:accounts.get(0);}@Overridepublic Account findAccountByName(String accountName) {    //写法不同,因为名字可能相同    List&lt;Account&gt; accounts = jdbcTemplate.query("select * from Account where name = ?", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), accountName);    if (accounts.isEmpty()){        return null;    }else if(accounts.size()&gt;1){        throw new RuntimeException("结果集不唯一");    }else {        return accounts.get(0);    }}@Overridepublic void updateAccount(Account account) {    jdbcTemplate.update("update account set name=?,balance=?,uid=? where id=?",account.getName(),account.getBalance(),account.getUid(),account.getId());}</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><ol start="3"><li>配置类</li></ol><p>/**</p><ul><li>Spring的配置类,相当于bean.xml</li><li>/<br>@Configuration<br>@ComponentScan(“com.sqtian”)<br>@Import({JdbcConfig.class,TransactionConfig.class})<br>@PropertySource(“jdbcConfig.properties”)<br>//开启事务注解的支持<br>@EnableTransactionManagement<br>public class SpringConfiguration {<br>}</li></ul><hr><p>/**</p><ul><li>和连接数据库相关的配置类</li><li>/</li></ul><p>public class JdbcConfig {</p><pre><code>@Value("${jdbc.driver}")private String driver;@Value("${jdbc.url}")private String url;@Value("${jdbc.username}")private String username;@Value("${jdbc.password}")private String password;/** * 创建jdbcTemplate * @param dataSource * @return */@Bean(name="jdbcTemplate")public JdbcTemplate createJdbcTemplate(DataSource dataSource){    return new JdbcTemplate(dataSource);}@Bean("dataSource")public DataSource createDataSource(){    DriverManagerDataSource ds = new DriverManagerDataSource();    ds.setDriverClassName(driver);    ds.setUrl(url);    ds.setUsername(username);    ds.setPassword(password);    return ds;}</code></pre><p>}</p><hr><p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8<br>jdbc.username=root<br>jdbc.password=root</p><hr><p>/**</p><ul><li>和事务相关的配置类</li><li>/</li></ul><p>public class TransactionConfig {</p><pre><code>/** * 用于创建事务管理器对象 * @param dataSource * @return */@Bean("transactionManager")public PlatformTransactionManager createTransactionManager(DataSource dataSource){    return new DataSourceTransactionManager(dataSource);}</code></pre><p>}</p><hr><ol start="4"><li>测试类</li></ol><p>@RunWith(SpringJUnit4ClassRunner.class)</p><p>@ContextConfiguration(classes = SpringConfiguration.class)<br>public class AccountServiceTest {</p><pre><code>@Autowiredprivate IAccountService accountService;@Testpublic void testTransfer() {    accountService.transfer("楚留香","西门吹雪",5000d);}</code></pre><p>}</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaNote_Spring_Day03</title>
      <link href="/2020/06/29/java-kuang-jia/javanote-spring-day03/"/>
      <url>/2020/06/29/java-kuang-jia/javanote-spring-day03/</url>
      
        <content type="html"><![CDATA[<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>spring中的app和基于XML以及注解的AOP配置</p><ol><li><p>完善我们的account案例</p></li><li><p>分析案例中的问题</p></li><li><p>回顾之前讲过的一个技术: 动态代理</p></li><li><p>动态代理另一种实现方式</p></li><li><p>解决案例中的问题</p></li><li><p>AOP的概念</p></li><li><p>spring中的AOP相关术语</p></li><li><p>spring中基于XML和注解的AOP配置</p><pre><code> 编码问题，改成utf8 &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8"&gt;&lt;/property&gt;</code></pre></li></ol><a id="more"></a><p>实现转账功能</p><ol><li><p>在持久层接口中添加根据名称找账户的方法</p></li><li><p>在持久层实现类中实现方法<br> public Account findAccountByName(String accountName) {</p><pre><code> try {     List&lt;Account&gt; accounts = runner.query("select * from account where name = ?",new BeanListHandler&lt;Account&gt;(Account.class),accountName);     if(accounts == null || accounts.size() == 0){         return null;     }else if(accounts.size() &gt; 1){         throw new RuntimeException("结果集不唯一,数据有问题");     }else{         return accounts.get(0);     } } catch (Exception e) {     throw new RuntimeException(e); }</code></pre><p> }</p></li><li><p>在业务层接口中添加转账方法</p></li><li><p>在业务层实现类中实现方法<br> public void transfer(String sourceName, String targetName, Double money) {</p><pre><code> //1. 根据名称查询转出账户 Account source = accountDao.findAccountByName(sourceName); //2. 根据名称查询转入账户 Account target = accountDao.findAccountByName(targetName); //3. 转出账户减钱 source.setBalance(source.getBalance()-money); //4. 转入账户加钱 target.setBalance(target.getBalance()+money); //5. 更新转出账户 accountDao.updateAccount(source); //int i=1/0 //6. 更新转入账户 accountDao.updateAccount(target);</code></pre><p> }</p></li></ol><p>问题：方法中没调用一次accountDao，就获取了一个连接，不同连接有自己的事务。如果中间报错，转账不完整。<br>需要使用ThreadLocal对象把Connection和当前线程绑定，从而使一个线程中只有一个能控制事务的对象</p><p>事务控制应该都是在业务层</p><ol><li>添加连接池工具类<br>package com.sqtian.utils;</li></ol><p>import javax.sql.DataSource;<br>import java.sql.Connection;</p><p>/**</p><ul><li><p>连接工具类,用于从数据源中获取一个连接,并且实现线程的绑定</p></li><li><p>/<br>public class ConnectionUtils {<br>  private ThreadLocal<connection> tl = new ThreadLocal<connection>();<br>  private DataSource datasource;</connection></connection></p><p>  public void setDatasource(DataSource datasource) {</p><pre><code>  this.datasource = datasource;</code></pre><p>  }</p><p>  public Connection getThreadConnection(){</p><pre><code>  //1. 先从ThreadLocal上获取  Connection connection = tl.get();  try {      //2. 判断当前线程上是否有连接      if(connection == null){          //3. 从数据源中获取一个连接,并且存入ThreadLocal中          connection = datasource.getConnection();          tl.set(connection);      }      //4. 返回当前线程上的连接      return connection;  } catch (Exception e) {      throw new RuntimeException(e);  }</code></pre><p>  }</p><p>  /**</p><ul><li>把连接和线程解绑</li><li>/<br>public void removeConnection(){<br>  tl.remove();<br>}</li></ul></li></ul><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><ol start="2"><li>添加事务管理工具类</li></ol><p>package com.sqtian.utils;</p><p>import java.sql.SQLException;</p><p>/**</p><ul><li><p>和事务管理相关的工具类,它包含了,开启事务,提交事务,回滚事务和释放连接</p></li><li><p>/<br>public class TransactionManager {</p><p>  private ConnectionUtils connectionUtils;</p><p>  public void setConnectionUtils(ConnectionUtils connectionUtils) {</p><pre><code>  this.connectionUtils = connectionUtils;</code></pre><p>  }</p><p>  /**</p><ul><li><p>开启事务</p></li><li><p>/<br>public void beginTransaction(){<br>  try {</p><pre><code>  connectionUtils.getThreadConnection().setAutoCommit(false);</code></pre><p>  } catch (SQLException e) {</p><pre><code>  e.printStackTrace();</code></pre><p>  }<br>}</p><p>/**</p></li><li><p>提交事务</p></li><li><p>/<br>public void commit(){<br>  try {</p><pre><code>  connectionUtils.getThreadConnection().commit();</code></pre><p>  } catch (SQLException e) {</p><pre><code>  e.printStackTrace();</code></pre><p>  }<br>}</p><p>/**</p></li><li><p>回滚事务</p></li><li><p>/<br>public void rollback(){<br>  try {</p><pre><code>  connectionUtils.getThreadConnection().rollback();</code></pre><p>  } catch (SQLException e) {</p><pre><code>  e.printStackTrace();</code></pre><p>  }<br>}</p><p>/**</p></li><li><p>释放连接</p></li><li><p>/<br>public void release(){<br>  try {</p><pre><code>  connectionUtils.getThreadConnection().close();//换回连接池中  connectionUtils.removeConnection();</code></pre><p>  } catch (SQLException e) {</p><pre><code>  e.printStackTrace();</code></pre><p>  }<br>}<br>}</p></li></ul></li></ul><hr><ol start="3"><li>在业务层控制事务</li></ol><p>package com.sqtian.service.impl;</p><p>import com.sqtian.dao.IAccountDao;<br>import com.sqtian.domain.Account;<br>import com.sqtian.service.IAccountService;<br>import com.sqtian.utils.TransactionManager;</p><p>import java.util.List;</p><p>/**</p><ul><li><p>账户的业务层实现类</p></li><li></li><li><p>事务控制应该都是在业务层</p></li><li><p>/<br>public class AccountServiceImpl implements IAccountService {</p><p>  private IAccountDao accountDao;<br>  private TransactionManager txManager;</p><p>  //交给spring注入<br>  public void setTxManager(TransactionManager txManager) {</p><pre><code>  this.txManager = txManager;</code></pre><p>  }</p><p>  //交给spring注入<br>  public void setAccountDao(IAccountDao accountDao) {</p><pre><code>  this.accountDao = accountDao;</code></pre><p>  }</p></li></ul><pre><code>public void transfer(String sourceName, String targetName, Double money) {    try{        //1. 开启事务        txManager.beginTransaction();        //2. 执行操作        //2.1. 根据名称查询转出账户        Account source = accountDao.findAccountByName(sourceName);        //2.2. 根据名称查询转入账户        Account target = accountDao.findAccountByName(targetName);        //2.3. 转出账户减钱        source.setBalance(source.getBalance()-money);        //2.4. 转入账户加钱        target.setBalance(target.getBalance()+money);        //2.5. 更新转出账户        accountDao.updateAccount(source);        //2.6. 更新转入账户        accountDao.updateAccount(target);        //3. 提交事务        txManager.commit();    }catch (Exception e){        //5. 回滚操作        txManager.rollback();        throw new RuntimeException(e);    }finally {        //6. 释放连接        txManager.release();    }}</code></pre><p>}</p><hr><ol start="4"><li><p>持久层实现类改变连接方式<br> //不再希望通过queryRunner里取连接,而是通过connectionUtils取<br> //删去原来的注入<constructor-arg name="ds" ref="dataSource"></constructor-arg></p><p> private ConnectionUtils connectionUtils;</p><p> public void setConnectionUtils(ConnectionUtils connectionUtils) {</p><pre><code> this.connectionUtils = connectionUtils;</code></pre><p> }</p><p> //改成加入connectionUtils.getThreadConnection()参数的guery方法<br> public Account findAccountByName(String accountName) {</p><pre><code> try {     List&lt;Account&gt; accounts = runner.query(connectionUtils.getThreadConnection(),"select * from account where name = ?",new BeanListHandler&lt;Account&gt;(Account.class),accountName);     if(accounts == null || accounts.size() == 0){         return null;     }else if(accounts.size() &gt; 1){         throw new RuntimeException("结果集不唯一,数据有问题");     }else{         return accounts.get(0);     } } catch (Exception e) {     throw new RuntimeException(e); }</code></pre><p> }</p></li></ol><hr><ol start="5"><li><p>注入新的依赖</p><!--?xml version="1.0" encoding="UTF-8"?--><p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans"</a></p><pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</code></pre> <bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl">     <!--注入dao对象-->     <property name="accountDao" ref="accountDao"></property>     <!--注入事务管理器-->     <property name="txManager" ref="txManager"></property> </bean> <bean id="accountDao" class="com.sqtian.dao.impl.AccountDaoImpl">     <property name="runner" ref="runner"></property>     <property name="connectionUtils" ref="connectionUtils"></property> </bean> <!--配置QueryRunner,如果用单例时,一个要用,另一个可能还没用完,线程受到影响.因此要用多例--> <bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype">     <!--注入数据源--> </bean> <!--配置数据源连接池--> <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">     <!--配置连接数据库的必备信息-->     <property name="driverClass" value="com.mysql.jdbc.Driver"></property>     <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8"></property>     <property name="user" value="root"></property>     <property name="password" value="root"></property> </bean> <!--配置Connection的工具类 ConnectionUtils--> <bean id="connectionUtils" class="com.sqtian.utils.ConnectionUtils">     <!--注入数据源-->     <property name="dataSource" ref="dataSource"></property> </bean> <!--配置事务管理器--> <bean id="txManager" class="com.sqtian.utils.TransactionManager">     <property name="connectionUtils" ref="connectionUtils"></property> </bean></li></ol><hr><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>现在依赖太繁杂，方法之间也存在依赖。如果一个方法名改变了，则需要变动大量代码。<br>需要使用动态代理<br>类似于客户与生产厂家之间的代理商</p><p>基于接口的动态代理<br>1.<br>package com.sqtian.proxy;</p><p>/**</p><ul><li><p>对生产厂家要求的接口</p></li><li><p>/<br>public interface IProducer {</p><p>  /**</p><ul><li>销售</li><li>@param money</li><li>/<br>public void saleProduct(Double money);<br>/**</li><li>售后</li><li>@param money</li><li>/<br>public void afterService(Double money);</li></ul></li></ul><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><ol start="2"><li>package com.sqtian.proxy;</li></ol><p>/**</p><ul><li><p>一个生产者</p></li><li></li><li><p>/<br>public class Producer implements IProducer{</p><p>  /**</p><ul><li><p>销售</p></li><li><p>@param money</p></li><li><p>/<br>public void saleProduct(Double money){<br>  System.out.println(“销售产品,并拿到钱:”+money);<br>}</p><p>/**</p></li><li><p>售后</p></li><li><p>@param money</p></li><li><p>/<br>public void afterService(Double money){<br>  System.out.println(“提供售后服务,并拿到钱:”+money);<br>}<br>}</p></li></ul></li></ul><hr><p>package com.sqtian.proxy;</p><p>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;</p><p>/**</p><ul><li><p>模拟一个消费者</p></li><li><p>/<br>public class Client {<br>  public static void main(String[] args) {</p><pre><code>  //匿名内部类访问外部成员时,外部成员要求是最终的  final Producer producer = new Producer();  producer.saleProduct(10000d);  /**   * 动态代理:   *     特点: 字节码随用随创建,随用随加载   *     作用: 不修改源码的基础上对方法加强   *     分类:   *         基于接口的动态代理   *         基于子类的动态代理   *     基于接口的动态代理:   *         涉及的类: Proxy   *         提供者: JDK官方   *     如何创建代理对象:   *         使用Proxy类中的newProxyInstance方法   *     创建代理对象的要求:   *         被代理类最少实现一个接口,如果没有则不能使用   *     newProxyInstance方法的参数:   *         ClassLoader: 类加载器   *             它用于加载代理对象字节码的.和被代理对象使用相同的类加载器. 固定写法 producer.getClass().getClassLoader()   *         Class[]   *             它是用于让代理对象和被代理对象有相同方法. 固定写法 producer.getClass().getInterfaces()   *         InvocationHandler: 用于提供增强的代码   *             它是让我们写如何代理.我们一般是都是些一个该接口的实现类.通常情况下都是匿名内部类.   *             此接口的实现类都是谁用谁写   *   *   */  IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(),      new InvocationHandler() {          /**           * 作用: 执行被代理对象的任何接口方法都会经过该方法           * @param proxy   代理对象的引用           * @param method  当前执行的方法           * @param args    当前执行方法所需的参数           * @return        和被代理对象方法有相同的返回值           * @throws Throwable           */      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {          //提供增强的代码          //比如经销商提取20%利润          Object returnValue = null;          //1. 获取方法执行的参数          Double money = (Double) args[0];          //2. 判断当前方法是不是销售          if("saleProduct".equals(method.getName())){              returnValue = method.invoke(producer,money*0.8d);          }          return returnValue;      }  });  proxyProducer.saleProduct(10000d);</code></pre><p>  }</p></li></ul><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>如果没有实现接口，则会报错</p><p>引出第二种代理方式<br>基于子类的动态代理<br>Producer 不需要实现接口</p><ol><li><p>导入cglib的jar包</p> <dependencies>     <dependency>         <groupid>cglib</groupid>         <artifactid>cglib</artifactid>         <version>2.1_3</version>     </dependency> </dependencies></li><li><p>/**</p><ul><li><p>模拟一个消费者</p></li><li><p>/<br>public class Client {<br>public static void main(String[] args) {</p><pre><code>//匿名内部类访问外部成员时,外部成员要求是最终的final Producer producer = new Producer();producer.saleProduct(10000d);/** * 动态代理: *     特点: 字节码随用随创建,随用随加载 *     作用: 不修改源码的基础上对方法加强 *     分类: *         基于接口的动态代理 *         基于子类的动态代理 *     基于接口的动态代理: *         涉及的类: Enhancer *         提供者: 第三方cglib库 *     如何创建代理对象: *         使用Enhancer类中的create方法 *     创建代理对象的要求: *         被代理类不能是最终类 *     create方法的参数: *         Class: 字节码 *             它用于指定被代理对象的字节码 *         Callback: 用于提供增强的代码 *             它是让我们写如何代理.我们一般是都是些一个该接口的实现类.通常情况下都是匿名内部类. *             此接口的实现类都是谁用谁写 *            一般写的都是该接口的子接口实现类: MethodInterceptor * */Producer cglibProducer = (Producer) Enhancer.create(producer.getClass(),new MethodInterceptor(){    /**     * 作用: 执行被代理对象的任何接口方法都会经过该方法     * @param proxy   代理对象的引用     * @param method  当前执行的方法     * @param args    当前执行方法所需的参数     * @param methodProxy 当前执行方法的代理对象     * @return        和被代理对象方法有相同的返回值     * @throws Throwable     */    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {            //提供增强的代码            //比如经销商提取20%利润            Object returnValue = null;            //1. 获取方法执行的参数            Double money = (Double) args[0];            //2. 判断当前方法是不是销售            if("saleProduct".equals(method.getName())){                returnValue = method.invoke(producer,money*0.8d);            }            return returnValue;    }});cglibProducer.saleProduct(10000d);</code></pre><p>}</p></li></ul></li></ol><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><p>回到转账案例<br>AccountServiceImpl中太多事务管理的冗余代码，通过代理对象统一管理</p><ol><li>把事务管理的代码交给BeanFactory<br>package com.sqtian.service.impl;</li></ol><p>/**</p><ul><li><p>账户的业务层实现类</p></li><li></li><li><p>事务控制应该都是在业务层</p></li><li><p>/<br>public class AccountServiceImpl implements IAccountService {</p><p>  private IAccountDao accountDao;</p></li></ul><pre><code>//交给spring注入public void setAccountDao(IAccountDao accountDao) {    this.accountDao = accountDao;}public void transfer(String sourceName, String targetName, Double money) {    //2.1. 根据名称查询转出账户    Account source = accountDao.findAccountByName(sourceName);    //2.2. 根据名称查询转入账户    Account target = accountDao.findAccountByName(targetName);    //2.3. 转出账户减钱    source.setBalance(source.getBalance()-money);    //2.4. 转入账户加钱    target.setBalance(target.getBalance()+money);    //2.5. 更新转出账户    accountDao.updateAccount(source);    //2.6. 更新转入账户    accountDao.updateAccount(target);    System.out.println("转账成功");}</code></pre><p>}</p><hr><p>package com.sqtian.factory;</p><p>import com.sqtian.service.IAccountService;<br>import com.sqtian.utils.TransactionManager;</p><p>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;</p><p>/**</p><ul><li><p>用于创建Service的代理对象的工厂</p></li><li></li><li><p>/<br>public class BeanFactory {<br>  private IAccountService accountService;<br>  private TransactionManager txManager;</p><p>  //交给spring注入<br>  public void setTxManager(TransactionManager txManager) {</p><pre><code>  this.txManager = txManager;</code></pre><p>  }</p><p>  public final void setAccountService(IAccountService accountService) {</p><pre><code>  this.accountService = accountService;</code></pre><p>  }</p><p>  /**</p><ul><li>获取Service代理对象</li><li>/<br>public IAccountService getAccountService() {<br>  return (IAccountService) Proxy.newProxyInstance(accountService.getClass().getClassLoader(),<pre><code>  accountService.getClass().getInterfaces(),  new InvocationHandler() {      /**       * 添加事务支持       *       * @param proxy       * @param method       * @param args       * @return       * @throws Throwable       */      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {          Object returnValue = null;          try {              //1. 开启事务              txManager.beginTransaction();              //2. 执行操作              returnValue = method.invoke(accountService, args);              //3. 提交事务              txManager.commit();              //4. 返回结果              return returnValue;          } catch (Exception e) {              //5. 回滚操作              txManager.rollback();              throw new RuntimeException(e);          } finally {              //6. 释放连接              txManager.release();          }      }  });</code></pre>}</li></ul></li></ul><p>}</p><hr><ol start="2"><li>修改配置文件<!--?xml version="1.0" encoding="UTF-8"?-->&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/beans"</a><pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</code></pre></li></ol><pre><code>&lt;!--配置代理的service--&gt;&lt;bean id="proxyAccountService" factory-bean="beanFactory" factory-method="getAccountService"&gt;&lt;/bean&gt;&lt;!--配置beanFactory--&gt;&lt;bean id="beanFactory" class="com.sqtian.factory.BeanFactory"&gt;    &lt;property name="accountService" ref="accountService"&gt;&lt;/property&gt;    &lt;property name="txManager" ref="txManager"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;    &lt;!--注入dao对象--&gt;    &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;</code></pre><!--        &lt;!&ndash;注入事务管理器&ndash;&gt;--><!--        <property name="txManager" ref="txManager"></property>--><pre><code>&lt;/bean&gt;&lt;bean id="accountDao" class="com.sqtian.dao.impl.AccountDaoImpl"&gt;    &lt;property name="runner" ref="runner"&gt;&lt;/property&gt;    &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置QueryRunner,如果用单例时,一个要用,另一个可能还没用完,线程受到影响.因此要用多例--&gt;&lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt;    &lt;!--注入数据源--&gt;&lt;/bean&gt;&lt;!--配置数据源连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;!--配置连接数据库的必备信息--&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/lovelycc?characterEncoding=utf8"&gt;&lt;/property&gt;    &lt;property name="user" value="root"&gt;&lt;/property&gt;    &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置Connection的工具类 ConnectionUtils--&gt;&lt;bean id="connectionUtils" class="com.sqtian.utils.ConnectionUtils"&gt;    &lt;!--注入数据源--&gt;    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置事务管理器--&gt;&lt;bean id="txManager" class="com.sqtian.utils.TransactionManager"&gt;    &lt;property name="connectionUtils" ref="connectionUtils"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h2 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h2><p>Aspect Oriented Programming 面向切面编程<br>通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术<br>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性<br>优势：<br>    减少重复代码<br>    提高开发效率<br>    维护方便</p><p>相关术语<br>Joinpoint(连接点):<br>    所谓连接点是指那些被拦截的点.在spring中,这些点指方法,因为spring只支持方法类型的连接点<br>Pointcut(切入点):<br>    指我们要对哪些Joinpoint进行拦截的定义 (被动态代理的方法)</p><p>Advice(通知/增强):<br>    拦截后要做的事情<br>    前置通知,后置通知,异常通知,最终通知,环绕通知</p><p>Target(目标对象):<br>    代理的目标对象</p><p>Weaving(织入):<br>    把增强应用到目标对象来创建新的代理对象的过程</p><p>Proxy(代理):<br>    被增强后产生的结果代理类</p><p>Aspect(切面):<br>    是切入点与通知的结合</p><p>打印日志的AOP测试</p><p>public class AccountServiceImpl implements IAccountService {<br>    public void saveAccount() {<br>        System.out.println(“执行了保存”);<br>    }</p><pre><code>public void updateAccount(int i) {    System.out.println("执行了更新");}public int deleteAccount() {    System.out.println("执行了删除");    return 0;}</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><p>package com.sqtian.utils;</p><p>/**</p><ul><li>用于记录日志的工具类,它里面提供了公共的代码</li><li>/</li></ul><p>public class Logger {</p><pre><code>/** * 用于打印日志,计划让其在切入点方法执行之前执行(切入点方法就是业务层方法) * */public void printLog(){    System.out.println("Logger类中的printLog方法开始记录日志");}</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title="}"></a>}</h2><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p><pre><code>&lt;!-- 配置spring的IOC, 把Service对象配置进来 --&gt;&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!-- spring中基于XML的AOP配置步骤    1. 把通知的Bean也交给spring来管理    2. 使用aop:config标签表明开始AOP的配置    3. 使用aop:aspect标签表面配置切面            id属性: 是给切面提供一个唯一标识            ref属性: 是指定通知类的bean的ID    4. 在aop:aspect标签的内部使用对应标签来配置通知的类型            我们现在的示例是让printLog方法在切入点方法执行之前执行,所以是前置通知            aop:before 表示配置前置通知                method属性:用于指定Logger类中哪个方法是前置通知                pointcut属性:用于指定切入点表达式,该表达式的含义指的是对业务层中哪些方法增强        切入点表达式的写法:            关键字: execution(表达式)            表达式:                访问修饰符  返回值  包名.类名.方法名(参数列表)            标准写法:                public void com.sqtian.service.impl.AccountServiceImpl.saveAccount()            访问修饰符可以省略                void com.sqtian.service.impl.AccountServiceImpl.saveAccount()            返回值可以使用通配符表示任意返回值                * com.sqtian.service.impl.AccountServiceImpl.saveAccount()                包名可以使用通配符表示任意包，但是有几级包就业写几个*                * *.*.*.*.AccountServiceImpl.saveAccount()               包名可以使用..表示当前包及其子包                * *..AccountServiceImpl.saveAccount()            类名和方法名都可以使用*表示通配                * *..*.*()            参数列表:                可以直接写数据类型:                    基本类型直接写名称         int                    引用类型写包名.类名的方式   java.lang.String                    可以使用通配符表示任意类型,但是必须有参数 * *..*.*(*)                    可以使用..表示有无参数均可              * *..*.*(..)            全通配写法:                * *..*.*(..)            实际开发中,切入点表达式的通常写法:                切到业务层实现类下的所有方法                * com.sqtian.service.impl.*.*(..)--&gt;&lt;!--配置Logger类--&gt;&lt;bean id="logger" class="com.sqtian.utils.Logger"&gt;&lt;/bean&gt;&lt;!--配置AOP--&gt;&lt;aop:config&gt;    &lt;!--配置切面--&gt;    &lt;aop:aspect id="logAdvice" ref="logger"&gt;        &lt;!--配置通知的类型,并且建立通知方法和切入点方法的关联--&gt;        &lt;aop:before method="printLog" pointcut="execution(* com.sqtian.service.impl.*.*(..))"&gt;&lt;/aop:before&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><hr><p>/**</p><ul><li>测试AOP的配置</li><li>/<br>public class AOPTest {<br>  public static void main(String[] args) {<pre><code>  //1. 获取容器  ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");  //2. 获取对象  IAccountService as = (IAccountService) ac.getBean("accountService");  //3. 执行方法  as.saveAccount();</code></pre>  }<br>}</li></ul><hr><p>通知的类型<br>package com.sqtian.utils;</p><p>import org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint;</p><p>/**</p><ul><li>用于记录日志的工具类,它里面提供了公共的代码</li><li>/</li></ul><p>public class Logger {</p><pre><code>/** * 前置通知 * */public void beforePrintLog(){    System.out.println("Logger类中的前置通知方法开始记录日志");}/** * 后置通知 * */public void afterReturningPrintLog(){    System.out.println("Logger类中的后置通知方法开始记录日志");}/** * 异常通知 * */public void afterThrowingPrintLog(){    System.out.println("Logger类中的异常通知方法开始记录日志");}/** * 最终通知 * */public void afterPrintLog(){    System.out.println("Logger类中的最终通知方法开始记录日志");}/** * 环绕通知 * 问题: *         当我们配置类环绕通知之后,切入点方法没有执行,而通知方法执行了 * 分析: *         通过对比动态代理中的环绕通知代码,发现动态代理的环绕通知有明确的切入点方法调用, * 解决: *     spring框架为我们提供了一个接口: ProceedingJoinPoint. 该接口有一个方法proceed(). 此方法就相当于明确调用切入点方法 *     该接口可以作为环绕通知的方法参数,在程序执行时,spring框架会提供实现类给我们使用 * *     spring中的环绕通知: *         它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式. 写在哪就在什么位置执行 */public Object aroundPrintLog(MethodInvocationProceedingJoinPoint pjp){    Object rtValue = null;    try {        Object[] args = pjp.getArgs(); //得到方法执行所需的参数        System.out.println("Logger类中的环绕通知方法开始记录日志");        rtValue = pjp.proceed(); //明确调用业务层方法(切入点方法)        System.out.println("Logger类中的环绕通知方法开始记录日志");        return rtValue;    }catch (Throwable t){        System.out.println("Logger类中的环绕通知方法开始记录日志");        throw new RuntimeException(t);    }finally {        System.out.println("Logger类中的环绕通知方法开始记录日志");    }}</code></pre><p>}</p><hr><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd"></beans></p><pre><code>&lt;!-- 配置spring的IOC, 把Service对象配置进来 --&gt;&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt;&lt;!--配置Logger类--&gt;&lt;bean id="logger" class="com.sqtian.utils.Logger"&gt;&lt;/bean&gt;&lt;!--配置AOP--&gt;&lt;aop:config&gt;    &lt;!--配置切入点表达式 id属性用于指定表达式的唯一标识. expression属性用于指定表达式内容        此标签写在aop:aspect标签内部只能当前切面使用.        它还可以写在aop:aspect的外卖,此时就变成了所有切面可用,但是按约束要求要放在切面配置之前    --&gt;    &lt;aop:pointcut id="pt1" expression="execution(* com.sqtian.service.impl.*.*(..))"/&gt;    &lt;!--配置切面--&gt;    &lt;aop:aspect id="logAdvice" ref="logger"&gt;</code></pre><!--            &lt;!&ndash;配置前置通知的类型,在切入点方法执行之前执行&ndash;&gt;--><!--            <aop:before method="beforePrintLog" pointcut-ref="pt1"></aop:before>--><!--            &lt;!&ndash;配置后置通知的类型,在切入点方法正常执行之后执行,与异常通知只有一个执行&ndash;&gt;--><!--            <aop:after-returning method="afterReturningPrintLog" pointcut-ref="pt1"></aop:after-returning>--><!--            &lt;!&ndash;配置异常通知的类型,在切入点方法执行产生异常之后执行,与后置通知只有一个执行&ndash;&gt;--><!--            <aop:after-throwing method="afterThrowingPrintLog" pointcut-ref="pt1"></aop:after-throwing>--><!--            &lt;!&ndash;配置最终通知的类型,无论切入点方法是否正常执行都会在其后面执行&ndash;&gt;--><!--            <aop:after method="afterPrintLog" pointcut-ref="pt1"></aop:after>--><pre><code>        &lt;!--配置环绕通知--&gt;        &lt;aop:around method="aroundPrintLog" pointcut-ref="pt1"&gt;&lt;/aop:around&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><hr><h2 id="注解AOP"><a href="#注解AOP" class="headerlink" title="注解AOP"></a>注解AOP</h2><p>bean.xml</p><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/aop" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        https://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd"></beans></p><pre><code>&lt;!--配置要扫描的包--&gt;&lt;context:component-scan base-package="com.sqtian"&gt;&lt;/context:component-scan&gt;&lt;!--配置spring开启注解AOP的支持--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><hr><p>@Service(“accountService”)<br>public class AccountServiceImpl implements IAccountService {<br>…<br>}</p><hr><p>package com.sqtian.utils;</p><p>import org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint;</p><p>/**</p><ul><li>用于记录日志的工具类,它里面提供了公共的代码</li><li>/</li></ul><p>@Component(“logger”)<br>@Aspect //表示当前类是一个切面类<br>public class Logger {</p><pre><code>/** * 注解配置切入点表达式 */@Pointcut("execution(* com.sqtian.service.impl.*.*(..))")private void pt1(){}/** * 前置通知 * */@Before("pt1()")public void beforePrintLog(){    System.out.println("Logger类中的前置通知方法开始记录日志");}/** * 后置通知 * */@AfterReturning("pt1()")public void afterReturningPrintLog(){    System.out.println("Logger类中的后置通知方法开始记录日志");}/** * 异常通知 * */@AfterThrowing("pt1()")public void afterThrowingPrintLog(){    System.out.println("Logger类中的异常通知方法开始记录日志");}/** * 最终通知 * */@After("pt1()")public void afterPrintLog(){    System.out.println("Logger类中的最终通知方法开始记录日志");}/** * 环绕通知 */@Arround("pt1()")public Object aroundPrintLog(MethodInvocationProceedingJoinPoint pjp){    Object rtValue = null;    try {        Object[] args = pjp.getArgs(); //得到方法执行所需的参数        System.out.println("Logger类中的环绕通知方法开始记录日志");        rtValue = pjp.proceed(); //明确调用业务层方法(切入点方法)        System.out.println("Logger类中的环绕通知方法开始记录日志");        return rtValue;    }catch (Throwable t){        System.out.println("Logger类中的环绕通知方法开始记录日志");        throw new RuntimeException(t);    }finally {        System.out.println("Logger类中的环绕通知方法开始记录日志");    }}</code></pre><p>}</p><hr><p>//不用xml的方式,在配置类加上注解@EnableAspectJAutoProxy</p><p>package config;</p><p>import org.springframework.context.annotation.*;</p><p>@Configuration<br>@ComponentScan(“com.sqtian”)<br>@EnableAspectJAutoProxy<br>@Import(JdbcConfig.class)<br>@PropertySource(“classpath:JdbcConfig.properties”)<br>public class SpringConfiguration {</p><pre><code>//用于写公共配置</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaNote_Spring_Day02</title>
      <link href="/2020/06/29/java-kuang-jia/javanote-spring-day02/"/>
      <url>/2020/06/29/java-kuang-jia/javanote-spring-day02/</url>
      
        <content type="html"><![CDATA[<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><p>spring中基于注解的IOC和ioc的案例</p><ol><li><p>spring中ioc的常用注解</p></li><li><p>案例使用xml方式和注解方式实现单表的CRUD操作<br> 持久层技术选择：dbutils</p></li><li><p>改造基于注解的ioc案例，使用纯注解的方式实现<br> spring的一些新注解使用</p></li><li><p>spring和Junit整合</p></li></ol><a id="more"></a><p>Account案例</p><ol><li>导入依赖<br>pom.xml</li></ol><!--?xml version="1.0" encoding="UTF-8"?--><p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelversion>4.0.0</modelversion></project></p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;com.sqtian.springExample&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;        &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;        &lt;version&gt;1.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;c3p0&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.13&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><hr><ol start="2"><li>创建业务层接口与实现类</li></ol><p>package com.sqtian.service;</p><p>import com.sqtian.domain.Account;</p><p>import java.util.List;</p><p>/**</p><ul><li><p>账户的业务层接口</p></li><li></li><li><p>/<br>public interface IAccountService {</p><p>  /**</p><ul><li><p>查询所有</p></li><li><p>@return</p></li><li><p>/<br>List<account> findAllAccount();</account></p><p>/**</p></li><li><p>找一个</p></li><li><p>@return</p></li><li><p>/<br>Account findAccountById(Integer accountId);</p><p>/**</p></li><li><p>保存</p></li><li><p>@param account</p></li><li><p>/<br>void saveAccount(Account account);</p><p>/**</p></li><li><p>改</p></li><li><p>@param account</p></li><li><p>/<br>void updateAccount(Account account);</p><p>/**</p></li><li><p>删</p></li><li><p>@param accountId</p></li><li><p>/<br>void deleteAccount(Integer accountId);<br>}</p></li></ul></li></ul><hr><p>package com.sqtian.service.impl;</p><p>import com.sqtian.dao.IAccountDao;<br>import com.sqtian.domain.Account;<br>import com.sqtian.service.IAccountService;</p><p>import java.util.List;</p><p>/**</p><ul><li><p>账户的业务层实现类</p></li><li><p>/<br>public class AccountServiceImpl implements IAccountService {</p><p>  private IAccountDao accountDao;</p><p>  public void setAccountDao(IAccountDao accountDao) {</p><pre><code>  this.accountDao = accountDao;</code></pre><p>  }</p><p>  public List<account> findAllAccount() {</account></p><pre><code>  return accountDao.findAllAccount();</code></pre><p>  }</p><p>  public Account findAccountById(Integer accountId) {</p><pre><code>  return accountDao.findAccountById(accountId);</code></pre><p>  }</p><p>  public void saveAccount(Account account) {</p><pre><code>  accountDao.saveAccount(account);</code></pre><p>  }</p><p>  public void updateAccount(Account account) {</p><pre><code>  accountDao.updateAccount(account);</code></pre><p>  }</p><p>  public void deleteAccount(Integer accountId) {</p><pre><code>  accountDao.deleteAccount(accountId);</code></pre><p>  }<br>}</p></li></ul><hr><ol start="3"><li>创建Account实体类<br>package com.sqtian.domain;</li></ol><p>import java.io.Serializable;</p><p>/**</p><ul><li>账户的实体类</li><li></li><li>/</li></ul><p>public class Account implements Serializable {<br>    private Integer id;<br>    private String name;<br>    private double balance;</p><pre><code>public Integer getId() {    return id;}public void setId(Integer id) {    this.id = id;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public double getBalance() {    return balance;}public void setBalance(double balance) {    this.balance = balance;}@Overridepublic String toString() {    return "Account{" +        "id=" + id +        ", name='" + name + '\'' +        ", balance=" + balance +        '}';}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><ol start="4"><li>创建持久层接口和实现类<br>package com.sqtian.dao;</li></ol><p>import com.sqtian.domain.Account;</p><p>import java.util.List;</p><p>/**</p><ul><li>持久层接口</li><li>/</li></ul><p>public interface IAccountDao {</p><pre><code>/** * 查询所有 * @return */List&lt;Account&gt; findAllAccount();/** * 找一个 * @return */Account findAccountById(Integer accountId);/** * 保存 * @param account */void saveAccount(Account account);/** * 改 * @param account */void updateAccount(Account account);/** * 删 * @param accountId */void deleteAccount(Integer accountId);</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>package com.sqtian.dao.impl;</p><p>import com.sqtian.dao.IAccountDao;<br>import com.sqtian.domain.Account;<br>import org.apache.commons.dbutils.QueryRunner;<br>import org.apache.commons.dbutils.handlers.BeanHandler;<br>import org.apache.commons.dbutils.handlers.BeanListHandler;</p><p>import java.sql.SQLException;<br>import java.util.List;</p><p>/**</p><ul><li>持久层实现类</li><li></li><li>/</li></ul><p>public class AccountDaoImpl implements IAccountDao {</p><pre><code>private QueryRunner runner;//交给spring注入public void setRunner(QueryRunner runner) {    this.runner = runner;}public List&lt;Account&gt; findAllAccount() {    try {        return runner.query("select * from account",new BeanListHandler&lt;Account&gt;(Account.class));    } catch (Exception e) {        throw new RuntimeException(e);    }}public Account findAccountById(Integer accountId) {    try {        return runner.query("select * from account where id = ?",new BeanHandler&lt;Account&gt;(Account.class),accountId);    } catch (Exception e) {        throw new RuntimeException(e);    }}public void saveAccount(Account account) {    try {        runner.update("insert into account(name,balance)values(?,?)",account.getName(),account.getBalance());    } catch (Exception e) {        throw new RuntimeException(e);    }}public void updateAccount(Account account) {    try {        runner.update("update account set name=?,balance=? where id = ?",account.getName(),account.getBalance(),account.getId());    } catch (Exception e) {        throw new RuntimeException(e);    }}public void deleteAccount(Integer accountId) {    try {        runner.update("delete from account where id = ?",accountId);    } catch (Exception e) {        throw new RuntimeException(e);    }}</code></pre><p>}</p><hr><ol start="5"><li>配置spring<br>bean.xml</li></ol><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd"></beans></p><pre><code>&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;    &lt;!--注入dao对象--&gt;    &lt;property name="accountDao" ref="accountDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="accountDao" class="com.sqtian.dao.impl.AccountDaoImpl"&gt;    &lt;property name="runner" ref="runner"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置QueryRunner,如果用单例时,一个要用,另一个可能还没用完,线程受到影响.因此要用多例--&gt;&lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt;    &lt;!--注入数据源--&gt;    &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--配置数据源连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;!--配置连接数据库的必备信息--&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC"&gt;&lt;/property&gt;    &lt;property name="user" value="root"&gt;&lt;/property&gt;    &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><ol start="6"><li>创建测试类<br>package com.sqtian.test;</li></ol><p>import com.sqtian.domain.Account;<br>import com.sqtian.service.IAccountService;<br>import org.junit.Test;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;</p><p>import java.util.List;</p><p>/**</p><ul><li>使用junit单元测试</li><li></li><li>/</li></ul><p>public class AccountServiceTest {</p><pre><code>@Testpublic void testFindAll() {    //1. 获取容器    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");    //2. 调用业务层对象    IAccountService as = ac.getBean("accountService",IAccountService.class);    //3. 执行方法    List&lt;Account&gt; accounts = as.findAllAccount();    for (Account account : accounts) {        System.out.println(account);    }}@Testpublic void testFindAllOne() {    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");    IAccountService as = ac.getBean("accountService", IAccountService.class);    Account accountById = as.findAccountById(1);    System.out.println(accountById);}@Testpublic void testSave() {    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");    IAccountService as = ac.getBean("accountService", IAccountService.class);    Account account = new Account();    account.setName("CC");    account.setBalance(7000);    account.setUid(25);    as.saveAccount(account);}@Testpublic void testUpdate() {    Account account = new Account();    account.setName("CCTT");    account.setBalance(7000);    account.setUid(20);    account.setId(5);    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");    IAccountService as = ac.getBean("accountService", IAccountService.class);    as.updateAccount(account);}@Testpublic void testDelete() {    ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");    IAccountService as = ac.getBean("accountService", IAccountService.class);    as.deleteAccount(5);}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>/**</p><ul><li>账户的业务层实现类</li><li>业务层调用持久层</li><li></li><li>注解实现IOC</li><li>用于创建对象的</li><li>他们的作用就和在xml配置文件中编写一个<bean></bean>标签实现的功能是一样的</li><li>Component</li><li>作用: 用于把当前类的对象存入spring容器中</li><li>属性:</li><li>value, 用于指定bean的id,不写时默认是当前类名,且首字母小写</li><li></li><li>Controller</li><li>一般用在表现层</li><li>Service</li><li>一般用在业务层</li><li>Repository</li><li>一般用在持久层</li><li>以上三个注解的作用和属性与Component是一模一样的</li><li>他们三个是spring框架为我们提供的三层使用的注解，使我们的三层对象更清晰</li><li></li><li></li><li>用于注入数据的</li><li>和在xml配置文件中的bean标签写一个<property></property>标签的作用是一样的</li><li>Autowired</li><li>作用：自动按照类型注入，只要容器中有唯一一个bean对象类型和要注入的变量类型匹配，就可以注入成功，没有则报错</li><li>出现位置可以是变量上，也可以是方法上</li><li>Qualifier</li><li>作用：在按照类型注入的基础上再按照名称注入。给类成员注入时不能单独使用。但是在给方法参数注入时可以。</li><li>Resource</li><li>作用：直接按照bean的id注入，可以独立使用</li><li>属性：name，用于指定id</li><li>以上三个注解都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现</li><li>另外，集合类型的注入只能通过xml来实现</li><li></li><li>用于改变作用范围</li><li>和在bean标签中使用scope属性实现的功能一样</li><li>Scope</li><li>用于指定bean的作用范围</li><li>属性： value指定范围的取值 常用取值：singleton、prototype</li><li></li><li>和生命周期相关 （了解）</li><li>和在bean标签中使用init-method和destroy-method作用一样</li><li>PreDestroy</li><li>用于指定销毁方法</li><li>PostConstruct</li><li>用于指定初始化方法</li><li>/</li></ul><h2 id="通过注解的方式优化账户案例"><a href="#通过注解的方式优化账户案例" class="headerlink" title="通过注解的方式优化账户案例"></a>通过注解的方式优化账户案例</h2><ol><li>修改配置文件约束</li></ol><p>bean.xml</p><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd"></beans></p><pre><code>&lt;context:annotation-config/&gt;&lt;!--告知spring在创建容器时要扫描的包--&gt;&lt;context:component-scan base-package="com.sqtian"&gt;&lt;/context:component-scan&gt;&lt;!--配置QueryRunner,如果用单例时,一个要用,另一个可能还没用完,线程受到影响.因此要用多例--&gt;&lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt;    &lt;!--注入数据源--&gt;    &lt;constructor-arg name="ds" ref="dataSource"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--配置数据源连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;    &lt;!--配置连接数据库的必备信息--&gt;    &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;    &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC"&gt;&lt;/property&gt;    &lt;property name="user" value="root"&gt;&lt;/property&gt;    &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><hr><ol start="2"><li>给实现类添加注解</li></ol><p>/**</p><ul><li>账户的业务层实现类</li><li>/</li></ul><p>@Service(“accountService”)<br>public class AccountServiceImpl implements IAccountService {</p><pre><code>//只有一个需要注入，可以用autowired注解，通过注解的方式注入可以不需要set方法@Autowiredprivate IAccountDao accountDao;public List&lt;Account&gt; findAllAccount() {    return accountDao.findAllAccount();}public Account findAccountById(Integer accountId) {    return accountDao.findAccountById(accountId);}public void saveAccount(Account account) {    accountDao.saveAccount(account);}public void updateAccount(Account account) {    accountDao.updateAccount(account);}public void deleteAccount(Integer accountId) {    accountDao.deleteAccount(accountId);}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><p>/**</p><ul><li>持久层实现类</li><li></li><li>/</li></ul><p>@Repository(“accountDao”)<br>public class AccountDaoImpl implements IAccountDao {</p><pre><code>@Autowiredprivate QueryRunner runner;public List&lt;Account&gt; findAllAccount() {    try {        return runner.query("select * from account",new BeanListHandler&lt;Account&gt;(Account.class));    } catch (Exception e) {        throw new RuntimeException(e);    }}public Account findAccountById(Integer accountId) {    try {        return runner.query("select * from account where id = ?",new BeanHandler&lt;Account&gt;(Account.class),accountId);    } catch (Exception e) {        throw new RuntimeException(e);    }}public void saveAccount(Account account) {    try {        runner.update("insert into account(name,balance,uid)values(?,?,?)",account.getName(),account.getBalance(),account.getUid());    } catch (Exception e) {        throw new RuntimeException(e);    }}public void updateAccount(Account account) {    try {        runner.update("update account set name=?,balance=?,uid = ? where id = ?",account.getName(),account.getBalance(),account.getUid(),account.getId());    } catch (Exception e) {        throw new RuntimeException(e);    }}public void deleteAccount(Integer accountId) {    try {        runner.update("delete from account where id = ?",accountId);    } catch (Exception e) {        throw new RuntimeException(e);    }}</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><h2 id="全注解的方式"><a href="#全注解的方式" class="headerlink" title="全注解的方式"></a>全注解的方式</h2><p>不需要bean.xml了<br>新建配置类</p><p>package config;</p><p>import org.springframework.context.annotation.*;</p><p>/**</p><ul><li>该类是一个配置类，其作用和bean.xml是一样的</li><li>spring中的新注解</li><li>Configuration</li><li>作用: 指定当前类是一个配置类</li><li>细节: 当配置类作为AnnotationConfigApplicationContext对象创建的参数时,该注解可以不写</li><li>ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);</li><li></li><li>ComponentScan</li><li>作用:用于通过注解指定spring在创建容器时要扫描的包</li><li>属性:</li><li>value: 它和basePackages的作用是一样的,都是用于指定创建容器时要扫描的包</li><li>我们使用此注解就等同于在xml中配置了     &lt;context:component-scan base-package=”com.sqtian”&gt;</li><li></li><li>Bean</li><li>作用: 用于把当前方法的返回值作为bean对象存入spring的ioc容器中</li><li>属性:</li><li>name: 用于指定bean的id,当不写时,</li><li>细节:</li><li>当我们使用注解配置方法时,如果方法有参数,spring框架会去容器中查找有没有可用的bean对象.</li><li>查找方式和和Autowired注解的作用一样.</li><li></li><li>Import</li><li>作用: 用于导入其他的配置类</li><li>属性:</li><li>value: 用于指定其他配置类的字节码</li><li>当我们使用Import的注解之后,有Import注解的类叫父配置类,而导入的都是子配置类</li><li></li><li>PropertySource</li><li>作用: 用于指定properties文件的位置</li><li>属性:</li><li>value: 指定文件的名称和路径</li><li>关键字: classpath. 表示到类路径下</li><li>/</li></ul><p>@Configuration<br>@ComponentScan(“com.sqtian”)<br>@Import(JdbcConfig.class)<br>@PropertySource(“classpath:JdbcConfig.properties”)<br>public class SpringConfiguration {</p><pre><code>//用于写公共配置</code></pre><p>}</p><hr><p>package config;</p><p>import com.mchange.v2.c3p0.ComboPooledDataSource;<br>import org.apache.commons.dbutils.QueryRunner;<br>import org.springframework.beans.factory.annotation.Qualifier;<br>import org.springframework.beans.factory.annotation.Value;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Scope;</p><p>import javax.sql.DataSource;</p><p>public class JdbcConfig {</p><pre><code>//注上配置文件里的key@Value("${jdbc.driver}")private String driver;@Value("${jdbc.url}")private String url;@Value("${jdbc.username}")private String username;@Value("${jdbc.password}")private String password;/** * 用于创建一个QueryRunner对象 * 需要实现多例 * @param dataSource * @return */@Bean(name = "runner")@Scope("prototype")public QueryRunner createQueryRunner(@Qualifier("dataSource") DataSource dataSource){  //当有多个数据源时,可以用Qualifier指定id    return new QueryRunner(dataSource);}/** * 创建数据源对象 * @return */@Bean("dataSource")public DataSource creatDatasource(){    try {        ComboPooledDataSource ds = new ComboPooledDataSource();        ds.setDriverClass(driver);        ds.setJdbcUrl(url);        ds.setUser(username);        ds.setPassword(password);        return ds;    } catch (Exception e) {        throw new RuntimeException(e);    }}</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title="}"></a>}</h2><p>JdbcConfig.properties</p><p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC<br>jdbc.username=root<br>jdbc.password=root</p><hr><pre><code>@Testpublic void testFindAll() {    //1. 获取容器</code></pre><p>//        ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);</p><pre><code>    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);    //2. 调用业务层对象    IAccountService as = ac.getBean("accountService",IAccountService.class);    //3. 执行方法    List&lt;Account&gt; accounts = as.findAllAccount();    for (Account account : accounts) {        System.out.println(account);    }}</code></pre><h2 id="结合junit"><a href="#结合junit" class="headerlink" title="结合junit"></a>结合junit</h2><p>/**</p><ul><li>使用junit单元测试</li><li>Spring整合junit的配置</li><li><ol><li>导入spring整合junit的jar</li></ol></li><li><ol start="2"><li>使用junit提供的一个注解把原有的main方法替换了,替换成spring提供的@Runwith</li></ol></li><li><ol start="3"><li>告知spring的运行器,spring和ioc创建是基于xml还是注解的,并且说明位置</li></ol></li><li>@ContextConfiguration</li><li>location: 指定xml文件的位置,加上classpath关键字,表示在类路径下</li><li>classes: 指定注解类所在位置</li><li>当我们使用spring 5.x版本时, junit必须对应4.12及以上</li><li></li><li>/</li></ul><p>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = SpringConfiguration.class)</p><p>//如果用bean.xml配置<br>//@ContextConfiguration(location= “classpath:bean.xml”)<br>public class AccountServiceTest {</p><pre><code>@Autowiredprivate IAccountService as;//创建容器的代码交给spring实现,直接用as@Testpublic void testFindAll() {    //3. 执行方法    List&lt;Account&gt; accounts = as.findAllAccount();    for (Account account : accounts) {        System.out.println(account);    }}</code></pre><h2 id="-6"><a href="#-6" class="headerlink" title="}"></a>}</h2><pre><code>     &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h2 id="开发人员"><a href="#开发人员" class="headerlink" title="开发人员"></a>开发人员</h2><p>public class AccountServiceTest {</p><pre><code>@Autowiredprivate ApplicationContext ac;private IAccountService as;@Beforepublic void init(){    //1. 获取容器    ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);    //2. 调用业务层对象    as = ac.getBean("accountService",IAccountService.class);}@Testpublic void testFindAll() {    //3. 执行方法    List&lt;Account&gt; accounts = as.findAllAccount();    for (Account account : accounts) {        System.out.println(account);    }}</code></pre><h2 id="-7"><a href="#-7" class="headerlink" title="}"></a>}</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaNote_Spring_Day01</title>
      <link href="/2020/06/29/java-kuang-jia/javanote-spring-day01/"/>
      <url>/2020/06/29/java-kuang-jia/javanote-spring-day01/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>Spring框架的概述以及spring中基于XML的IOC配置</p><p>程序的耦合<br>    耦合：程序的依赖关系<br>        包括：<br>            类之间的依赖<br>            方法间的依赖<br>    解耦：<br>        降低程序间的依赖关系<br>    实际开发中：<br>        应该做到，编译期不依赖，运行时才依赖<br>    解耦的思路：<br>        第一步：使用反射来创建对象，而避免使用new关键字<br>        第二步：通过读取配置文件来获取要创建的对象全限定类名</p><a id="more"></a><pre><code>创建Bean对象的工厂Bean：在计算机英语中，有可重用组件的含义JavaBean：用java编写的可重用组件    javabean &gt; 实体类    它就是创建我们的service和dao对象的    第一个: 需要一个配置文件来配置我们的service和dao            配置的内容: 唯一标识=全限定类名(key=value)    第二个: 通过读取配置文件中配置的内容, 反射创建对象    我们的配置文件可以是xml也可以是properties</code></pre><hr><p>用工厂模式创建对象<br>/**</p><ul><li><p>创建Bean对象的工厂</p></li><li><p>/<br>public class BeanFactory {</p><p>  //定义一个Properties对象<br>  private static Properties properties;</p><p>  //定义一个Map,用于存放我们要创建的对象,我们称之为容器<br>  private static Map&lt;String,Object&gt; beans;</p><p>  //使用静态代码块为Properties对象赋值<br>  static{</p><pre><code>  try {      //实例化对象      properties = new Properties();      //获取properties文件的流对象      InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");      properties.load(in);      //实例化容器      beans = new HashMap&lt;String, Object&gt;();      //取出配置文件中所有的Key      Enumeration keys = properties.keys();      //遍历枚举      while(keys.hasMoreElements()){          //取出每个key          String key = keys.nextElement().toString();          //根据key获取value          String beanPath = properties.getProperty(key);          //反射创建对象          Object value = Class.forName(beanPath).newInstance();          //把key和value存入容器中          beans.put(key,value);      }  } catch (Exception e) {      throw new ExceptionInInitializerError("初始化properties失败!");  }</code></pre><p>  }</p><p>  /**</p><ul><li>根据Bean名称获取Bean对象</li><li>@param beanName</li><li>@return</li><li>/</li></ul></li></ul><p>//    public static Object getBean(String beanName){<br>//        Object bean = null;<br>//<br>//        try {<br>//            String beanPath = properties.getProperty(beanName);<br>//            bean = Class.forName(beanPath).newInstance();<br>////每次都会调用默认构造函数创建对象<br>//        } catch (Exception e) {<br>//            e.printStackTrace();<br>//        }<br>//        return bean;<br>//    }</p><pre><code>/** * 静态代码块准备好beans后,每次getBean就简单了 * 现在是单例对象了 */public static Object getBean(String beanName){    return beans.get(beanName);}</code></pre><p>}</p><hr><p>public class AccountDaoImpl implements IAccountDao{<br>    /**<br>     * 账户的持久层实现类<br>     */</p><pre><code>public void saveAccount() {    System.out.println("保存了账户");}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>/**</p><ul><li>账户的业务层实现类</li><li>业务层调用持久层</li><li>/<br>public class AccountServiceImpl implements IAccountService {</li></ul><p>//    private IAccountDao accountDao = new AccountDaoImpl();<br>    private IAccountDao accountDao = (IAccountDao) BeanFactory.getBean(“accountDao”);</p><p>//    private int i = 1;//变量若定义在方法外面,单例对象不会重置变量,想要i不变,则要定义到方法里</p><pre><code>public void saveAccount() {    int i = 1;//一般应用层和持久层中不需要额外定义的变量    accountDao.saveAccount();    System.out.println(i);    i++;}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>/**</p><ul><li><p>模拟一个表现层,用于调用业务层</p></li><li><p>实际开发中是一个servlet</p></li><li><p>/<br>public class Client {</p><p>  public static void main(String[] args) {<br>//        IAccountService as = new AccountServiceImpl();</p><pre><code>  IAccountService as = (IAccountService) BeanFactory.getBean("accountService");  as.saveAccount();</code></pre><p>  }<br>}</p></li></ul><hr><p>accountService = com.sqtian.service.impl.AccountServiceImpl<br>accountDao = com.sqtian.dao.impl.AccountDaoImpl</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC(Inversion of Control): 控制反转, 把创建对象的权力交给框架,是框架的重要特征<br>包括依赖注入和依赖查找<br>明确ioc的作用: 削减计算机程序的耦合(解除我们代码中的依赖关系)</p><p>Spring中的IOC</p><p>/**</p><ul><li><p>模拟一个表现层,用于调用业务层</p></li><li><p>实际开发中是一个servlet</p></li><li><p>获取spring的IOC核心容器，并根据id获取对象</p></li><li></li><li><p>ApplicationContext的三个常用实现类</p></li><li><p>ClassPathXmlApplicationContext: 它可以加载类路径下的配置文件,要求配置文件必须在类路径下.不在的话加载不了</p></li><li><p>FileSystemXmlApplicationContext: 它可以加载磁盘任意路径下的配置文件(必须有访问权限)</p></li><li><p>AnnotationConfigApplicationContext: 它是用于读取注解创建容器的</p></li><li></li><li><p>核心容器的两个接口引发出的问题</p></li><li><p>ApplicationContext:   单例对象适用    实际更多采用此接口</p></li><li><p>它在构建核心容器时,创建对象采取的策略是采用立即加载的方式. 只要一读取完配置文件马上就创建配置文件中的配置的对象</p></li><li><p>BeanFactory:           多例对象适用</p></li><li><p>它在构建核心容器时,创建对象采取的策略是采用延迟加载的方式. 什么时候根据id获取对象了, 什么时候才真正创建对象</p></li><li></li><li><p>/<br>public class Client {</p><p>  public static void main(String[] args) {</p><pre><code>  //1. 获取核心容器对象</code></pre><p>//        ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”); //更常用<br>//        ApplicationContext ac = new FileSystemXmlApplicationContext(“D:\IntelliJ IDEACommunity Edition 2019.3.1\com.sqtian.SpringIOC\src\main\resources\bean.xml”);</p><pre><code>  //-----------BeanFactory------------  Resource resource = new ClassPathResource("bean.xml");  BeanFactory factory = new XmlBeanFactory(resource);  IAccountService as = (IAccountService) factory.getBean("accountService");  IAccountService adao = (IAccountService) factory.getBean("accountDao");  //2. 根据id获取Bean对象</code></pre><p>//        IAccountService as = (IAccountService) ac.getBean(“accountService”);<br>//        IAccountDao adao = ac.getBean(“accountDao”,IAccountDao.class);</p></li></ul><p>//        as.saveAccount();<br>    }<br>}</p><p>bean对象的细节</p><!--?xml version="1.0" encoding="UTF-8"?--><p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd"></beans></p><!--    把对象的创建交给spring来管理--><pre><code>&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt;</code></pre><!--    spring对bean的管理细节    1. 创建bean的三种方式    2. bean对象的作用范围    3. bean对象的生命周期    --><pre><code>&lt;!--创建bean的三种方式--&gt;&lt;!--第一种方式：使用默认构造函数创建    在spring的配置文件中使用bean标签，配以id和class属性后，且没有其他标签时使用第一种。    若类中没有默认构造函数则对象无法创建--&gt;&lt;bean id="accountDao" class="com.sqtian.dao.impl.AccountDaoImpl"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt;&lt;!--第二种方式： 使用普遍工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器--&gt;</code></pre><!--    <bean id="instanceFactory" class="com.sqtian.factory.instanceFactory"></bean>--><!--    <bean id="accountService" factory-bean="instanceFactory" factory-method="getAccountService"></bean>--><pre><code>&lt;!--第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）--&gt;</code></pre><!--    <bean id="accountService" class="com.sqtian.factory.StaticFactory" factory-method="getAccountService"></bean>--><pre><code>&lt;!-- more bean definitions go here --&gt;&lt;!--bean的作用范围调整    bean标签的scope属性：        作用：用于指定bean的作用范围        取值：            singleton：单例的（默认值）            prototype：多例的            request：作用于web应用的请求范围            session：作用于web应用的会话范围            global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session        --&gt;&lt;!--bean对象的生命周期    单例对象        出生：当容器创建时对象出生        活着：只要容器还在，对象一直活着        死亡：容器销毁，对象消亡        总结：单例对象的生命周期和容器相同    多例对象        出生：当我们使用对象时spring框架为我们创建        活着：对象只要是在使用过程中就一直活着        死亡：当对象长时间不用且没有别的对象引用时，由java的垃圾回收器回收        --&gt;</code></pre><hr><p>spring中的依赖注入</p><pre><code>&lt;!--spring中的依赖注入    依赖注入：        Dependency Injection    IOC的作用：        降低程序的耦合（依赖关系）    依赖关系的管理：        以后都交给spring来维护    在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明    依赖关系的维护：        就称之为依赖注入    依赖注入：        能注入的数据有三类：            基本类型和String            其他bean类型（在配置文件中或者注解配置过的bean）            复杂类型/集合类型        注入的方式有三种：            第一种：使用构造函数提供            第二种：使用set方法提供            第三种：使用注解提供--&gt;&lt;!--构造函数的注入:        使用标签: constructor-arg        标签出现的位置: bean标签的内部        标签中的属性            type:用于指定要注入的数据的数据类型, 该数据类型也是构造函数中某个或某些参数的类型            index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值.索引从0开始            name:用于指定给构造函数中指定名称的参数赋值                 常用的            ===================以上三个用于指定给构造函数中哪个参数赋值====================================            value:用于提供基本类型和String类型的数据            ref:用于指定其他的bean类型数据. 他指的就是在spring的IOC核心容器中出现过的bean对象        优势:            在获取bean对象时,注入数据是必须操作,否则对象无法创建成功        弊端:            改变了bean对象的实例化方式,使我们在创建对象时,如果用不到这些数据,也必须提供        --&gt;&lt;bean id="accountService" class="com.sqtian.service.impl.AccountServiceImpl"&gt;</code></pre><!--        <constructor-arg type="java.lang.String" value="test"></constructor-arg>--><pre><code>    &lt;constructor-arg name="name" value="test"&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--配置一个日期对象--&gt;&lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;&lt;!--set方法注入                 更常用    涉及的标签: property    出现位置: bean标签内部    标签属性:        name:用于指定注入时所调用的set方法名称                 常用的        value:用于提供基本类型和String类型的数据        ref:用于指定其他的bean类型数据. 他指的就是在spring的IOC核心容器中出现过的bean对象    优势:        创建对象时没有明确的限制,可以直接使用默认构造函数    弊端:        如果有某个成员必须有值,则获取对象时有可能set方法没有执行--&gt;&lt;bean id="accountService2" class="com.sqtian.service.impl.AccountServiceImpl2"&gt;    &lt;property name="name" value="TEST"&gt;&lt;/property&gt;    &lt;property name="age" value="21"&gt;&lt;/property&gt;    &lt;property name="birthday" ref="now"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--复杂类型/集合类型的注入    用于给List结构集合注入的标签:        list array set    用于给Map结构集合注入的标签:        map props    结构相同,标签可以互换--&gt;&lt;bean id="accountService3" class="com.sqtian.service.impl.AccountServiceImpl3"&gt;    &lt;property name="myStrs"&gt;        &lt;array&gt;            &lt;value&gt;AAA&lt;/value&gt;            &lt;value&gt;BBB&lt;/value&gt;            &lt;value&gt;CCC&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name="myList"&gt;        &lt;list&gt;            &lt;value&gt;AAA&lt;/value&gt;            &lt;value&gt;BBB&lt;/value&gt;            &lt;value&gt;CCC&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name="mySet"&gt;        &lt;set&gt;            &lt;value&gt;AAA&lt;/value&gt;            &lt;value&gt;BBB&lt;/value&gt;            &lt;value&gt;CCC&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;property name="myMap"&gt;        &lt;map&gt;            &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt;            &lt;entry key="testB"&gt;                &lt;value&gt;BBB&lt;/value&gt;            &lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name="myProps"&gt;        &lt;props&gt;            &lt;prop key="testC"&gt;ccc&lt;/prop&gt;            &lt;prop key="testD"&gt;ddd&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><p>public class AccountServiceImpl2 implements IAccountService {</p><pre><code>//如果是经常变化的数据，并不适用于注入的方式private String name;private Integer age;private Date birthday;public void setName(String name) {    this.name = name;}public void setAge(Integer age) {    this.age = age;}public void setBirthday(Date birthday) {    this.birthday = birthday;}//    private IAccountDao accountDao = new AccountDaoImpl();public void saveAccount() {</code></pre><p>//        accountDao.saveAccount();<br>        System.out.println(“service中的saveAccount方法执行了。。。”+name+”,”+age+”,”+birthday);</p><pre><code>}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>public class AccountServiceImpl3 implements IAccountService {</p><pre><code>//如果是经常变化的数据，并不适用于注入的方式private String[] myStrs;private List&lt;String&gt; myList;private Set&lt;String&gt; mySet;private Map&lt;String,String&gt; myMap;private Properties myProps;public void setMyStrs(String[] myStrs) {    this.myStrs = myStrs;}public void setMyList(List&lt;String&gt; myList) {    this.myList = myList;}public void setMySet(Set&lt;String&gt; mySet) {    this.mySet = mySet;}public void setMyMap(Map&lt;String, String&gt; myMap) {    this.myMap = myMap;}public void setMyProps(Properties myProps) {    this.myProps = myProps;}public void saveAccount() {    System.out.println(Arrays.toString(myStrs));    System.out.println(myList);    System.out.println(mySet);    System.out.println(myMap);    System.out.println(myProps);}</code></pre><p>}</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaWebNote06_Http&#39;</title>
      <link href="/2020/05/13/java-ji-chu/javawebnote06-http/"/>
      <url>/2020/05/13/java-ji-chu/javawebnote06-http/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaWebNote05_Tomcat&#39;</title>
      <link href="/2020/05/13/java-ji-chu/javawebnote05-tomcat/"/>
      <url>/2020/05/13/java-ji-chu/javawebnote05-tomcat/</url>
      
        <content type="html"><![CDATA[<p>Tomcat相关知识</p><a id="more"></a><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><ol><li><p>web相关概念回顾</p><ol><li><p>软件架构</p><ol><li><p>C/S：客户端/服务器端</p></li><li><p>B/S：浏览器/服务器端</p></li></ol></li><li><p>资源分类</p><ol><li><p>静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源，静态资源可以直接被浏览器解析<br> 如：html，css，JavaScript</p></li><li><p>动态资源：每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，再返回给浏览器<br> 如：servlet/jsp，php，asp…..</p></li></ol></li><li><p>网络通信三要素</p><ol><li>IP: 电子设备(计算机)在网络中的唯一标识. </li><li>端口: 应用程序在计算机中的唯一标识. 0-65536</li><li>传输协议: 规定了数据传输的规则<ol><li>基础协议:<ol><li>tcp: 安全协议,三次握手. 速度稍慢</li><li>udp: 不安全协议, 速度快</li></ol></li></ol></li></ol></li></ol></li><li><p>web服务器软件</p><ul><li>服务器: 安装了服务器软件的计算机</li><li>服务器软件: 接受用户的请求,处理请求,做出响应</li><li>web服务器软件: 可以部署web项目,让用户通过浏览器来访问这些项目<br>  也称作web容器,动态资源一定要依赖web服务器软件运行</li><li>常见的java相关的web服务器软件:<ul><li>webLogic: oracle公司,大型JavaEE服务器,支持所有的JavaEE规范,收费</li><li>webSphere: IBM公司,大型JavaEE服务器,支持所有的JavaEE规范,收费</li><li>JBOSS: JBOSS公司,大型JavaEE服务器,支持所有的JavaEE规范,收费</li><li>TomCat: Apache基金组织, 中小型的JavaEE服务器,仅仅支持少量的JavaEE规范. 开源免费</li></ul></li></ul></li></ol><pre><code>* JavaEE: java语言在企业级开发中使用的技术规范的总和,一共规定了13项大的规范* Tomcat: web服务器软件    目录结构        bin：可执行文件        conf： 配置文件        lib：依赖jar包        logs：日志文件        temp：临时文件        webapps：存放web项目        work：存放运行时的数据    启动：        可能遇到的问题            1. 一闪而过：                环境变量没有正确配置            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    cmd netstat -ano                2. 温柔：修改自身端口号                    D:\Tomcat\apache-tomcat-8.5.54\conf\server.xml                    一般会将tomcat的默认端口号修改为80,因为80端口号是http协议的默认端口号                        好处: 在访问时,就不用输入端口号了    关闭:        1. 正常关闭:            1. bin/shutdown            2. ctrl+c        2. 强制关闭:            x    部署:        1. 直接将项目放到webapps目录下即可            http://localhost/hello/HelloWorld.html            * 简化部署:                 将项目打包成war包,war包拷贝过去会自动解压缩        2. 配置conf/server.xml文件            在&lt;Host&gt;标签体中配置            &lt;Context docBase="D:\hello" path="/hehe" /&gt;            * docBase: 项目存放路径            * path: 虚拟目录            http://localhost/hehe/HelloWorld.html            缺点: 任意破坏全局的tomcat配置文件,不推荐        3. 在D:\Tomcat\apache-tomcat-8.5.54\conf\Catalina\localhost创建任意名称的xml文件,在文件中编写            &lt;Context docBase="D:\hello" /&gt;            * 虚拟目录就是xml文件的名称            http://localhost/bbb/HelloWorld.html        * 静态项目和动态项目            *目录结构                *java动态项目的目录结构                    -- 项目的根目录                        -- WEB-INF目录:                            -- web.xml: web项目的核心配置文件                            -- classes目录: 放置字节码文件的目录                            -- lib目录:防止依赖的jar包        * 将tomcat集成到IDEA中,并且创建javaEE的项目,部署项目</code></pre><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><pre><code>1. 概念: server applet, 运行在服务器端的小程序    * servlet就是一个接口,定义了java类被浏览器访问到(tomcat识别)的规则    * 自定义一个类,实现Servlet接口,复写方法.2. 快速入门:    1. 创建JavaEE项目    2. 定义一个类,实现Servlet接口        public class ServletDemo01 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet        web.xml3. 执行原理    1. 当服务器接收到客户端浏览器的请求后,会解析请求URL路径,获取访问的Servlet的资源路径    2. 查找web.xml文件,是否有对应的&lt;url-pattern&gt;标签体内容    3. 如果有,则再找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存,并且创建其对象    5. 调用其方法4. Servlet中的方法    * init()        初始化方法,在Servlet被创建时执行,只会执行一次    * service()        提供服务的方法,每一次Servlet被访问时执行. 访问一次执行一次    * destroy()        销毁方法,在服务器正常关闭时执行,执行一次.     * getServletConfig()        获取Servlet的配置对象    * getServletInfo()        获取Servlet的一些信息,版本,作者等等    生命周期        1. 被创建: 执行init方法, 只执行一次        一般用于加载资源            默认情况下,第一次被访问时,Servlet被创建            可以配置web.xml改变执行Servlet的创建时机                在&lt;servlet&gt;标签下配置                1. 第一次被访问时创建                    &lt;load-on-startup&gt;的值为负数                2. 在服务器启动时创建                    &lt;load-on-startup&gt;的值为0或正整数            Servlet的init方法只执行一次,说明一个Servlet在内存中只存在一个对象,Servlet是单例的                多个用户同时访问时,可能存在线程安全问题                解决方法: 尽量不要再servlet中定义成员变量, 使用局部变量. 即使定义了成员变量,也不要对其修改值        2. 提供服务: 执行service方法, 可执行多次            每次访问Servlet时都会被调用一次        3. 被销毁: 执行destroy方法, 只执行一次            Servlet被销毁时执行,服务器关闭时Servlet被销毁            只有服务器正常关闭,才会执行destroy,在被销毁之前执行,一般用于释放资源5. Servlet3.0    好处        * 支持注解配置,可以不需要web.xml了        步骤:        1. 创建JavaEE项目, 选择Servlet的版本3.0以上, 可以不创建web.xml        2. 定义一个类实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解,进行配置            WebServlet("虚拟资源路径")6. IDEA与tomcat的相关配置    1. IDEA会为每一个tomcat部署的项目建立一份配置文件        查看控制台的log: Using CATALINA_BASE: " "        后面的目录打开    2. 工作空间项目和tomcat部署的web项目        * tomcat真正访问的是"tomcat部署的web项目",对应着"工作空间项目"的web目录下的所有资源        * WEB-INFO目录下的资源不能被浏览器直接访问, 所以文件写在web目录下,不要写在WEB-INFO下        * 断点调试: 打上断点不能直接run,要使用debug启动</code></pre><p>Servlet 体系结构<br>    Servlet –接口</p><pre><code>GenericServlet --实现类Servlet接口的抽象类    将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象方法    将来定义Servlet类时,可以继承GenericServlet,实现service()方法即可HttpServlet --抽象类    直接实现servlet的service需要先判断请求方式    String method = req.getMethod();    if("GET".equals(method)){        //get方式获取数据    }else if ("POST".equals(method)){        //post方式获取数据    }    HttpServlet是对http协议的一种封装,简化操作    不再复写service,而是复写doGet/doPost方法推荐使用HttpServlet</code></pre><p>Servlet相关配置<br>    1. urlpartten:Servlet访问路径<br>        1. 一个Servlet可以定义多个访问路径: @WebServlet({“/d4”,”/dd4”,”/ddd4”})<br>        2. 路径定义规则:<br>            1. /xxx<br>            2. /xxx/xxx: 多层路径,目录结构<br>            3. *.do  :localhost/xxx.do</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaWebNote04_XML&#39;</title>
      <link href="/2020/05/11/java-ji-chu/javawebnote04-xml/"/>
      <url>/2020/05/11/java-ji-chu/javawebnote04-xml/</url>
      
        <content type="html"><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ol><li><p>概念：Extensible Markup Language 可扩展标记语言<br> 可扩展：标签都是自定义的</p><p> 功能：<br> 存储数据</p><pre><code> 1. 配置文件 2. 在网络中传输</code></pre><p> 与HTML的区别</p><ol><li>xml标签都是自定义的，html标签是预定义的</li><li>xml的语法严格，html语法松散</li><li>xml是存储数据的，html是展示数据的<a id="more"></a>    </li></ol></li><li><p>语法<br> 基本语法：</p><pre><code> 1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. 有且仅有一个根标签 4. 属性必须用引号引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写</code></pre><p> 快速入门：</p></li></ol><!--?xml version='1.0' ?--><users>    <user id="1">        <name>zhangsan</name>        <age>23<age>        <gender>male</gender>    </age></age></user><pre><code>&lt;user id='2'&gt;    &lt;name&gt;lisi&lt;/name&gt;    &lt;age&gt;24&lt;age&gt;    &lt;gender&gt;male&lt;/gender&gt;&lt;/user&gt;</code></pre></users><pre><code>组成部分：    1. 文档声明:        1. 格式:&lt;?xml 属性列表 ?&gt;        2. 属性列表:            *version: 版本号, 必须的属性            *encoding: 编码格式, 告知解析引擎当前文档使用的字符集            *standalone: 是否独立,yes 不依赖其他文件 no 依赖其他文件    2. 指令: 结合css的        *&lt;?xml-stylesheet type="text/css" href="a.css" ?&gt;    3. 标签: 标签名称自定义的    4. 属性:        id属性值唯一    5. 文本:        CDATA区:在该区域中的数据会被原样展示            格式:&lt;![CDATA[ 数据 ]]&gt;约束:    约束文档:规定xml文档的书写规则    作为框架的使用者,能够在xml中引入约束文档,能够简单的读懂约束文档    分类:        1. DTD: 一种简单的约束技术            引入DTD文档到xml文档中            内部dtd: 将约束规则定义在xml文档中            外部dtd: 将约束的规则定义在外部dtd文档中                本地: &lt;!DOCTYPE 根标签名 SYSTEM "dtd文件的位置"&gt;                网络: &lt;!DOCTYPE 根标签名 PUBLIC "dtd文件名字" "dtd文件的位置URL"&gt;        2. Schema: 一种复杂的约束技术            引入:                1. 填写xml文档的根元素                2. 引入xsi前缀                3. 引入xsd文件命名空间                4. 为每一个xsd约束声明一个前缀,作为标识</code></pre><ol start="3"><li>解析<br>操作xml文档,将文档中的数据读取到内存中</li></ol><p>*操作xml文档<br>    1. 解析(读取): 将文档中的数据读取到内存中<br>    2. 写入: 将内存中的数据保存到xml文档中,持久化的存储</p><p>*解析xml的方式<br>    1. DOM: 将标记语言文档一次性加载进内存,在内存中会形成一棵DOM树<br>        优点: 操作方便,可以对文档进行CRUD所有操作<br>        缺点: 占内存<br>    2. SAX: 逐行读取,基于事件驱动<br>        优点: 不占内存<br>        缺点: 只能读取,不能增删改</p><p>*xml常见解析器<br>    1. JAXP: sun公司提供,支持dom和sax两种思想,基本没人用<br>    2. DOM4J: 一款优秀的解析器<br>    3. Jsoup: html解析器,也可以解析xml<br>    4. PULL: Android操作系统内置解析器,sax方式的</p><p>*Jsoup示例<br>步骤:<br>    1. 导入jar包<br>    2. 获取Document对象,根据xml文档获取<br>        获取student.xml的path<br>        String path = JsoupDemo1.class.getClassLoader().getResource(“student.xml”).getPath();<br>        Document document = Jsoup.parse(new File(path),”utf-8”);<br>    3. 获取对象标签Element对象<br>        Elements elements = document.getElementsByTag(“name”)<br>        获取第一个name的Element对象<br>        Element element = elements.get(0);<br>    4. 获取数据<br>        String name = element.text();<br>        sout(name);</p><p>对象的使用:<br>    1. jSOUP: 工具类,可以解析html或xml文档,返回Document<br>    2. Document: 文档对象. 代表内存中的dom树<br>    3. Elements: 元素Element对象的集合,可以当作ArrayList<element> 来使用<br>    4. Element: 元素对象<br>    5. Node: 节点对象</element></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_Mybatis_Day04&#39;</title>
      <link href="/2020/05/09/java-kuang-jia/javanote-mybatis-day04/"/>
      <url>/2020/05/09/java-kuang-jia/javanote-mybatis-day04/</url>
      
        <content type="html"><![CDATA[<h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p>mybatis的缓存和注解开发<br>mybatis中的加载时机(查询的时机)<br>mybatis中的一级缓存和二级缓存<br>mybatis的注解开发<br>单表CRUD<br>多表查询</p><a id="more"></a><ol><li><p>mybatis延迟加载<br> 问题：在一对多中，当我们有一个用户，他有100个账户</p><pre><code>   在查询用户的时候要不要把关联的账户查出来   在查询账户的时候要不要把关联的用户查出来   在查询用户时，用户下的账户信息应该是什么时候使用什么时候查询   在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来</code></pre></li></ol><p>什么是延迟加载<br>    在真正使用数据时才发起查询，不用的时候不查询，按需加载<br>什么是立即加载<br>    不管用不用，只要一调用方法马上发起查询</p><p>在对应的四种表关系里<br>    一对多，多对多：通常情况下我们都是采用延迟加载</p><pre><code>    &lt;collection property="accounts" ofType="account" select="com.sqtian.dao.IAccountDao.findAccountByUid" column="id"&gt;&lt;/collection&gt;配置findAccountByUid方法，findAll方法里只写select * from account，延迟开关打开时才会继续查询findAccountByUid&lt;select id="findAccountByUid" resultType="account"&gt;    select * from account where uid = #{uid}&lt;/select&gt;&lt;!--配置延迟开关的参数--&gt;&lt;settings&gt;    &lt;setting name="lazyLoadingEnabled" value="true"/&gt;    &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;多对一，一对一：通常情况下我们都是采用立即加载</code></pre><ol start="2"><li><p>Mybatis中的缓存<br> 什么是缓存：存在于内存中的临时数据<br> 为什么使用缓存：减少与数据库的交互次数，提高执行效率<br> 适用于缓存：</p><pre><code> 经常查询并且不经常改变 数据正确与否对最终结果影响不大</code></pre><p> 不使用于缓存：</p><pre><code> 经常改变的数据 数据得正确与否对最终结果影响很大 例如：商品的库存，银行的汇率，股市的牌价</code></pre><p> 一级缓存</p><pre><code> 它指的是Mybatis中SqlSession对象的缓存 当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中 该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用 当SqlSession对象消失时，mybatis的一级缓存也就消失了</code></pre><p> 二级缓存</p><pre><code> 它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存 使用二级缓存：     第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）&lt;setting name = "cacheEnabled" value="true"/&gt;     第二步: 让当前的映射文件支持二级缓存(在IUserDao.xml中配置)&lt;cache/&gt;     第三步: 让当前的操作支持二级缓存(在select标签中配置)&lt;select useCache = "true"/&gt;     存放在二级缓存的内容是数据,而不是对象.谁要用,就把数据拿来新建一个用户对象</code></pre></li></ol><h2 id="Mybatis注解开发"><a href="#Mybatis注解开发" class="headerlink" title="Mybatis注解开发"></a>Mybatis注解开发</h2><p>注解与IUserDao.xml不能同时使用<br>jdbcConfig.properties</p><p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC&amp;characterEncoding=utf8<br>jdbc.username=root<br>jdbc.password=root</p><hr><p>CRUD注解：不用再去xml里操作</p><p>/**</p><ul><li><p>在mybatis中CRUD一共有四个注解</p></li><li><p>@Select @Insert @Update @Delete</p></li><li><p>/<br>public interface IUserDao {</p><p>  /**</p><ul><li><p>查询所有用户</p></li><li><p>@return</p></li><li><p>/<br>@Select(“select * from hero”)<br>List<user> findAll();</user></p><p>/**</p></li><li><p>保存用户</p></li><li><p>/<br>@Insert(“insert into hero values(#{id},#{name},#{age},#{weight},#{height})”)<br>void saveUser(User user);</p><p>/**</p></li><li><p>更新用户</p></li><li><p>/<br>@Update(“update hero set name=#{name},age=#{age},weight=#{weight},height=#{height} where id=#{id}”)<br>void updateUser(User user);</p><p>/**</p></li><li><p>删除用户</p></li><li><p>/<br>@Delete(“delete from hero where id=#{id}”)<br>void deleteUser(Integer uid);<br>}</p></li></ul></li></ul><hr><p>public class AnnotationCRUDTest {</p><pre><code>private InputStream in;private SqlSession sqlSession;private IUserDao userDao;/** * 测试查询所有 */@Before //用于在测试方法执行之前执行public void init() throws Exception{    //1.读取配置文件,生成字节输入流    in = Resources.getResourceAsStream("SqlMapConfig.xml");    //2.获取SqlSessionFactory    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);    //3.获取sqlSession对象    sqlSession = factory.openSession();    //4.获取dao代理对象    userDao = sqlSession.getMapper(IUserDao.class);}@After //用于在测试方法执行之后执行public void destroy() throws IOException {    //提交事务    sqlSession.commit();    //6.关闭资源    sqlSession.close();    in.close();}@Testpublic void testSave(){    User user = new User();    user.setId(14);    user.setName("xx");    user.setAge(18);    user.setWeight(90);    user.setHeight(165);    userDao.saveUser(user);}@Testpublic void testUpdate(){    User user = new User();    user.setId(14);    user.setName("叶雨时");    user.setAge(21);    user.setWeight(126);    user.setHeight(180);    userDao.updateUser(user);}@Testpublic void testDelete(){    userDao.deleteUser(14);    List&lt;User&gt; users = userDao.findAll();    for (User u : users) {        System.out.println(u);    }}</code></pre><p>}</p><hr><p>result注解：</p><pre><code>@Select("select * from hero")@Results(id = "userMap",value={    @Result(id=true,column = "id",property = "id"),    @Result(id=false,column = "name",property = "name"),    @Result(id=false,column = "age",property = "age"),    @Result(id=false,column = "weight",property = "weight"),    @Result(id=false,column = "height",property = "height")})List&lt;User&gt; findAll();@Insert("insert into hero values(#{id},#{name},#{age},#{weight},#{height})")@ResultMap("userMap")void saveUser(User user);</code></pre><p>一对一：一个账户只有一个用户<br>    1. 在Account中添加User属性<br>    2. 在注解中添加映射<br>    3. 用User的FindById找到User</p><hr><pre><code>//多对一(mybatis中称之为一对一)的映射: 一个账户只能属于一个用户private User user;public User getUser() {    return user;}public void setUser(User user) {    this.user = user;}</code></pre><hr><pre><code>@Select("select * from hero where id=#{id}")@ResultMap("userMap")User findById(Integer uid);</code></pre><hr><p>public interface IAccountDao  {</p><pre><code>/** * 查询所有账户,并且获取每个账户所属的用户信息 * 1对1,使用立即加载 */@Select("select * from account")@Results(id = "accountMap",value = {    @Result(id=true,column = "id",property = "id"),    @Result(column = "uid",property = "uid"),    @Result(column = "name",property = "name"),    @Result(column = "balance",property = "balance"),    @Result(column = "uid",property = "user",one=@One(select="com.sqtian.dao.IUserDao.findById",fetchType = FetchType.EAGER))})List&lt;Account&gt; findAll();</code></pre><p>}</p><hr><pre><code>@Testpublic void testFindAll(){    List&lt;Account&gt; accounts = accountDao.findAll();    for (Account account : accounts) {        System.out.println("---每一个账户的信息---");        System.out.println(account);        System.out.println(account.getUser());    }}</code></pre><hr><p>一对多：一个用户可以有多个账户<br>    1. 在用户里添加accounts属性<br>    2. IUserDao的注解里添加映射<br>    3. 利用account的方法findByUid</p><pre><code>//1对多关系映射,一个用户对应多个账户private List&lt;Account&gt; accounts;public List&lt;Account&gt; getAccounts() {    return accounts;}public void setAccounts(List&lt;Account&gt; accounts) {    this.accounts = accounts;}</code></pre><hr><pre><code>/** * 查询所有用户 * 一对多,使用延迟加载 * @return */@Select("select * from hero")@Results(id = "userMap",value={    @Result(id=true,column = "id",property = "id"),    @Result(id=false,column = "name",property = "name"),    @Result(id=false,column = "age",property = "age"),    @Result(id=false,column = "weight",property = "weight"),    @Result(id=false,column = "height",property = "height"),    @Result(property = "accounts",column = "id",        many=@Many(select = "com.sqtian.dao.IAccountDao.findByUid",fetchType = FetchType.LAZY))})List&lt;User&gt; findAll();</code></pre><hr><pre><code>/** * 根据用户id查询账户信息 * @param uid 用户id * @return */@Select("select * from account where uid=#{id}")List&lt;Account&gt; findByUid(Integer uid);</code></pre><hr><pre><code>@Testpublic void testFindAll(){    List&lt;User&gt; users = userDao.findAll();    for (User user : users) {        System.out.println("---每一个用户信息---");        System.out.println(user);        System.out.println(user.getAccounts());    }}</code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_Mybatis_Day03&#39;</title>
      <link href="/2020/05/09/java-kuang-jia/javanote-mybatis-day03/"/>
      <url>/2020/05/09/java-kuang-jia/javanote-mybatis-day03/</url>
      
        <content type="html"><![CDATA[<h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><p>mybatis的深入和多表<br>mybatis连接池<br>mybatis事务控制及设计方法<br>mybatis的多表查询</p><a id="more"></a><ol><li><p>实际开发中都会使用到连接池，它可以减少我们获取连接所消耗的时间<br> 连接池就是用于存储连接的一个容器，容器其实就是一个集合对象，待机和必须是线程安全的，不能两个线程拿到统一连接<br> 该集合还必须实现队列的特性：先进先出</p></li><li><p>mybatis中的连接池<br> mybatis连接池提供了3种方式的配置：</p><pre><code> 配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签,type属性表示采用何种连接池方式 type属性:     POOLED  采用传统的javax.sql.DataSource规范中的连接池,mybatis中有针对规范的实现     UNPOOLED  采用传统的获取连接方式,虽然也实现Javax.sql.DataSource接口,但是并没有使用池的思想     JNDI    采用服务器提供的JNDI技术实现,来获取DataSource对象,不同的服务器所能拿到的DataSource是不一样的             注意:如果不是web或者maven的war工程,是不能使用的</code></pre></li></ol><ol start="3"><li><p>mybatis中的事务<br> 什么是事务<br> 事务的四大特性ACID<br> 不考虑隔离性会产生的3个问题<br> 解决方法:四种隔离级别</p><p> 它是通过sqlsession对象的comit方法和rollback方法实现事务的提交和回滚</p></li></ol><pre><code>sqlSession = factory.openSession(true);//可以自动提交,不用再写sqlSession.commit()一个事务中要实现多次交互时,不推荐自动提交,控制不住</code></pre><p>mybatis中的动态sql语句</p><pre><code>1. if标签/** * 根据传入参数条件查询用户 * @param user 查询的条件，有可能有用户名，有可能有年龄等等 * */List&lt;User&gt; findUserByCondition(User user);</code></pre><hr><pre><code>&lt;!--根据条件查询用户--&gt;&lt;select id="findUserByCondition" parameterType="com.sqtian.domain.User" resultType="com.sqtian.domain.User"&gt;    select * from hero where 1=1    &lt;if test="name != null"&gt;        and name = #{name}    &lt;/if&gt;    &lt;if test="age != null"&gt;        and age = #{age}    &lt;/if&gt;&lt;/select&gt;</code></pre><hr><p>或者<br>    <!--根据条件查询用户--><br>    <select id="findUserByCondition" parametertype="com.sqtian.domain.User" resulttype="com.sqtian.domain.User">        select * from hero                                    and name = #{name}                                        and age = #{age}                        </select></p><hr><pre><code>@Testpublic void testFindByCondition(){    User user = new User();    user.setName("new");    user.setAge(18);    List&lt;User&gt; users = userDao.findUserByCondition(user);    for (User u : users) {        System.out.println(u);    }}</code></pre><hr><pre><code>2. 多个参数</code></pre><p>如 select * from hero where id in(1,3,5); 如何实现<br>利用queryVo 添加    private List<integer> ids;</integer></p><pre><code>/** * 根据QueryVo中的id集合查询用户 * * */List&lt;User&gt; findUserInIds(QueryVo vo);</code></pre><hr><pre><code>&lt;!--根据queryVo中的id集合查询--&gt;&lt;select id="findUserInIds" resultType="User" parameterType="QueryVo"&gt;    select * from hero    &lt;where&gt;        &lt;if test="ids != null and ids.size()&gt;0"&gt;            &lt;foreach collection="ids" open="and id in(" close=")" item="id" separator=","&gt;                #{id}            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;</code></pre><hr><pre><code>@Testpublic void testFindInIds(){    //根据queryVo对象的条件来查询    QueryVo queryVo = new QueryVo();    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    list.add(1);    list.add(3);    list.add(5);    queryVo.setIds(list);    List&lt;User&gt; users = userDao.findUserInIds(queryVo);    for (User u : users) {        System.out.println(u);    }}</code></pre><hr><p>4.mybatis中的多表查询<br>    表之间的关系有几种:<br>        一对多<br>        多对一<br>        一对一<br>        多对多</p><pre><code>示例: 用户和账户    一个用户可以有多个账户    一个账户只能属于一个用户(多个账户也可以属于同一个用户)步骤:     1. 建立两个表: 用户表,账户表        让用户表和账户表之间具备一对多的关系: 需要使用外键在账户表中添加    2. 建立两个实体类: 用户实体类和账户实体类        让用户和账户的实体类能体现出来一对多的关系    3. 建立两个配置文件        用户的配置文件        账户的配置文件    4. 实现配置:        当我们查询用户时,可以同时得到用户下所包含的账户信息        当我们查询账户时,可以同时得到账户的所属用户信息    select h.*,a.id as aid,a.uid,a.balance from account a,hero h where h.id=a.uid;</code></pre><h2 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h2><p>public class Account implements Serializable {</p><pre><code>private Integer id;private Integer uid;private String name;private Double balance;@Overridepublic String toString() {    return "Account{" +        "id=" + id +        ", uid=" + uid +        ", name='" + name + '\'' +        ", balance=" + balance +        '}';}public Integer getId() {    return id;}public void setId(Integer id) {    this.id = id;}public Integer getUid() {    return uid;}public void setUid(Integer uid) {    this.uid = uid;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public Double getBalance() {    return balance;}public void setBalance(Double balance) {    this.balance = balance;}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>public class AccountUser extends Account {<br>    private String name;<br>    private Integer age;</p><pre><code>@Overridepublic String toString() {    return super.toString()+"     AccountUser{" +        "name='" + name + '\'' +        ", age=" + age +        '}';}@Overridepublic String getName() {    return name;}@Overridepublic void setName(String name) {    this.name = name;}public Integer getAge() {    return age;}public void setAge(Integer age) {    this.age = age;}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>public interface IAccountDao {<br>    /**<br>     * 查询所有账户,同时还有获取当前账户的所属用户信息<br>     * @return<br>     */<br>    List<account> findAll();</account></p><pre><code>/** * 查询所有账户,并且带有用户名称和地址信息 * @return */List&lt;AccountUser&gt; findAllAccounts();</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><!--?xml version="1.0" encoding="UTF-8"?--><mapper namespace="com.sqtian.dao.IAccountDao"><pre><code>&lt;!--配置查询所有  com.sqtian.domain.--&gt;&lt;select id="findAll" resultType="Account"&gt;    select * from account;&lt;/select&gt;&lt;!--配置查询所有--&gt;&lt;select id="findAllAccounts" resultType="AccountUser"&gt;    select a.*,h.name,h.age from account a ,hero h where h.id=a.uid;&lt;/select&gt;</code></pre></mapper>-------------------------------------------------------------------------------------<p>实际上常用的方法</p><p>从表实体应该包含一个主表实体的对象引用<br>在封装account时希望同时也将user封装</p><p>public class Account</p><pre><code>//从表实体应该包含一个主表实体的对象引用private User user;public User getUser() {    return user;}public void setUser(User user) {    this.user = user;}</code></pre><hr><mapper namespace="com.sqtian.dao.IAccountDao"><pre><code>&lt;!--定义封装account和user的resultMap--&gt;&lt;resultMap id="accountUserMap" type="account"&gt;    &lt;id property="id" column="aid"&gt;&lt;/id&gt;    &lt;result property="uid" column="uid"&gt;&lt;/result&gt;    &lt;result property="balance" column="balance"&gt;&lt;/result&gt;    &lt;!--一对一的关系映射,配置封装user的内容--&gt;    &lt;association property="user" column="uid" javaType="com.sqtian.domain.User"&gt;        &lt;id property="id" column="id"&gt;&lt;/id&gt;        &lt;result property="name" column="name"&gt;&lt;/result&gt;        &lt;result property="age" column="age"&gt;&lt;/result&gt;        &lt;result property="weight" column="weight"&gt;&lt;/result&gt;        &lt;result property="height" column="height"&gt;&lt;/result&gt;    &lt;/association&gt;&lt;/resultMap&gt;&lt;!--配置查询所有  resultMap引用映射--&gt;&lt;select id="findAll" resultMap="accountUserMap"&gt;</code></pre><!--        select * from account;--><pre><code>    select h.*,a.id as aid,a.uid,a.balance from account a,hero h where h.id=a.uid;&lt;/select&gt;</code></pre></mapper>--------------------------------------------------------<pre><code>@Testpublic void testFindAll(){    //5.执行查询所有的方法    List&lt;Account&gt; accounts = accountDao.findAll();    for (Account account : accounts) {        System.out.println("每一个账户的信息");        System.out.println(account);        System.out.println(account.getUser());    }}</code></pre><hr><h2 id="一对多查询操作"><a href="#一对多查询操作" class="headerlink" title="一对多查询操作"></a>一对多查询操作</h2><p>select * from hero h left outer join account a on h.id=a.uid</p><hr><p>public class User<br>    //一对多关系映射,主表实体应该包含从表实体的集合引用<br>    private List<account> accounts;</account></p><pre><code>public List&lt;Account&gt; getAccounts() {    return accounts;}public void setAccounts(List&lt;Account&gt; accounts) {    this.accounts = accounts;}</code></pre><hr><p>IUserDao</p><pre><code>&lt;resultMap id="userAccountMap" type="user"&gt;    &lt;id property="id" column="id"&gt;&lt;/id&gt;    &lt;result property="name" column="name"&gt;&lt;/result&gt;    &lt;result property="age" column="age"&gt;&lt;/result&gt;    &lt;result property="weight" column="weight"&gt;&lt;/result&gt;    &lt;result property="height" column="height"&gt;&lt;/result&gt;    &lt;!--配置user对象中accounts集合的映射--&gt;    &lt;collection property="accounts" ofType="Account"&gt;        &lt;id property="id" column="aid"&gt;&lt;/id&gt;        &lt;result property="uid" column="uid"&gt;&lt;/result&gt;        &lt;result property="balance" column="balance"&gt;&lt;/result&gt;    &lt;/collection&gt;&lt;/resultMap&gt;&lt;!--配置查询所有  com.sqtian.domain.--&gt;&lt;select id="findAll" resultMap="userAccountMap"&gt;</code></pre><!--        select * from hero;--><pre><code>    select * from hero h left outer join account a on h.id=a.uid&lt;/select&gt;</code></pre><hr><pre><code>@Testpublic void testFindAll(){    //5.执行查询所有的方法    List&lt;User&gt; users = userDao.findAll();    for (User user : users) {        System.out.println("---每个用户的信息---");        System.out.println(user);        System.out.println(user.getAccounts());    }}</code></pre><hr><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>示例: 用户和角色<br>    一个用户可以有多个角色<br>    一个角色可以赋予多个用户</p><pre><code>步骤:     1. 建立两个表: 用户表,角色表        让用户表和角色表之间具备多对多的关系: 需要使用中间表，中间表中包含各自的主键，在中间表中是外键    2. 建立两个实体类: 用户实体类和角色实体类        让用户和角色的实体类能体现出来多对多的关系        各自包含对方一个集合的引用    3. 建立两个配置文件        用户的配置文件        角色的配置文件    4. 实现配置:        当我们查询用户时,可以同时得到用户下所包含的角色信息        当我们查询账户时,可以同时得到角色的所属用户信息</code></pre><p>CREATE TABLE role(<br>    id INT(11) NOT NULL COMMENT’编号’,<br>    ROLE_NAME VARCHAR(32)DEFAULT NULL COMMENT’角色名称’,<br>    ROLE_DESC VARCHAR(60)DEFAULT NULL COMMENT’角色描述’<br>);</p><p>INSERT INTO role VALUES(1,’无名剑主’,’划破时代黑暗的破势之剑’),(2,’东灵剑主’,’飘逸灵巧的睿智之剑’),(3,’月白剑主’,’优雅高贵的魅力之剑’),(4,’红云剑主’,’桀骜狂放的狂道之剑’),(5,’紫霄剑主’,’顺应时势的天道之剑’);</p><p>SELECT * FROM role;</p><p>CREATE TABLE user_role(<br>    uid INT(11) NOT NULL COMMENT’用户编号’,<br>    rid INT(11) NOT NULL COMMENT’角色编号’,<br>    PRIMARY KEY (uid,rid),<br>    KEY FK_Reference_10 (rid),<br>    CONSTRAINT FK_Reference_10 FOREIGN KEY (rid) REFERENCES role(id),<br>    CONSTRAINT FK_Reference_9 FOREIGN KEY (uid) REFERENCES hero(i<code>role``user_role``role``hero``user_role``hero</code>d)<br>);<br>INSERT INTO user_role(uid,rid) VALUES (1,5),(2,1),(3,1),(4,2),(5,4),(6,3),(13,4);</p><p>SELECT * FROM user_role;</p><hr><p>多对多<br>查询角色的同时获取用户信息<br>select h.*,r.id as rid,r.role_name,r.role_desc from role r<br>left outer join user_role ur on r.id=ur.rid<br>left outer join hero h on ur.uid=h.id </p><pre><code>//多对多的关系映射private List&lt;User&gt; users;public List&lt;User&gt; getUsers() {    return users;}public void setUsers(List&lt;User&gt; users) {    this.users = users;}</code></pre><hr><!--?xml version="1.0" encoding="UTF-8"?--><mapper namespace="com.sqtian.dao.IRoleDao">    <resultmap id="roleMap" type="com.sqtian.domain.Role">        <id property="roleId" column="rid"></id>        <result property="roleName" column="role_name"></result>        <result property="roleDesc" column="role_desc"></result>        <collection property="users" oftype="User">            <id property="id" column="id"></id>            <result property="name" column="name"></result>            <result property="age" column="age"></result>            <result property="weight" column="weight"></result>            <result property="height" column="height"></result>        </collection>    </resultmap><pre><code>&lt;select id="findAll" resultMap="roleMap"&gt;    select h.*,r.id as rid,r.role_name,r.role_desc from role r    left outer join user_role ur on r.id=ur.rid    left outer join hero h on ur.uid=h.id&lt;/select&gt;</code></pre></mapper><hr><pre><code>@Testpublic void testFindAll(){    //5.执行查询所有的方法    List&lt;Role&gt; roles = roleDao.findAll();    for (Role role : roles) {        System.out.println("每一个角色的信息");        System.out.println(role);        System.out.println(role.getUsers());    }}</code></pre><hr><p>多对多<br>查询用户获取角色信息<br>select h.*,r.id as rid,r.role_name,r.role_desc from hero h<br>left outer join user_role ur on h.id=ur.uid<br>left outer join role r on ur.rid=r.id </p><pre><code>//多对多关系映射private List&lt;Role&gt; roles;public List&lt;Role&gt; getRoles() {    return roles;}public void setRoles(List&lt;Role&gt; roles) {    this.roles = roles;}</code></pre><hr><pre><code>    &lt;collection property="roles" ofType="Role"&gt;        &lt;id property="roleId" column="rid"&gt;&lt;/id&gt;        &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt;        &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt;    &lt;/collection&gt;</code></pre><hr><pre><code>@Testpublic void testFindAllRoles(){    //5.执行查询所有的方法    List&lt;User&gt; users = userDao.findAllRoles();    for (User user : users) {        System.out.println("---每个用户的信息---");        System.out.println(user);        System.out.println(user.getRoles());    }}</code></pre><hr><h2 id="JNDI-数据源"><a href="#JNDI-数据源" class="headerlink" title="JNDI 数据源"></a>JNDI 数据源</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_Mybatis_Day02&#39;</title>
      <link href="/2020/05/09/java-kuang-jia/javanote-mybatis-day02/"/>
      <url>/2020/05/09/java-kuang-jia/javanote-mybatis-day02/</url>
      
        <content type="html"><![CDATA[<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>mybatis基本使用<br>mybatis的单表crud操作<br>mybatis的参数和返回值<br>mybatis的dao编写<br>mybatis配置细节</p><a id="more"></a><h2 id="CRUD增删改查"><a href="#CRUD增删改查" class="headerlink" title="CRUD增删改查"></a>CRUD增删改查</h2><ol><li>IUserDao</li></ol><p>/**<br> *</p><ul><li>用户的持久层接口</li><li>/<br>public interface IUserDao {<br>  /**<ul><li>查询所有操作</li><li>/</li></ul></li></ul><p>//    @Select(“select * from hero”)<br>    List<user> findAll();</user></p><pre><code>/** * 保存用户 * 在映射文件中写入对应sql语句 */void saveUser(User user);/** * 更新用户 * 在映射文件中写入对应sql语句 */void updateUser(User user);/** * 删除用户 */void deleteUser(Integer userID);/** * 根据id查询用户 * @return */User findById(int userID);/** * 根据名称模糊查询用户 * @return */List&lt;User&gt; findByName(String userName);/** * 查询总用户数 * @return */int findTotal();</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><ol start="2"><li>添加IuserDao.xml中对应方法</li></ol><!--?xml version="1.0" encoding="UTF-8"?--><mapper namespace="com.sqtian.dao.IUserDao"><pre><code>&lt;!--配置查询所有--&gt;    &lt;select id="findAll" resultType="com.sqtian.domain.User"&gt;        select * from hero;    &lt;/select&gt;&lt;!--保存用户 指定传入参数类型 getset方法都是自动生成的,可以用#{}直接获取属性--&gt;&lt;insert id="saveUser" parameterType="com.sqtian.domain.User"&gt;    &lt;!--配置插入操作后,获取插入数据的id--&gt;    &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt;        select last_insert_id();    &lt;/selectKey&gt;    insert into hero(name,age,weight,height)values(#{name},#{age},#{weight},#{height});&lt;/insert&gt;&lt;!--更新用户 指定传入参数类型 getset方法都是自动生成的,可以用#{}直接获取属性--&gt;&lt;update id="updateUser" parameterType="com.sqtian.domain.User"&gt;    update hero set name=#{name},age=#{age},weight=#{weight},height=#{height} where id=#{id};&lt;/update&gt;&lt;!--删除用户--&gt;&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt;    delete from hero where id = #{userID};&lt;/delete&gt;&lt;!--根据id查询用户--&gt;&lt;select id="findById" parameterType="INT" resultType="com.sqtian.domain.User"&gt;    select * from hero where id = #{userID};&lt;/select&gt;&lt;!--根据名称模糊查询用户--&gt;&lt;select id="findByName" parameterType="string" resultType="com.sqtian.domain.User"&gt;    select * from hero where name like #{userName};&lt;/select&gt;&lt;!--查询用户总记录条数--&gt;&lt;select id="findTotal" resultType="int"&gt;    select count(id) from hero;&lt;/select&gt;</code></pre></mapper><hr><ol start="3"><li>测试方法<br>/**<ul><li>测试mybatisCRUD操作</li><li>增删改查</li><li>/</li></ul></li></ol><p>public class CRUDTest {</p><pre><code>private InputStream in;private SqlSession sqlSession;private IUserDao userDao;/** * 测试查询所有 */@Before //用于在测试方法执行之前执行public void init() throws Exception{    //1.读取配置文件,生成字节输入流    in = Resources.getResourceAsStream("SqlMapConfig.xml");    //2.获取SqlSessionFactory    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);    //3.获取sqlSession对象    sqlSession = factory.openSession();    //4.获取dao代理对象    userDao = sqlSession.getMapper(IUserDao.class);}@After //用于在测试方法执行之后执行public void destroy() throws IOException {    //提交事务    sqlSession.commit();    //6.关闭资源    sqlSession.close();    in.close();}@Testpublic void testFindAll(){    //5.执行查询所有的方法    List&lt;User&gt; users = userDao.findAll();    for (User user : users) {        System.out.println(user);    }}@Testpublic void testSave(){    User user = new User();    user.setName("新建武将");    user.setAge(18);    user.setWeight(120);    user.setHeight(170);    //执行保存用户    userDao.saveUser(user);}@Testpublic void testUpdate(){    User user = new User();    user.setId(10);    user.setName("update");    user.setAge(18);    user.setWeight(120);    user.setHeight(170);    //执行更新用户    userDao.updateUser(user);}@Testpublic void testDelete(){    userDao.deleteUser(10);}@Testpublic void testFindById(){    User user = userDao.findById(1);    System.out.println(user);}@Testpublic void testFindByName(){    List&lt;User&gt; users = userDao.findByName("%update%");    for (User user : users) {        System.out.println(user);    }}@Testpublic void testFindTotal(){    int count = userDao.findTotal();    System.out.println(count);}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><h2 id="参数深入"><a href="#参数深入" class="headerlink" title="参数深入"></a>参数深入</h2><p>OGNL表达式：<br>    Object Graphic Navigation Language<br>    对象   图      导航       语言</p><pre><code>他是通过对象的取值方法来获取数据。在写法上把get给省略了比如：我们获取用户的名称        类中的写法：user.getUsername();        OGNL表达式写法：user.usernamemybatis中为什么能直接写username,而不用user.呢    因为在parameterType中已经提供了属性所属的类,所以此时不需要写对象名</code></pre><p>mybatis 使用OGNL表达式解析对象字段的值,#{}或者${}括号中的值为pojo属性名称</p><p>注: 各种对象含义<br>BO：Business Object，业务对象。<br>    主要是承载业务数据的实体。<br>    处理业务逻辑的时候使用，数据结构也是针对业务逻辑建立的。<br>PO：persistence Object，持久化对象。<br>    数据最终要存储，无论以何种形式存储，都必须要持久化。<br>    加入使用关系数据库存储，一个PO对应一条数据库的记录，<br>    或者是对象从数据库查询出来的结果集的一条记录。<br>DAO：Data Access Object，数据访问对象。<br>    包含一些数据库的基本操作，CRUD，和数据库打交道。<br>    负责将PO持久化到数据库，也负责将从数据库查询的结果集映射为PO。<br>DTO：Data Transfer Object，数据传输对象。<br>    一般用来在前段和后台的数据传输，数据结构的简历是基于网络传输的，<br>    减少传输的数据量，避免传输过多无用的数据。<br>VO：Value Object，值对象。<br>    主要用在前段数据和控件的绑定操作中，以键值对的形式存在。<br>    可以从DTO转化而来，这么做的好处就是减少对于DTO的依赖，<br>    进一步减少对应后端的依赖。还可以增加前段的可测试性，也就是没有DTO，<br>    也可以对前段逻辑进行自动化的单元测试，可以通过MockDTO来达到测试的目的。<br>POJO（Plain Old Java Object）简单的Java对象，实际就是普通JavaBeans。<br>    其中有一些属性及其getter setter方法的类,没有业务逻辑，<br>    有时可以作为VO(value -object)或dto(Data Transform Object)来使用.<br>    当然,如果你有一个简单的运算属性也是可以的,<br>    但不允许有业务方法,也不能携带有connection之类的方法。</p><hr><pre><code>/** * 根据queryVo中的条件查询用户 * */List&lt;User&gt; findUserByVo(QueryVo vo);</code></pre><hr><pre><code>&lt;!--根据QueryVo的条件查询用户--&gt;&lt;select id="findUserByVo" parameterType="com.sqtian.domain.QueryVo" resultType="com.sqtian.domain.User"&gt;    select * from hero where name like #{user.name};&lt;/select&gt;</code></pre><hr><p>package com.sqtian.domain;</p><p>public class QueryVo {<br>    private User user;</p><pre><code>public User getUser() {    return user;}public void setUser(User user) {    this.user = user;}</code></pre><p>}</p><hr><pre><code>@Testpublic void testFindByVo(){    //根据queryVo对象的条件来查询    QueryVo queryVo = new QueryVo();    User user = new User();    user.setName("%update%");    queryVo.setUser(user);    List&lt;User&gt; users = userDao.findUserByVo(queryVo);    for (User u : users) {        System.out.println(u);    }}</code></pre><hr><h2 id="结果类型封装"><a href="#结果类型封装" class="headerlink" title="结果类型封装"></a>结果类型封装</h2><pre><code>如果封装结果的对象User的属性和数据库中字段不一样数据库中是id,name,age,weight,height创建User对象时定义的属性是userId,userName,userAge,userWeight,userHeight,如何对应方法一: 起别名在sql层面解决    &lt;!--配置查询所有--&gt;    &lt;select id="findAll" resultType="com.sqtian.domain.User"&gt;        select id as userId,name as userName,age as userName,weight as userWeight,height as userHeight from hero;    &lt;/select&gt;    执行效率高,但开发效率低方法二: 配置查询结果的列名和实体类的属性名对应关系    &lt;resultMap id="userMap" type="com.sqtian.domain.User"&gt;        &lt;!--主键字段的对应--&gt;        &lt;id property="属性名userId" column="数据库中对应的列名id"&gt;&lt;/id&gt;        &lt;!--非主键字段的对应--&gt;        &lt;result property="userName" column="username"&gt;&lt;/result&gt;        &lt;result property="userAge" column="age"&gt;&lt;/result&gt;        &lt;result property="userWeight" column="weight"&gt;&lt;/result&gt;        &lt;result property="userHeight" column="height"&gt;&lt;/result&gt;    &lt;/resultMap&gt;    同时,还需要将&lt;select id="findAll" resultType="com.sqtian.domain.User"&gt;    改为&lt;select id="findAll" resultMap="userMap"&gt;    开发效率高</code></pre><h2 id="mybatis-配置文件的一些配置"><a href="#mybatis-配置文件的一些配置" class="headerlink" title="mybatis 配置文件的一些配置"></a>mybatis 配置文件的一些配置</h2><p>jdbc.driver=com.mysql.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC<br>jdbc.username=root<br>jdbc.password=root</p><hr><!--?xml version="1.0" encoding="UTF-8"?--><!--mybatis的主配置文件--><configuration>    <!--配置properties        可以在标签内部配置连接数据库的信息，也可以通过属性引用外部配置文件信息        将property信息写在resources下的jdbcConfig.properties文件里,        通过resource属性引用，<properties resource="jdbcConfig.properties"        url属性: 是按照URL的写法来找properties文件                URL:Uniform Resource Locator 统一资源定位符,可以唯一标识一个资源的位置                写法:                http://localhost:8080/mybatiesserver/demoqServlet                协议 主机 端口 URI                URI:Uniform Resource Identifier 统一资源标识符,是在应用中唯一标识一个资源的<pre><code>    &lt;properties url=&quot;file:///D:/IntelliJ IDEA Community Edition 2019.3.1/com.sqtian.mybatis/src/main/resources/jdbcConfig.properties/jdbcConfig.properties&quot;&gt;    &gt;--&gt;&lt;properties resource=&quot;jdbcConfig.properties&quot;&gt;</code></pre><!--        <property name="driver" value="com.mysql.jdbc.Driver"/>--><!--        <property name="url" value="jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC"/>--><!--        <property name="username" value="root"/>--><!--        <property name="password" value="root"/>--><pre><code>&lt;/properties&gt;&lt;!--配置环境--&gt;&lt;environments default="mysql"&gt;    &lt;!--配置mysql环境--&gt;    &lt;environment id = "mysql"&gt;        &lt;!--配置事务类型 --&gt;        &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;        &lt;!--配置数据源(连接池)--&gt;        &lt;dataSource type="POOLED"&gt;            &lt;!--配置连接数据库的4个基本信息                ${}引用properties里的内容            --&gt;            &lt;property name="driver" value="${jdbc.driver}"/&gt;            &lt;property name="url" value="${jdbc.url}"/&gt;            &lt;property name="username" value="${jdbc.username}"/&gt;            &lt;property name="password" value="${jdbc.password}"/&gt;        &lt;/dataSource&gt;    &lt;/environment&gt;&lt;/environments&gt;&lt;!--指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件&lt;mapper resource="com/sqtian/dao/IUserDao.xml"/&gt;    如果使用注解的方式，来配置，此处应该使用class属性指定被注解的dao全限定类名&lt;mapper class="com.sqtian.dao.IUserDao"/&gt;,不需要com.sqtian.dao.IUserDao.xml--&gt;&lt;mappers&gt;    &lt;mapper resource="com/sqtian/dao/IUserDao.xml"/&gt;&lt;/mappers&gt;</code></pre></configuration><hr><p>可以给路径取别名缩小路径长度<br><typealiases><br>    <typealias type="实体类全限定类名" alias="指定的别名,不再区分大小写"></typealias></typealiases></p><pre><code>还可以用package属性,更加方便.用于指定别名,指定之后,该包下的实体类都会注册别名,并且类名就是别名,不再区分大小写&lt;package name="com.sqtian.domain"&gt;&lt;/package&gt;</code></pre><p>同时mappers标签下的package也可以进行配置<package name="com.sqtian.dao"></package></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote_Mybatis_Day01&#39;</title>
      <link href="/2020/05/09/java-kuang-jia/javanote-mybatis-day01/"/>
      <url>/2020/05/09/java-kuang-jia/javanote-mybatis-day01/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>mybatis入门<br>mybatis概述<br>mybatis环境搭建<br>mybatis入门案例<br>自定义mybatis框架</p><a id="more"></a><ol><li><p>什么是框架<br> 整个或部分系统的可重用设计,它是软件开发中的一套解决方案,不同框架解决的是不同的问题<br> 好处:</p><pre><code> 框架封装了很多细节,使开发者可以使用极简的方式实现功能,提高效率</code></pre></li><li><p>三层架构<br> 表现层:</p><pre><code> 用于展示数据</code></pre><p> 业务层:</p><pre><code> 处理业务要求</code></pre><p> 持久层:</p><pre><code> 和数据库交互</code></pre></li><li><p>持久层技术解决方案<br> JDBC技术:</p><pre><code> Connection PreparedStatement ResultSet</code></pre><p> Spring的JdbaTemplate:</p><pre><code> Spring中对jdbc的简单封装</code></pre><p> Apache的DBUtils:</p><pre><code> 也是对jdbc的简单封装</code></pre><p> 以上这些都不是框架</p><pre><code> JDBC是规范 Spring的JdbcTemplate和Apache的DBUtils都只是工具类</code></pre></li><li><p>mybatis概述<br> mybatis是一个java编写的持久层框架<br> MyBatis内部封装了jdbc,使开发者只需要关注sql语句本身,<br> 而不是花费精力去加载驱动,创建链接,创建statement等繁杂的过程</p></li><li><p>入门案例<br> 环境搭建</p><pre><code> 第一步: 创建maven工程并导入坐标 pom.xml</code></pre></li></ol><!--?xml version="1.0" encoding="UTF-8"?--><p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelversion>4.0.0</modelversion></project></p><pre><code>&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;com.sqtian.mybatis&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;version&gt;3.4.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.12&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.13&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre>-----------------------------------------------------------------------------------<pre><code>    第二步: 创建实体类和dao接口</code></pre><p>package com.sqtian.domain;</p><p>import java.io.Serializable;</p><p>public class User implements Serializable {<br>    private Integer id;<br>    private String name;<br>    private Integer age;<br>    private double weight;<br>    private double height;</p><pre><code>@Overridepublic String toString() {    return "com.sqtian.domain.User{" +        "id=" + id +        ", name='" + name + '\'' +        ", age=" + age +        ", weight=" + weight +        ", height=" + height +        '}';}public Integer getId() {    return id;}public void setId(Integer id) {    this.id = id;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public Integer getAge() {    return age;}public void setAge(Integer age) {    this.age = age;}public double getWeight() {    return weight;}public void setWeight(double weight) {    this.weight = weight;}public double getHeight() {    return height;}public void setHeight(double height) {    this.height = height;}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><pre><code>    第三步: 创建Mybatis的主配置文件 SqlMapConfig.xml</code></pre><!--?xml version="1.0" encoding="UTF-8"?--><!--mybatis的主配置文件--><configuration>    <!--配置环境-->    <environments default="mysql">        <!--配置mysql环境-->        <enviroment id="mysql">            <!--配置事务类型 -->            <transactionmanager type="JDBC"></transactionmanager>            <!--配置数据源(连接池)-->            <datasource type="POOLED">                <!--配置连接数据库的4个基本信息-->                <property name="driver" value="com.mysql.jdbc.Driver">                <property name="url" value="jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC">                <property name="username" value="root">                <property name="password" value="root"><pre><code>        &lt;/dataSource&gt;    &lt;/enviroment&gt;&lt;/environments&gt;&lt;!--指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件--&gt;&lt;mappers&gt;    &lt;mapper resource="com/sqtian/dao/IUserDao.xml"/&gt;&lt;/mappers&gt;</code></pre></property></property></property></property></datasource></enviroment></environments></configuration>----------------------------------------------------------------------------------------<pre><code>    第四步: 创建映射配置文件 IUserDao.xml</code></pre><!--?xml version="1.0" encoding="UTF-8"?--><mapper namespace="com.sqtian.dao.IUserDao"><pre><code>&lt;!--配置查询所有--&gt;    &lt;select id="findAll"&gt;        select * from hero    &lt;/select&gt;</code></pre></mapper>----------------------------------------------------------------<pre><code>    注意事项:        mybatis的映射配置文件位置必须和dao接口的包结构相同        映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名        映射配置文件的操作配置(select),id属性的取值必须是dao接口的方法名</code></pre><p>案例：</p><ol><li>读取配置文件</li><li>创建SqlSessionFactory工厂</li><li>创建SqlSession</li><li>创建Dao接口的代理对象</li><li>执行dao中的方法</li><li>释放资源</li></ol><p>public class MybatisTest {<br>    public static void main(String[] args) throws Exception {<br>        //1.读取配置文件<br>        InputStream inputStream = Resources.getResourceAsStream(“SqlMapConfig.xml”); //钱<br>        //2.创建SqlSessionFactory工厂<br>        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //包工头<br>        SqlSessionFactory factory = builder.build(inputStream); //把钱给包工头建工厂<br>        //3.使用工厂模式生产SqlSession对象<br>        SqlSession session = factory.openSession();  //工厂模式的优势，解耦（降低类之间的依赖关系）<br>        //4.使用SqlSession创建Dao接口的代理对象<br>        IUserDao userDao = session.getMapper(IUserDao.class); //创建Dao类使用了代理模式，不修改源码的基础上对已有方法增强<br>        //5.使用代理对象执行方法<br>        List<user> users = userDao.findAll();<br>        for (User user : users) {<br>            System.out.println(user);<br>        }<br>        //6.释放资源<br>        session.close();<br>        inputStream.close();</user></p><pre><code>}</code></pre><p>}</p><hr><p>使用注解的方式更加方便<br>public interface IUserDao {<br>    /**<br>     * 查询所有操作<br>     */</p><pre><code>@Select("select * from hero")List&lt;User&gt; findAll();</code></pre><p>}</p><p>sqlMapConfig里<br>    <!--指定映射配置文件的位置,映射配置文件指的是每个dao独立的配置文件<mapper resource="com/sqtian/dao/IUserDao.xml"/>        如果使用注解的方式，来配置，此处应该使用class属性指定被注解的dao全限定类名,不需要com.sqtian.dao.IUserDao.xml--><br>    <mappers><br>        <mapper class="com.sqtian.dao.IUserDao"><br>    </mapper></mappers></p><ol start="6"><li><p>自定义Mybatis的分析<br> mybatis在使用代理dao的方式实现增删改查时做什么事</p><ol><li><p>创建代理对象</p></li><li><p>在代理对象中调用selectList</p><p>自定义mybatis涉及到的<br>class Resources<br>class SqlSessionFactoryBuilder<br>interface SqlSessionFactory<br>interface SqlSession</p><p>自己创建以上类，参考mybatis源码</p></li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaWebNote03_JS&#39;</title>
      <link href="/2020/05/02/java-ji-chu/javawebnote03-js/"/>
      <url>/2020/05/02/java-ji-chu/javawebnote03-js/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>概念：一门客户端脚本语言<br>    运行在客户端浏览器中的。每一个浏览器都有JavaScript<br>    脚本语言：不需要编译，直接就可以被浏览器解析执行</p><a id="more"></a>    <p>功能：<br>    可以来增强用户和html页面的交互过程，可以来控制html元素，<br>    让页面有一些动态的效果，增强用户的体验</p><p>JavaScript = ECMAScript + JavaScript特有的(BOM+DOM)</p><p>ECMAScript: 客户端脚本语言的标准<br>    1. 基本语法<br>        1. 与html结合方式<br>            1. 内部JS<br>                定义<script>标签<br>                <script><br>                    alert("Hello World");<br>                </script><br>            2. 外部JS<br>                通过src属性引入<br>                <script src="../js/a.js"></script></p><pre><code>        注意:             1. &lt;script&gt;可以定义在html页面的任何地方,但是定义的位置会影响执行顺序            2. &lt;script&gt;可以定义多个    2. 注释        单行: //        多行: /**/    3. 数据类型        1. 原始数据类型(基本数据类型)            1. number: 数字. 整数/小数/NaN(not a number 一个不是数字的数字类型)            2. string: 字符串. 字符串             3. boolean: true false            4. null: 一个对象为空的占位符            5. undefined: 未定义.如果一个变量没有给初始化值,则会被默认赋值为undefined        2. 引用数据类型:对象    4. 变量        变量: 一小块存储数据的内存空间        Java语言是强类型语言,申请空间时规定了类型,int a = 3;a就只能存放int而JavaScript是一个弱类型语言        而JavaScript是一个弱类型语言,var a = 3;a还可以存放其他类型的数据        语法:            var 变量名 = 初始化值;    5. 运算符        1. 一元运算符: 只有一个运算数的运算符            ++.-- ...            +(-):正负号,注意:在JS中,如果运算数不是运算符所要求的类型,你们JS引擎会自动进行类型转换                string转number: 按照字面值转换.如果字面值不是数字,则转为NaN(不是数字的数字类型)                boolean转number: true转1,false转0        2. 算术运算符:            +-*/% ...        3. 赋值运算符:            =,+=, ...        4. 比较运算符:            &lt;&gt; (全等于)===...            比较方式            1. 类型相同,直接比较. 字符串按照字典顺序逐一比较            2. 类型不同,先进行类型转换再比较.                 ===: 在比较之前先判断类型,如果类型不一样则直接返回false        5. 逻辑运算符:            &amp;&amp; || !            其他类型转boolean                1. number：0和NaN为假，其他为真                2. string：除了空字符串，其他都是true                3. null和undefined：false                4. 所有对象都是true        6. 三元运算符:            ? :    6. 流程控制语句        1. if...else...        2. switch            在java中,switch语句可以接收的数据类型: byte int shor char 枚举 String            在js中,switch可以接收任意类型        3. while        4. do...while        5. for    7. js特殊语法        变量定义使用var关键字，也可以不使用        使用：定义变量是局部变量        不使用：定义变量是全局变量2. 基本对象    Function        &lt;script&gt;            /*                Function: 函数方法对象                    1. 创建:                        1. var fun = new Function(形式参数列表,方法体); 不推荐                        2. function 方法名称（形式参数列表）{                                方法体                            }                        3. var 方法名 = function(形式参数列表){                                方法体                            }                    2. 方法:                    3. 属性:                        length: 参数个数                    4. 特点:                        1. 方法定义时，形参的类型不用写                        2. 方法是一个对象,如果定义名称相同的方法,会覆盖                        3. 在js中,方法的调用只与方法的名称有关,和参数列表无关                        4. 在方法声明中隐藏的内置对象(数组),arguments,封装所有的实际参数                    5. 调用:            */            //创建方式1            //var fun1 = new Function("a","b","alert(a);");            //fun1(3,4);            //创建方式2            function fun2(a,b){                alert(a+b);            }            fun2(3,4);            //求任意个数的和            function add(){                var sum = 0;                for(var i = 0; i&lt; arguments.length; i++){                    sum += arguments[i];                }                return sum;            }            var sum = add(1,2,3,4);            alert(sum);        &lt;/script&gt;    Array        创建方式        var arr1 = new Array(1,2,3);        var arr2 = new Array(默认长度);        var arr3 = [1,2,3];        特点: JS中,数组的类型是可变的              JS中,数组的长度可以变化        属性: length 数组的长度        方法:            join(参数): 将数组中的元素按照指定的分隔符拼接为字符串            push(参数): 向数组末尾添加    Boolean    Date    Math    Number    String    RegExp: 正则表达式对象        1. 正则表达式: 定义字符串的组成规则            1. 单个字符: []                如: [a] [ab] [a-zA-Z0-9]                *特殊符号代表特殊含义的单个字符:                    \d: 单个数字字符 [0-9]                    \w: 单个单词字符 [a-zA-Z0-9]            2. 量词符号:                ?: 表示出现0次或1次                *: 表示出现0次或多次                +: 出现1次或多次                {m,n}: 表示 m&lt;=数量&lt;=n        2. 创建            ver reg = new RegExp("正则表达式");            ver reg = new RegExp("^\\w{6,12}$");//6-12个字符的单词            ver reg2 = /正则表达式/;        3. 方法            test(参数): 验证指定的字符串是否符合正则定义的规范    Global        1. 特点: 全局对象,这个Global中封装的方法不需要对象就可以直接调用            方法名()        2. 方法:            encodeURI(): url编码            decodeURI(): url解码            encodeURIComponent(): url编码            decodeURIComponent(): url解码            parseInt(): 将字符串转为数字                逐一判断每一个字符是否为数字,直到不是数字为止,将前边数字部分转为number            isNaN(): 判断一个值是否是NaN                NaN六亲不认,连自己都不认.NaN参与的==比较全是false,只好用isNaN来判断            eval(): 将JavaScript 字符串,并把它作为脚本代码来执行</code></pre><h2 id="九九乘法表练习"><a href="#九九乘法表练习" class="headerlink" title="九九乘法表练习"></a>九九乘法表练习</h2><meta name="generator" content="Hexo 3.9.0">    <meta charset="UTF-8">    <title>99乘法表</title><pre><code>&lt;style&gt;    td{        border: 1px solid;    }&lt;/style&gt;&lt;script&gt;    document.write("&lt;table align='center'&gt;");    //1. 完成基本的for循环嵌套    for (var i = 1; i &lt;= 9; i++) {        document.write("&lt;tr&gt;");        for(var j = 1;j &lt;= i; j++){        document.write("&lt;td&gt;");            document.write(i+"*"+j+"="+(i*j)+"&amp;nbsp;&amp;nbsp;&amp;nbsp;");            document.write("&lt;/td&gt;");        }        document.write("&lt;/tr&gt;");        //输出换行        document.write("&lt;br&gt;");    }//完成表格嵌套document.write("&lt;/table&gt;");&lt;/script&gt;</code></pre><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaWebNote02_CSS&#39;</title>
      <link href="/2020/04/27/java-ji-chu/javawebnote02-css/"/>
      <url>/2020/04/27/java-ji-chu/javawebnote02-css/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ol><li>概念：Cascading Style Sheets 层叠样式表</li></ol><a id="more"></a><ol start="2"><li><p>CSS好处</p><ol><li>功能强大</li><li>将内容展示和样式控制分离<ul><li>降低耦合度,解耦</li><li>让分工协作更容易</li><li>提高开发效率</li></ul></li></ol></li><li><p>CSS的使用:CSS与html结合方式</p><ol><li><p>内联样式<br>在标签内使用style属性指定css代码,如</p><div style="color:red;">hello css</div>并没有把内容和样式分开,因此不推荐</li><li><p>内部样式<br>在head标签内,定义style标签,style标签的标签体内容就是css代码</p><meta name="generator" content="Hexo 3.9.0"> <meta charset="UTF-8"> <title>Title</title> <style>     div{         color:blue; //被div包裹的内容就会变成蓝色     } </style><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><div>hello css</div><p>只能设置当前页面被div标记的部分,想把多个页面设置成这样就不适用了</p></li><li><p>外部样式<br>第一步:定义CSS资源文件<br>第二步:在head标签内,定义link标签,引入外部的资源文件</p><p>一般都放在一个css的文件夹里,后缀名.css</p><p>a.css<br>div{<br> color:green;<br>}</p></li></ol><hr><pre><code> &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="css/a.css"&gt;</code></pre>   <div>hello css</div>  ---------------------------------------------- 也可以写成 <style>     @import"css/a.css"; </style> ----------------------------------------------</li></ol><ol start="4"><li><p>CSS语法:</p><ul><li><p>格式:<br>  选择器{</p><pre><code>  属性名1:属性值1;  属性名2:属性值2;  ......</code></pre><p>  }</p></li><li><p>选择器:筛选具有相似特征的元素<br>  如写上div,所有div就会应用样式,没有写div的就不会改变</p></li></ul></li></ol><ol start="5"><li>选择器:筛选具有相似特征的元素<ul><li>分类:<ol><li>基本选择器<ol><li>id选择器:选择具体的id属性值的元素<br>语法:#id属性值()</li></ol></li></ol></li></ul></li></ol><pre><code>        2. 元素选择器:选择具有相同标签名称的元素            语法:标签名称()            注意:id选择器优先级高于元素选择器        3. 类选择器:选择具有相同的class属性值的元素            语法:.class属性值{}            注意:优先级高于元素选择器,低于id选择器        &lt;head&gt;            &lt;meta charset="UTF-8"&gt;            &lt;title&gt;Title&lt;/title&gt;            &lt;style&gt;                #div1{                    color:red; //只有id为div1的部分才会改变                }                div{                    color:green;   //应用于所有div标记的部分,但id选择器优先级高于元素选择器,所以id选择器部分不会被覆盖                }                .cls1{                    color:blue;                }            &lt;/style&gt;        &lt;/head&gt;        &lt;body&gt;        &lt;div id="div1"&gt;hello css&lt;/div&gt;        &lt;div&gt;hello&lt;/div&gt;        &lt;p class="cls1"&gt;无名剑&lt;/p&gt;        &lt;/body&gt;    2. 扩展选择器        1. 选择所有元素:            *语法: *{}        2. 并集选择器:            *语法:选择器1,选择器2{}        3. 子选择器:筛选选择器1元素下的选择器2元素            *语法:选择器1 选择器2{}        4. 父选择器：筛选选择器2的父选择器1元素            *语法：选择器1 &gt; 选择器2{}        5. 属性选择器: 选择元素名称, 属性名=属性值的元素            *语法: 元素名称[属性名='属性值']{}        6. 伪类选择器: 选择一些元素具有的状态            *语法: 元素:状态{}            *如: &lt;a&gt;                *状态:                    link: 初始化的状态                    visited: 被访问过的状态                    active: 正在访问状态                    hover: 鼠标悬浮状态        &lt;head&gt;            &lt;meta charset="UTF-8"&gt;            &lt;title&gt;扩展选择器&lt;/title&gt;            &lt;style&gt;                子选择器, 只有在div下的p标签                div p{                    color:red;                }                父选择器, 只有p上的div会变                div &gt; p{                    border: 1px solid;                }                属性选择器,只有type符合的才会变                input[type='text']{                    border: 5px solid;                }                改变超链接各种不同状态的属性                a:link{                    color:pink                }                a:hover{                    color:green                }                a:active{                    color:yellow                }                a:visited{                    color:red                }            &lt;/style&gt;        &lt;/head&gt;        &lt;body&gt;            &lt;div&gt;                &lt;p&gt;无名剑主&lt;/p&gt;            &lt;/div&gt;            &lt;p&gt;虎啸飞剑式&lt;/p&gt;            &lt;div&gt;恒山松岳&lt;/div&gt;            &lt;input type = "text"&gt;            &lt;input type = "password"&gt;            &lt;br&gt;  &lt;br&gt;            &lt;a href="#"&gt;洗髓经&lt;/a&gt;        &lt;/body&gt;</code></pre><ol start="6"><li><p>属性</p><ol><li><p>字体, 文本<br> font-size: 字体大小<br> color: 文本颜色<br> text-align: 对齐方式<br> line-height: 行高<br> ……</p></li><li><p>背景<br> background</p></li><li><p>边框<br> boder: 边框</p></li><li><p>尺寸<br> width<br> height</p></li><li><p>盒子模型: 控制布局<br> margin: 外边距<br> padding: 内边距</p><pre><code> 默认情况下内边距会影响整个盒子大小 需要设置box-sizing: border-box;</code></pre><p> float: 浮动</p><pre><code> left right</code></pre></li></ol></li></ol><meta name="generator" content="Hexo 3.9.0">    <meta charset="UTF-8">    <title>Title</title><pre><code>&lt;style&gt;    div{        border: 1px solid red;        width: 100px    }    .div1{        width: 100px;        height: 100px;        /*        对于内盒,就可以直接设置外边距让其居中        margin: 50px; */    }    .div2{        width: 200px;        height: 200px;        /*            如果设置外盒内边距,其大小容易改变            设置合资的属性,让长宽就是最终大小        */        padding: 50px;        box-sizing: border-box;    }    .div3{        float: left;    }    .div4{        float: left;    }    .div5{        float: right;    }&lt;/style&gt;</code></pre><pre><code>&lt;div class="div2"&gt;    &lt;div class="div1"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="div3"&gt;aaaa&lt;/div&gt;&lt;div class="div4"&gt;bbbb&lt;/div&gt;&lt;div class="div5"&gt;cccc&lt;/div&gt;</code></pre><h2 id="CSS案例-注册页面"><a href="#CSS案例-注册页面" class="headerlink" title="CSS案例 注册页面"></a>CSS案例 注册页面</h2><meta name="generator" content="Hexo 3.9.0">    <meta charset="UTF-8">    <title>注册页面</title><pre><code>&lt;style&gt;    *{        margin: 0px;        padding: 0px;        box-sizing: border-box    }    body{        background: url('../image/background.jpg') no-repeat center;    }    .rg_layout{        width: 900px;        height: 500px;        border: 5px solid #EEEEEE;        background-color: white;        /* 让div水平居中*/        margin: auto;        margin-top: 15px;    }    .rg_left{        float: left;        margin: 15px;    }    .rg_left p:first-child{        color:#FFD026;        font-size:20px;    }    .rg_left p:last-child{        color:#A6A6A6;        font-size:20px;    }    .rg_center{        float: left;        width: 450px;    }    .rg_right{        float: right;        margin: 15px;    }    .rg_right p{        font-size:15px;    }    .rg_right p a{        color:pink;    }    .td_left{        width: 100px;        text-align: right;        height: 45px;    }    .td_right{        padding-left: 50px;    }    #user,#password,#email,#name,#tel,#birthday,#checkcode{        width: 251px;        height: 32px;        border: 1px solid #A6A6A6;        /*设置边框圆角*/        border-radius: 5px;        padding-left: 10px    }    #checkcode{width:100px;}    #img_checked{        width: 100px;        vertical-align: middle;    }    #btn_sub{        width: 150px;        height: 40px;        background-color: #FFD026;        border: 1px solid #FFD026;    }&lt;/style&gt;</code></pre><pre><code>&lt;div class="rg_layout"&gt;    &lt;div class="rg_left"&gt;        &lt;p&gt;新用户注册&lt;/p&gt;        &lt;p&gt;USER REGISTER&lt;/p&gt;    &lt;/div&gt;    &lt;div class="rg_center"&gt;        &lt;div class="rg_form"&gt;            &lt;form action="#" method = "post"&gt;                &lt;table&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="user"&gt;用户名&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="text" name="username" id="user" placeholder="请输入用户名"&gt;&lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="password"&gt;密码&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="password" name="password" id="password" placeholder="请输入密码"&gt;&lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="email"&gt;Email&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="email" name="email" id="email" placeholder="请输入邮箱"&gt;&lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="name"&gt;姓名&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="text" name="name" id="name" placeholder="请输入姓名"&gt;&lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="tel"&gt;手机号&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="text" name="tel" id="tel" placeholder="请输入手机号"&gt;&lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;性别&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="radio" name="gender" value="male"&gt;男                            &lt;input type="radio" name="gender" value="female"&gt;女 &lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="birthday"&gt;出生日期&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="date" name="birthday" id="birthday" placeholder="请输入出生日期"&gt;&lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td class="td_left"&gt;&lt;label for="checkcode"&gt;验证码&lt;/label&gt;&lt;/td&gt;                        &lt;td class="td_right"&gt;&lt;input type="text" name="checkcode" id="checkcode" placeholder="请输入验证码"&gt;                            &lt;img id="img_checked" src="img/"&gt;                        &lt;/td&gt;                    &lt;/tr&gt;                    &lt;tr&gt;                        &lt;td colspan="2" align="center"&gt;&lt;input type="submit" value="注册" id="btn_sub"&gt; &lt;/td&gt;                    &lt;/tr&gt;                &lt;/table&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class="rg_right"&gt;        &lt;p&gt;已有账号&lt;a href="#"&gt;立即登录&lt;/a&gt; &lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;AndroidPart2&#39;</title>
      <link href="/2020/04/27/androidpart2/"/>
      <url>/2020/04/27/androidpart2/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-网络与数据的存储"><a href="#Android-网络与数据的存储" class="headerlink" title="Android 网络与数据的存储"></a>Android 网络与数据的存储</h2><p>使用SharedPerferences方便地存储数据<br>数据持久化<br>适用于存储一些简单的数据</p><p>public class ListViewDemoActivity extends Activity implements View.OnClickListener {</p><pre><code>public static final String LIST_VIEW_DATA_COUNTS = "list_view_data_counts";public static final String PREFERENCE_NAME = "preference_name";public static final int DEFAULT_VALUE = 10;//ListView视图作为一个容器，房子private ListView mphoneBookListView;private List&lt;UserInfo&gt; mUserInfos;private int mDataCounts = 10;private Button mConfirmButton;private PhoneBookAdapter mPhoneBookAdapter;private EditText mDataCountsEditText;private SharedPreferences mSharedPreferences;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_listview_demo);    findViews();    setData();    setListeners();}private void findViews() {    mphoneBookListView = findViewById(R.id.list_view);    mDataCountsEditText = findViewById(R.id.data_counts_edit_text);    mConfirmButton = findViewById(R.id.confirm_button);}private void setData() {    //每次创建时读取    SharedPreferences sharedPreferences = getSharedPreferences(PREFERENCE_NAME,Context.MODE_PRIVATE);    mDataCounts = sharedPreferences.getInt(LIST_VIEW_DATA_COUNTS, DEFAULT_VALUE);    mDataCountsEditText.setText(String.valueOf(mDataCounts));    mUserInfos = new ArrayList&lt;&gt;();    for (int index = 0; index &lt; mDataCounts; index++) {        mUserInfos.add(new UserInfo("西门吹雪", 18));    }    //数据列表和数据绑定,adapter适配器，房子里的柜子，柜子放进房子    mPhoneBookAdapter = new PhoneBookAdapter(ListViewDemoActivity.this, mUserInfos);    //房子(mphoneBookListView)里面有柜子(phoneBookAdapter)，柜子里面有格子(name_text_view)，    //格子里面放数据private String[] mNames = {"西门吹雪","李寻欢"}    mphoneBookListView.setAdapter(mPhoneBookAdapter);}private void setListeners() {    //刷新更新数据    mPhoneBookAdapter.notifyDataSetChanged();    //条目点击事件    mphoneBookListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {        @Override        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {            //点击第一条数据时更新            if(position==0){                // 新建另外一批数据                mUserInfos.clear();                mUserInfos.add(new UserInfo("我是新数据一",20));                mUserInfos.add(new UserInfo("我是新数据二",20));                mUserInfos.add(new UserInfo("我是新数据三",20));                // 替换掉老的数据,数据通过PhoneBookAdapter传递,因此要在PhoneBookAdapter中创建refreshData方法                // 刷新ListView,让他更新自己的视图                mPhoneBookAdapter.refreshData(mUserInfos);            }            Toast.makeText(ListViewDemoActivity.this, mUserInfos.get(position).getmUserName()+"被点击了",Toast.LENGTH_LONG).show();        }    });    //长按事件    mphoneBookListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {        @Override        public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {            Toast.makeText(ListViewDemoActivity.this, mUserInfos.get(position).getmUserName()+"被长按了",Toast.LENGTH_LONG).show();            return false;        }    });    // 给确认按钮设置点击事件    mConfirmButton.setOnClickListener(this);}@Overridepublic void onClick(View v) {    switch (v.getId()){        case R.id.confirm_button:            //点击确认时,首先取到输入的数字            mDataCounts= Integer.valueOf(mDataCountsEditText.getText().toString());            refreshListView();            //保存起来,不然editText设置了2,退出后回来还是原来地个数,因此要保存起来,下次打开时自动读取            saveData2Preference(mDataCounts);            break;    }}private void saveData2Preference(int dataCounts) {    // 系统会自动帮我们创建一个XML文件,名字是"preference_name",地址在Data/Data/Shard_prefs    mSharedPreferences = getSharedPreferences(PREFERENCE_NAME, Context.MODE_PRIVATE);    SharedPreferences.Editor editor = mSharedPreferences.edit();    //数据持久化地存起来了    editor.putInt(LIST_VIEW_DATA_COUNTS,dataCounts);</code></pre><p>//        删除<br>//        editor.remove(LIST_VIEW_DATA_COUNTS);</p><pre><code>    //与commit不同,apply后台写数据,另开线程,和网络相关和IO操作相关的都要用异步的apply    editor.apply();}private void refreshListView() {    //刷新数据    mUserInfos.clear();    for (int index = 0; index &lt; mDataCounts; index++) {        mUserInfos.add(new UserInfo("李寻欢", 18));    }    mPhoneBookAdapter.refreshData(mUserInfos);    mPhoneBookAdapter.notifyDataSetChanged();}</code></pre><p>}</p><hr><p> <textview android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="条数" android:id="@+id/data_counts"></textview></p><pre><code>&lt;EditText    android:layout_width="200dp"    android:layout_height="wrap_content"    android:layout_below="@+id/data_counts"    android:id="@+id/data_counts_edit_text"    /&gt;&lt;Button    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="确定"    android:layout_toRightOf="@+id/data_counts_edit_text"    android:id="@+id/confirm_button"/&gt;&lt;TextView    android:id="@+id/phone_text_view"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:layout_centerHorizontal="true"    android:layout_below="@+id/data_counts_edit_text"    android:text="@string/phone_book"/&gt;&lt;ListView    android:layout_width="match_parent"    android:layout_height="match_parent"    android:layout_below="@+id/phone_text_view"    android:id="@+id/list_view"&gt;&lt;/ListView&gt;</code></pre><hr><p>作业：做一个小应用，启动时有两张引导界面，只有第一次启动时，显示，看完后下一次就不显示了</p><h2 id="如何随己所欲管理文件"><a href="#如何随己所欲管理文件" class="headerlink" title="如何随己所欲管理文件"></a>如何随己所欲管理文件</h2><p>//测试文件, 自己用file创建文件<br>    private void testFileDemo() {<br>        //在internal storage里创建了一个新文件<br>        File file = new File(getFilesDir(),”test.txt”);</p><pre><code>    Log.i("MainActivity","getFilesDir:"+ getFilesDir().getAbsolutePath());    Log.i("MainActivity","file path:"+file.getAbsolutePath());    String string = "I am handsome";    try {        boolean isSucess = file.createNewFile();    } catch (IOException e) {        Log.i("MainActivity","test.txt create error:"+e.toString());        e.printStackTrace();    }    try {        FileOutputStream fileOutputStream = openFileOutput("test2.txt", Context.MODE_PRIVATE);        fileOutputStream.write(string.getBytes());    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }    //检查 external storage 是否可用    String state = Environment.getExternalStorageState();    if(TextUtils.equals(state,Environment.MEDIA_MOUNTED)){    }}</code></pre><hr><p>操作assets目录下的文件</p><pre><code>void testAssets() throws IOException {    //assets下的文件不会被编译改变    //第一种,直接读路径    WebView webView = new WebView(this);    webView.loadUrl("file:///android_asset/HelloWorld.html");    //open的只能是文件,不能是文件夹    //读网页    InputStream inputStream = getResources().getAssets().open("HellowWorld.html");    //读列表</code></pre><p>//        String[] fileNames = getAssets().list(“images/“);</p><pre><code>    //读图片    InputStream IMGinputStream = getAssets().open("images/dog.jpg");    //把图片转为bitmap    Bitmap bitmap = BitmapFactory.decodeStream(IMGinputStream);    ImageView imageView = new ImageView(this);    imageView.setImageBitmap(bitmap);    //读音乐    AssetFileDescriptor assetFileDescriptor = getAssets().openFd("bgm.mp3");    MediaPlayer player = new MediaPlayer();    player.reset();    player.setDataSource(assetFileDescriptor.getFileDescriptor(),assetFileDescriptor.getStartOffset(),assetFileDescriptor.getLength());    player.prepare();    player.start();}</code></pre><hr><p>操作raw目录下的文件  操作res目录下的文件<br>    void testResFile(){<br>        //读音乐<br>        InputStream inputStream = getResources().openRawResource(R.raw.bgm);</p><pre><code>    //读color    getResources().getColor(R.color.blue);    //读String    getResources().getString(R.string.app_name)}</code></pre><hr><p>操作sd卡(外部存储)文件<br>    void testSDCard(){<br>//        File file = new File(“/sdcard/test/a.txt”);//直接写路径,不推荐<br>        String filePath = Environment.getExternalStorageDirectory().getAbsolutePath();<br>        File file = new File(filePath);</p><pre><code>    Environment.getDataDirectory(); //获取安卓中的data数据目录    Environment.getDownloadCacheDirectory(); //获取安卓中download目录 ...}</code></pre><hr><p>drawable放图片,mipmap放头像,layout放布局,values放值</p><p>相同点和区别:<br>放在assets和raw下的文件创建apk时都会原封不动地打在包里,不会再编译成二进制<br>但是assets是纯原封不动,raw系统会自动映射到R文件里的id,可以直接通过R.引用<br>res中不可以再有目录结构</p><h2 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h2><p>特色： 轻量级，独立，隔离，跨平台，多语言接口，安全性<br>对象关系映射ORM<br>public class DatabaseActivity extends AppCompatActivity {</p><pre><code>private SQLiteDatabase mSqLiteDatabase;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_database);    //新建一个数据库文件    DatabaseHelper databaseHelper = new DatabaseHelper(this);    mSqLiteDatabase = databaseHelper.getWritableDatabase();    //Add    findViewById(R.id.add_button).setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View v) {            //IO操作,建议后台操作,直接在onClick里操作容易卡死            //新建键值对            ContentValues contentValues = new ContentValues();            contentValues.put(DatabaseHelper.USERNAME, "无名剑主");            contentValues.put(DatabaseHelper.PASSWORD, "1234567");            long rowNumber = mSqLiteDatabase.insert(DatabaseHelper.TABLE_NAME, null, contentValues);            if (rowNumber != -1) {                Toast.makeText(DatabaseActivity.this, "插入成功", Toast.LENGTH_SHORT).show();            }            queryData();        }    });    findViewById(R.id.delete_button).setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View v) {            //Delete            String whereClauseString = "username=?";            String[] whereArgsString = {"无名剑主"};            mSqLiteDatabase.delete(DatabaseHelper.TABLE_NAME, whereClauseString, whereArgsString);            queryData();        }    });    findViewById(R.id.update_button).setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View v) {            //Update            ContentValues contentValues = new ContentValues();            contentValues.put(DatabaseHelper.PASSWORD, "7654321");            String whereClauseString = "username=?";            String[] whereArgsString = {"无名剑主"};            mSqLiteDatabase.update(DatabaseHelper.TABLE_NAME, contentValues, whereClauseString, whereArgsString);            queryData();        }    });    //事务，批量操作    //开始事务,此时数据库就会被锁定    mSqLiteDatabase.beginTransaction();    try {        //需要的操作        mSqLiteDatabase.setTransactionSuccessful();    } catch (Exception e){        e.printStackTrace();    }finally {        mSqLiteDatabase.endTransaction();    }}private void queryData() {    //Query    //游标    Cursor cursor =    mSqLiteDatabase.query(DatabaseHelper.TABLE_NAME,null,null,null,null,null,null,null);    if(cursor.moveToFirst()){        int count = cursor.getCount();        for (int i = 0; i &lt; count; i++) {            String userName = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.USERNAME));            String password = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseHelper.PASSWORD));            Log.i(MainActivity.class.getSimpleName(),i+":"+userName+"||"+password);        }    }}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>public class DatabaseHelper extends SQLiteOpenHelper {</p><pre><code>public static final String TABLE_NAME = "user";public static final String USERNAME = "username";public static final String PASSWORD = "password";public static final String DATABASE_NAME = "test.db";public DatabaseHelper(Context context) {    super(context, DATABASE_NAME, null, 1);}@Overridepublic void onCreate(SQLiteDatabase db) {    //新建表    db.execSQL("create table " + TABLE_NAME + "(" + USERNAME + " varchar(20) not null," + PASSWORD + " varchar(60) not null);");}@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    //升级数据库}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><pre><code>&lt;Button    android:id="@+id/add_button"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:text="Add" /&gt;&lt;Button    android:id="@+id/delete_button"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:text="Delete" /&gt;&lt;Button    android:id="@+id/update_button"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:text="Update" /&gt;</code></pre><hr><h2 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h2><p>四大组件之一（activity，service，broadcast receiver）<br>应用程序间共享数据的一种方式<br>为存储和获取数据提供了统一的接口<br>Android为常见的一些数据提供了默认的ContentProvider</p><p>定义：<br>Content Provider 将一些特定的应用程序数据供给其他应用程序使用<br>数据可以存储于文件系统，SQLite数据库或其他方式<br>内容提供者继承于ContentProvider 基类，为其他应用程序取用和存储他管理的数据实现了一套标准方法<br>应用程序并不能直接调用这些方法，而是使用ContentResolver对象，调用他的方法作为替代<br>ContentResover可以与任意内容提供者进行会话，与其合作来对所有相关交互通讯进行管理</p><hr><p>public class URIList {</p><pre><code>public static final String CONTENT = "content://";//包名public static final String AUTHORITY = "com.example.sqtian";//表面public static final String USER_URI = CONTENT + AUTHORITY + "/" + DatabaseHelper.USER_TABLE_NAME;public static final String BOOK_URI = CONTENT + AUTHORITY + "/" + DatabaseHelper.BOOK_TABLE_NAME;</code></pre><p>}</p><hr><p>public class DatabaseHelper extends SQLiteOpenHelper {</p><pre><code>public static final String USER_TABLE_NAME = "user_table_name";public static final String USERNAME = "username";public static final String PASSWORD = "password";public static final String DATABASE_NAME = "test.db";public static final String BOOK_TABLE_NAME = "book_table_name";public static final String BOOK_NAME = "book_name";public static final String BOOK_PRICE = "book_price";public DatabaseHelper(Context context) {    super(context, DATABASE_NAME, null, 1);}@Overridepublic void onCreate(SQLiteDatabase db) {    //新建表    db.execSQL("create table " + USER_TABLE_NAME + "(" + USERNAME + " varchar(20) not null," + PASSWORD + " varchar(60) not null);");    db.execSQL("create table " + BOOK_TABLE_NAME + "(" + BOOK_NAME + " varchar(20) not null," + BOOK_PRICE + " varchar(60) not null);");}@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {    //升级数据库}</code></pre><p>}</p><hr><p>public class TestContentProvider extends ContentProvider {</p><pre><code>private static UriMatcher sUriMatcher;private static final int URI_MATCH_USER = 1;private static final int URI_MATCH_BOOK = 2;static {    sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);    // 将content://com.example.sqtian/user_table_name 用int URI_MATCH_USER来代表    // 将content://com.example.sqtian/book_table_name 用int URI_MATCH_BOOK来代表    sUriMatcher.addURI(URIList.AUTHORITY, DatabaseHelper.USER_TABLE_NAME,URI_MATCH_USER);    sUriMatcher.addURI(URIList.AUTHORITY, DatabaseHelper.BOOK_TABLE_NAME,URI_MATCH_BOOK);}private DatabaseHelper mDatabaseHelper;//用代号进行匹配,传入uri得到表名private String getTableName(Uri uri){    int type = sUriMatcher.match(uri);    String tableName = null;    switch(type){        case URI_MATCH_USER:            tableName = DatabaseHelper.USER_TABLE_NAME;            break;        case URI_MATCH_BOOK:            tableName = DatabaseHelper.BOOK_TABLE_NAME;            break;    }    return tableName;}@Overridepublic boolean onCreate() {    mDatabaseHelper = new DatabaseHelper((getContext()));    return false;}@Nullable@Overridepublic Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {    //实现自己的query方法    //先通过uri得知是那张表    String tableName = getTableName(uri);    if(TextUtils.isEmpty(tableName)){        return null;    }    Cursor cursor = mDatabaseHelper.getWritableDatabase()            .query(tableName,projection,selection,selectionArgs,null,null,sortOrder);    return cursor;}@Nullable@Overridepublic String getType(@NonNull Uri uri) {    return null;}@Nullable@Overridepublic Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {    String tableName = getTableName(uri);    if(TextUtils.isEmpty(tableName)){        return null;    }    long id = mDatabaseHelper.getWritableDatabase().insert(tableName,null,values);    //返回一个uri和id拼接后的结果    return ContentUris.withAppendedId(uri,id);}@Overridepublic int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {    String tableName = getTableName(uri);    if(TextUtils.isEmpty(tableName)){        return -1;    }    int count = mDatabaseHelper.getWritableDatabase().delete(tableName, selection, selectionArgs);    //返回的是改变的条数    return count;}@Overridepublic int update(@NonNull Uri uri, @Nullable ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {    String tableName = getTableName(uri);    if(TextUtils.isEmpty(tableName)){        return -1;    }    int count = mDatabaseHelper.getWritableDatabase().update(tableName,values,selection,selectionArgs);    //返回的是改变的条数    return count;}</code></pre><p>}</p><hr><pre><code>    //内容解析器    ContentResolver contentResolver = getContentResolver();</code></pre><p>//        //资源路径<br>//        //content://package_name/table_name/id/row_name<br>//        Uri uri = Uri.parse(“content://com.android.contacts/contacts”);</p><pre><code>    //游标    Cursor cursor = contentResolver.query(Uri.parse(URIList.USER_URI),null,null,null,null);</code></pre><p>//        if(cursor != null &amp;&amp; cursor.moveToFirst()){<br>//            //遍历把数据取出来<br>//        }</p><pre><code>    // ContentProvider 提供者 提供增删改查的方法,query(uri)...</code></pre><hr><h2 id="网络与数据处理"><a href="#网络与数据处理" class="headerlink" title="网络与数据处理"></a>网络与数据处理</h2><p>public class NetworkActivity extends Activity implements View.OnClickListener {</p><pre><code>private Button mButton;private TextView mTextView;private EditText mEditText;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_network);    findViews();    mButton.setOnClickListener(this);    String url = getEditTextUrl();}private void findViews() {    mEditText = findViewById(R.id.address_edit_text);    mTextView = findViewById(R.id.result_text);    mButton = findViewById(R.id.get_data_button);}private String getEditTextUrl() {    return mEditText != null? mEditText.getText().toString():"";}@Overridepublic void onClick(View v) {    switch (v.getId()){        case R.id.get_data_button:            String url = getEditTextUrl();            //请求网络数据,需要manifest设置网络权限            String data = requestData(url);</code></pre><p>//                mTextView.setText(data); 放到异步操作中去处理</p><pre><code>            new RequestNstworkDataTask().execute(url);            break;    }}private String requestData(String urlString) {    try {        URL url = new URL(urlString);        HttpURLConnection connection = (HttpURLConnection) url.openConnection();        connection.setConnectTimeout(30000);        connection.setRequestMethod("GET");        connection.connect();        int responseCode = connection.getResponseCode();        String responseMessage = connection.getResponseMessage();        InputStream inputStream = connection.getInputStream();        Reader reader = new InputStreamReader(inputStream,"UTF-8");        char[] buffer = new char[1024];        reader.read(buffer);        String content = new String(buffer);        return content;    } catch (MalformedURLException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }    return null;}//异步任务处理,同步会卡死class RequestNstworkDataTask extends AsyncTask&lt;String,Integer,String&gt; {    //在后台work之前    @Override    protected void onPreExecute() {        super.onPreExecute();        //主线程    }    @Override    protected String doInBackground(String[] params) {        String result = requestData(params[0]);        return null;    }    @Override    protected void onPostExecute(String result) {        super.onPostExecute(result);        //执行完之后在主线程中        mTextView.setText(result);    }}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><pre><code>&lt;EditText    android:id="@+id/address_edit_text"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:hint="请输入网址"    android:layout_gravity="center_horizontal"    /&gt;&lt;Button    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:text="获取数据"    android:layout_gravity="center_horizontal"    android:id="@+id/get_data_button"/&gt;&lt;TextView    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:id="@+id/result_text"    android:text="This is Result"/&gt;</code></pre><hr><h2 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h2><p>test.xml<br><!--?xml version="1.0" encoding="utf-8"?--><br><web><br>    <item id="0" url="http://www.baidu.com">百度</item><br>    <item id="1" url="http://www.taobao.com">淘宝</item><br>    <item id="2" url="http://www.qq.com">腾讯</item><br>    <item id="3" url="http://www.zhihu.com">知乎</item></web></p>--------------------------------------------------------------------------public class WebURL {<pre><code>private int mID;private String mUrl;private String mContent;public int getID() {    return mID;}public void setID(Integer ID) {    mID = ID;}public String getUrl() {    return mUrl;}public void setUrl(String url) {    mUrl = url;}public String getContent() {    return mContent;}public void setContent(String content) {    mContent = content;}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><p>首先得到一个XMLReader，然后setContentHandler</p><hr><p>public class SAXParseHandler extends DefaultHandler {</p><pre><code>public static final String ITEM = "item";List&lt;WebURL&gt; mWebURLS;WebURL mWebURL;@Overridepublic void startDocument() throws SAXException {    super.startDocument();    mWebURLS = new ArrayList&lt;&gt;();}@Overridepublic void endDocument() throws SAXException {    super.endDocument();}@Overridepublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {    super.startElement(uri, localName, qName, attributes);    mWebURL = new WebURL();    if(TextUtils.equals(localName, ITEM)){        for (int i = 0; i &lt; attributes.getLength(); i++) {            if(TextUtils.equals(attributes.getLocalName(i),"id")){                mWebURL.setID(Integer.valueOf(attributes.getValue(i)));            }            //不同的属性情况        }    }}@Overridepublic void endElement(String uri, String localName, String qName) throws SAXException {    super.endElement(uri, localName, qName);}@Overridepublic void characters(char[] ch, int start, int length) throws SAXException {    super.characters(ch, start, length);}public List&lt;WebURL&gt; gerXMLList() {    return mWebURLS;}</code></pre><p>}</p><hr><p>// parse file by SAX, SAX方法解析XML<br>    private void testSAXParse() throws ParserConfigurationException, SAXException, IOException {</p><pre><code>    //首先创建一个工厂,从工厂里取出一个解析器,解析器读出一个reader    SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();    SAXParser saxParser = saxParserFactory.newSAXParser();    XMLReader xmlReader = saxParser.getXMLReader();    //给reader设置处理器    SAXParseHandler saxParseHandler = new SAXParseHandler();    xmlReader.setContentHandler(saxParseHandler);    //给reader数据流    InputStream inputStream = getResources().openRawResource(R.raw.test);    InputSource inputSource = new InputSource(inputStream);    xmlReader.parse(inputSource);    //得到数据    saxParseHandler.gerXMLList();}</code></pre><hr><p>PULL</p><pre><code>    //pull xml里才能读    XmlResourceParser xmlResourceParser = getResources().getXml(R.xml.test);    try {        while(xmlResourceParser.getEventType() != XmlResourceParser.END_DOCUMENT) {            if (xmlResourceParser.getEventType() == XmlResourceParser.START_TAG){                String tagName = xmlResourceParser.getName();                if(TextUtils.equals(tagName,"item")){                    String id = xmlResourceParser.getAttributeValue(null,"id");                }            }        }    } catch (XmlPullParserException e) {            e.printStackTrace();    }</code></pre><p>DOM</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><pre><code>    //JSON    InputStream is = getResources().openRawResource(R.raw.json);    String jsonString = getStringByInputStream(is);    try {        JSONObject jsonObject = new JSONObject(jsonString);        String title = jsonObject.getString("title");        JSONObject userJSONObject = jsonObject.getJSONObject("user");        userJSONObject.getLong("id");        JSONArray jsonArray = jsonObject.getJSONArray("images");    } catch (JSONException e) {        e.printStackTrace();    }</code></pre><p>GSON<br>        //GSON<br>        Gson gson = new Gson();</p><pre><code>    //fromJson() 把JsonString变成一个对象    UserData userData = gson.fromJson(jsonString, UserData.class);</code></pre><hr><p>public class UserData {<br>    //json.txt中对应的属性</p><pre><code>//SerializedName注解对应@SerializedName("title")private String mTitle;@SerializedName("content")private String mContent;@SerializedName("user")private User mUser;@SerializedName("images")private List&lt;String&gt; mImages;public class User{    @SerializedName("id")    private long mID;    @SerializedName("name")    private String mName;    @SerializedName("avatar")    private String mAvatar;}</code></pre><p>}</p><p>网络状态处理<br>    ConnectivityManager<br>    NetworkInfo</p><p>public class NetworkUtil {</p><pre><code>public void testNetwork(Context context){    //回答网络连接的查询结果,并在网络连接改变时通知应用程序    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);    NetworkInfo networkInfo = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);    boolean isWifiConnection = networkInfo.isConnected();</code></pre><p>//        networkInfo = connectivityManager.getAllNetworkInfo(ConnectivityManager.TYPE_MOBILE);<br>    }<br>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaWebNote01_HTML&#39;</title>
      <link href="/2020/04/19/java-ji-chu/javawebnote01-html/"/>
      <url>/2020/04/19/java-ji-chu/javawebnote01-html/</url>
      
        <content type="html"><![CDATA[<h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><pre><code>* JaveWeb：    使用Java语言开发基于互联网的项目* 软件架构    1. C/S：客户端/服务器端        在用户本地有一个客户端，在远程有一个服务器端        如qq，迅雷        优点: 用户体验好        缺点: 开发,安装,部署,维护 麻烦    2. B/S：浏览器/服务器端        只需要一个浏览器，用户通过不同的网址(URL), 客户访问不同的服务器端程序        优点:开发,安装,部署,维护 简单        缺点: 如果应用过大,用户体验会受到影响,对硬件要求过高* B/S架构    资源分类:        1. 静态资源:            使用静态网页开发技术发布的资源            所用用户访问得到的结果是一样的            如: 文本,图片,音频,视频,HTML,CSS,JavaScript            如果用户请求的是静态资源,那么服务器会直接将静态资源发送给浏览器,            浏览器中内置了静态资源的解析引擎,可以展示这些资源        2. 动态资源:            使用动态网页及时发布的资源            所用用户访问得到的结果可能不一样            如: jsp/servlet,php,asp...            如果用户请求的是动态资源,服务器会执行动态资源,转换为静态资源,再发送给浏览器                </code></pre><p>因此,要学习动态资源,必须先学习静态资源</p><a id="more"></a><p>静态资源:<br>    * HTML: 用于搭建基础网页,展示页面内容<br>    * CSS: 用于美化页面,布局页面<br>    * JavaScript: 控制页面的元素,让页面有一些动态效果</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol><li><p>概念: 最基础的网页开发语言<br> Hyper Text Markup Language 超文本标记语言</p><pre><code> 超文本: 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. 标记语言: 由标签构成的语言. &lt;标签名称&gt; 如 html,xml. 标记语言不是编程语言</code></pre></li><li><p>快速入门:<br> 语法:</p><pre><code> 1. 后缀名必须为html或者htm 2. 标签分为两类     1. 围堵标签: 有开始标签和结束标签. 如&lt;html&gt;&lt;/html&gt;     2. 自闭和标签: 开始标签和结束标签在一起. 如&lt;br/&gt;             3. 标签可以嵌套:     需要正确嵌套,不能你中有我,我中有你 4. 在开始标签中可以定义属性,属性是由键值对构成,值需要用引号(单双都可以)引起来 5. html的标签不区分大小写,建议使用小写</code></pre></li></ol><pre><code>&lt;head&gt;    &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;font color = 'blue'&gt;Hello World&lt;/font&gt;&lt;br/&gt;    &lt;font color = 'red'&gt;Hello World&lt;/font&gt;&lt;/body&gt;</code></pre><ol start="3"><li><p>标签</p><ol><li><p>文件标签: 构成html最基本的标签</p><ul><li>html: html文档的根标签</li><li>head: 头标签,用于指定html文档的一些属性,引入外部资源</li><li>title: 标题标签</li><li>body: 体标签</li></ul></li><li><p>文本标签: 和文本有关的标签</p> <h1> to </h1><h6> 标题标签，字体加大加粗 <p> 段落标签 <br> 换行 </p><hr> 线是一条水平线     属性：         *color：颜色         *width：宽度         *size：粗细         *align：对齐方式 <b>：字体加粗 <i>：字体斜体 <font>: 字体标签，html5已淘汰     *color：颜色          rgb(值1,值2,值3): 值范围:0-255         #值1值2值3:值的范围:00-FF之间     *size：大小<pre><code> *face：字体</code></pre> <center>: 居中标签,已过时 特殊字符查看特殊字符表</center></font></i></b><p></p></h6></li><li><p>图片标签: 展示图片的标签<br> *img: 展示图片</p></li><li><p>列表标签:<br> 有序列表</p><pre><code> *ol *li</code></pre><p> 无序列表</p><pre><code> *ul *li</code></pre></li><li><p>链接标签</p><pre><code> *a: 定义一个超链接     属性:     *href:指定访问资源的url,也可以访问本地资源     *target:指定打开资源的方式</code></pre></li><li><p>div和span:默认没有效果,共css设计</p><pre><code> div: 会换行   块级标签 span: 文本信息在一行展示,行内标签 内联标签</code></pre></li><li><p>语义化标签: html5中为了提高程序可读性,提供了一些标签</p> <header> <footer>    </footer></header></li><li><p>表格标签:<br> *table: 定义表格</p><pre><code> width：宽度 border：边框 cellpadding：定义内容和单元格距离 cellspacing：定义单元格之间的距离，如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式</code></pre><p> *tr: 定义行</p><pre><code> bgcolor：背景色 align：对齐方式</code></pre><p> *td: 定义单元格</p><pre><code> colspan: 合并列,占几列 rowspan: 合并行</code></pre><p> *th: 定义表头单元格</p> : 表格标题标签 :表示表格头部分,没有效果,增加可读性 :表示表格体部分 :表示表格脚部分,永远在最下面展示</li></ol></li></ol><p>案例 旅游网首页<br>早期没有css时,使用table布局<br>某一行只有一个单元格,就用<br>有多个单元格则嵌套表格<table></table>    </p><pre><code>9. 表单标签    表单:        概念: 用于采集用户输入的数据        form            *action: 指定提交数据的url            *method: 指定提交方式                分类: 一个有七种,常见两种                    get:                        1. 请求参数会在地址栏中显示                        2. 请求参数长度有限制                        3. 不太安全                    post:                        1. 请求参数不会在地址栏中显示,会封装在请求体中(HTTP协议后讲解)                        2. 请求参数长度没有限制                        3. 比较安全        表单项中的数据要想被提交: 必须指定name属性    表单项标签:        input: 可以通过type属性值,改变元素展示的样式            type属性:                text: 文本输入框                    value="" 默认文本,输入时不会自动消失                    placeholder = "请输入用户名" 提示文本,输入时会自动消失                password: 密码输入框                radio: 单选框                    注意                    1.要想多个单选框实现单选的效果,则多个单选框的name属性值必须一样                    2. 一般会给每一个单选框提供value属性,指定其被选中后提交的值                    3. checked属性可以指定默认选项                checkbox: 复选框,每一个选项也要提供value属性                file: 文件选择框                hidden: 隐藏域,用于提交一些信息                submit: 提交按钮,将数据上传到服务器                button: 就一个按钮                image: src= "" 图片按钮        lable:指定输入项的文字描述信息            注意:                label的for属性与input的id属性值对应,点击label区域会让input输入框获取焦点        select: 下拉列表            子元素: option, 指定列表项        textarea: 文本域            cols: 指定列数,每一行多少字符            rows: 指定行数</code></pre><h2 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h2><meta name="generator" content="Hexo 3.9.0">    <meta charset="UTF-8">    <title>你好世界</title><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css">    <!--注释-->    <!--    br 换行-->    我有一壶酒，<br>    可以慰风尘。<br>    <b>尽倾江湖中，</b><br>    <i>赠饮天下人。</i><br><pre><code>&lt;br&gt;&lt;font color="red" size="5" face = "楷体"&gt;恒山飞剑&lt;/font&gt;&lt;!--    标题标签 h1-h6--&gt;&lt;h1&gt;恒山飞剑&lt;/h1&gt;&lt;h2&gt;恒山飞剑&lt;/h2&gt;&lt;h3&gt;恒山飞剑&lt;/h3&gt;&lt;h4&gt;恒山飞剑&lt;/h4&gt;&lt;h5&gt;恒山飞剑&lt;/h5&gt;&lt;h6&gt;恒山飞剑&lt;/h6&gt;&lt;!--    段落标签 p--&gt;&lt;p&gt;著名武侠小说家，新派武侠小说泰斗，与金庸、梁羽生、温瑞安并称为中国武侠小说四大宗师。代表作有《多情剑客无情剑》、《绝代双骄》、《英雄无泪》等。古龙把武侠小说引入了经典文学的殿堂，将戏剧、推理、诗歌等元素带入传统武侠，又将自己独特的人生哲学融入其中，使中外经典镕铸一炉，开创了近代武侠小说新纪元，将武侠文学推上了一个新的高峰。&lt;/p&gt;&lt;!--显示一条水平线 hr--&gt;&lt;hr color = "red" width = "200" size = "5" align="left" /&gt;&lt;!--    img 展示一张图片--&gt;&lt;!-- ./表示当前目录, ../ 表示上一级目录    --&gt;&lt;img src="../image/1394699790.jpg" alt="mc" width="900" height="600"/&gt;&lt;!-- 有序列表 ol start 从第几开始 --&gt;&lt;ol type="a" start="3"&gt;    &lt;li&gt;早上起床干的事情&lt;/li&gt;    &lt;li&gt;睁眼&lt;/li&gt;    &lt;li&gt;看手机&lt;/li&gt;    &lt;li&gt;穿衣服&lt;/li&gt;    &lt;li&gt;洗漱&lt;/li&gt;&lt;/ol&gt;&lt;!-- 超链接 a href:跳转页面--&gt;&lt;a href="https://www.baidu.com/"&gt;点我&lt;/a&gt;&lt;!-- target默认self,在本页面打开链接, blank则新建空白页面打开,也可以设置点击图片打开--&gt;&lt;a href="https://www.baidu.com/" target="_blank"&gt;&lt;img src="../image/1.png"&gt;&lt;/a&gt;&lt;!--div: 会换行   块级标签span: 文本信息在一行展示,行内标签 内联标签--&gt;&lt;span&gt;东海仙灵&lt;/span&gt;&lt;span&gt;吐纳法&lt;/span&gt;&lt;div&gt;东海仙灵&lt;/div&gt;&lt;div&gt;吐纳法&lt;/div&gt;&lt;!--    定义表格--&gt;&lt;table border="1" width="50%" cellpadding="0" cellspacing="0" bgcolor="#facbd7" align="center"&gt;    &lt;thead&gt;        &lt;caption&gt;学生信息表&lt;/caption&gt;        &lt;tr&gt;            &lt;th&gt;编号&lt;/th&gt;            &lt;th&gt;姓名&lt;/th&gt;            &lt;th&gt;成绩&lt;/th&gt;        &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;小龙女&lt;/td&gt;            &lt;td&gt;100&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;2&lt;/td&gt;            &lt;td&gt;杨过&lt;/td&gt;            &lt;td&gt;50&lt;/td&gt;        &lt;/tr&gt;    &lt;/tbody&gt;    &lt;tfoot&gt;        &lt;tr&gt;            &lt;td&gt;3&lt;/td&gt;            &lt;td&gt;尹志平&lt;/td&gt;            &lt;td&gt;10&lt;/td&gt;        &lt;/tr&gt;    &lt;/tfoot&gt;&lt;/table&gt;&lt;!--    表单标签    form: 用于定义表单的,可以定义一个范围,范围代表采集用户数据的范围    包裹起来的部分才会提交    --&gt;</code></pre><form action="#" method="get">    <label for="username">用户名:</label> <input type="text" name="username" placeholder="请输入用户名" id="username"><br>    密码: <input type="password" name="password" placeholder="请输入密码"><br>    性别: <input type="radio" name="gender" value="male" checked=""> 男          <input type="radio" name="gender" value="female"> 女    <br><pre><code>爱好: &lt;input type="checkbox" name="hobby" value="sing"&gt; 唱    &lt;input type="checkbox" name="hobby" value="dance"&gt; 跳    &lt;input type="checkbox" name="hobby" value="rap" checked&gt; Rap    &lt;input type="checkbox" name="hobby" value="basketball"&gt; 篮球&lt;br&gt;图片: &lt;input type="file" name="file"&gt;&lt;br&gt;隐藏域: &lt;input type="hidden" name="id" value="aaa"&gt;&lt;br&gt;取色器: &lt;input type="color" name="color"&gt;&lt;br&gt;生日: &lt;input type="date" name="birthday"&gt;&lt;br&gt;邮箱: &lt;input type="email" name="email"&gt;&lt;br&gt;年龄: &lt;input type="number" name="age"&gt;&lt;br&gt;省份:&lt;select name="province"&gt;        &lt;option value=""&gt;--请选择---&lt;/option&gt;        &lt;option value="1"&gt;北京&lt;/option&gt;        &lt;option value="2"&gt;上海&lt;/option&gt;        &lt;option value="3"&gt;江苏&lt;/option&gt;    &lt;/select&gt;自我描述:    &lt;textarea cols="20" rows="5"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;input type="submit" value="登录"&gt;</code></pre></form><pre><code>&lt;!--    自定义表单--&gt;</code></pre><form action="#" method="post">    <pre><code>    &lt;tr&gt;        &lt;td&gt;&lt;label for="password"&gt;密码&lt;/label&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="password" name="password" id="password"&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;label for="email"&gt;Email&lt;/label&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="email" name="email" id="email"&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;label for="name"&gt;姓名&lt;/label&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="text" name="name" id="name"&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;label for="tel"&gt;手机号&lt;/label&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="text" name="tel" id="tel"&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;性别&lt;/td&gt;        &lt;td&gt;&lt;input type="radio" name="gender" value="male"&gt;男            &lt;input type="radio" name="gender" value="female"&gt;女 &lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;label for="birthday"&gt;出生日期&lt;/label&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="date" name="birthday" id="birthday"&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;&lt;label for="checkcode"&gt;验证码&lt;/label&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="text" name="checkcode" id="checkcode"&gt;            &lt;img src="img/"&gt;        &lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table border="1" align="center" width="500">        <tbody><tr>            <td><label for="user">用户名</label></td>            <td><input type="text" name="username" id="user"></td>        </tr></tbody></table></form><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script>----------------------------------------------------------------------------------------<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;AndroidPart1&#39;</title>
      <link href="/2020/04/17/androidpart1/"/>
      <url>/2020/04/17/androidpart1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一个应用"><a href="#第一个应用" class="headerlink" title="第一个应用"></a>第一个应用</h2><p>public class MainActivity extends AppCompatActivity {</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View v) {            //当被点击时出发的行为            Toast.makeText(MainActivity.this,"爱你哦",Toast.LENGTH_LONG).show();        }    });}</code></pre><p>}</p><p>=&gt; Buile APK</p><h2 id="产品提出了一些需求"><a href="#产品提出了一些需求" class="headerlink" title="产品提出了一些需求"></a>产品提出了一些需求</h2><p>新建一个应用<br>    有一个页面<br>    版本号为1.0.0<br>        D:\ASWork\app\build.gradle中修改<br>            versionCode 1<br>            versionName “1.0.0”<br>    修改应用图标<br>        D:\ASWork\app\src\main\AndroidManifest.xml中修改android:icon=”@mipmap/ic_launcher”<br>        首字母不可大写<br>    添加启动界面</p><hr><!--?xml version="1.0" encoding="utf-8"?--><p><linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/splashBackgroundColor" android:gravity="center"></linearlayout></p><pre><code>&lt;TextView    android:id="@+id/title_text_view"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="@string/splash_text"    android:textColor="@color/white"    android:textSize="24sp"/&gt;&lt;Button    android:id="@+id/enter_button"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:layout_marginTop="@dimen/button_margin"    android:text="@string/click"/&gt;</code></pre>    --------------------------------------------------------------------        首页四个按钮,分别进入不同页面传递标题        布局        跳转-------------------------------------------------------------------------        public class SplashActivity extends Activity {<pre><code>//定义按钮开关private Button mEnterButton;//定义点击触发事件private View.OnClickListener mOnClickListener = new View.OnClickListener() {    @Override    public void onClick(View v) {        switch (v.getId()){            case R.id.enter_button:                Intent intent = new Intent(SplashActivity.this,MainActivity.class);                startActivity(intent);                break;        }    }};@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_splash);    mEnterButton = (Button)findViewById(R.id.enter_button);    mEnterButton.setOnClickListener(mOnClickListener);}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>在启动页面停留一秒自动进入下一个页面<br>public class SplashActivity extends Activity {<br>    Handler mHandler = new Handler();<br>    @Override<br>    protected void onCreate(@Nullable Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_splash);</p><pre><code>    //延迟1000ms后跳转    mHandler.postDelayed(new Runnable() {        @Override        public void run() {            //跳转到MainActivity            Intent intent = new Intent(SplashActivity.this,MainActivity.class);            startActivity(intent);        }    },1000);}</code></pre><p>}</p><p>Activity间传递数据<br>SplashActivity<br>        //获取到textView<br>        TextView textView = (TextView) findViewById(R.id.title_text_view);<br>        final String title = textView.getText().toString();</p><pre><code>    //延迟1000ms后跳转    mHandler.postDelayed(new Runnable() {        @Override        public void run() {            //跳转到MainActivity            Intent intent = new Intent(SplashActivity.this,MainActivity.class);            //把数据传递到下一个页面,先获取这个数据            intent.putExtra("title",title);            startActivity(intent);        }    },1000);</code></pre><hr><p>MainActivity<br>        //接收数据,得到intent<br>        Intent intent = getIntent();<br>        if (intent != null){<br>            String title = intent.getStringExtra(“title”);<br>            setTitle(title);<br>        }</p><p>传递对象<br>//对象需要序列化<br>public class UserInfo implements Serializable {<br>    private String mUserName;<br>    private Integer mAge;</p><pre><code>public UserInfo(String mUserName, Integer mAge) {    this.mUserName = mUserName;    this.mAge = mAge;}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>SplashActivity<br>            @Override<br>            public void run() {</p><pre><code>            UserInfo userInfo = new UserInfo("CC",18);            //跳转到MainActivity            Intent intent = new Intent(SplashActivity.this,MainActivity.class);            //把数据传递到下一个页面,先获取这个数据            intent.putExtra("title",title);            intent.putExtra("userInfo", userInfo);            startActivity(intent);        }</code></pre><hr><p>MainActivity<br>        //接收数据,得到intent<br>        Intent intent = getIntent();<br>        if (intent != null){<br>            String title = intent.getStringExtra(“title”);</p><pre><code>        //接收序列化之后的对象        UserInfo userInfo = (UserInfo) intent.getSerializableExtra("userInfo");        setTitle(userInfo.getmUserName());    }</code></pre><hr><p>小问题：<br>intent.putExtra(“title”,title);<br>intent.putExtra(“userInfo”, userInfo);<br>将”title”，”userInfo”提取成常量，方便修改代码，ctrl+alt+C<br>    public static final String TITLE = “title”;<br>    public static final String USER_INFO = “userInfo”;</p><p>获取数据时，传递引用的常量<br>        //接收数据,得到intent<br>        Intent intent = getIntent();<br>        if (intent != null){<br>            String title = intent.getStringExtra(SplashActivity.TITLE);</p><pre><code>        //接收序列化之后的对象        UserInfo userInfo = (UserInfo) intent.getSerializableExtra(SplashActivity.USER_INFO);        setTitle(userInfo.getmUserName());    }</code></pre><p>//ctrl+alt+F 快捷设置全局变量        </p><p>Activity回传数据</p><p>SplashActivity<br>//              startActivity(intent);<br>                //传递出去再接收回传数据<br>                startActivityForResult(intent, REQUEST_CODE);</p><pre><code>@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    super.onActivityResult(requestCode, resultCode, data);    Log.i(TAG,"requestCode:"+requestCode+",resultCode:"+resultCode);    //04-09 03:56:47.971 4435-4435/com.example.sqtian I/SplashActivity: requestCode:9999,resultCode:1234    //判断链接页面是否正确    if(requestCode==REQUEST_CODE&amp;&amp;resultCode==MainActivity.RESULT_CODE){        if(data != null){            String title = data.getStringExtra(TITLE);            mTextView.setText(title);        }    }}</code></pre><hr><p>MainActivity<br>        findViewById(R.id.button_first).setOnClickListener(new View.OnClickListener() {<br>            @Override<br>            public void onClick(View v) {<br>                Intent intent = new Intent();<br>                intent.putExtra(SplashActivity.TITLE,”我是主页,我送礼回来了”);<br>                setResult(RESULT_CODE,intent);<br>                finish();<br>            }<br>        });</p><h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><p>onCreate()<br>onStart()<br>onResume()<br>onPause()<br>onStop()<br>onDestroy()<br>onRestart()<br>    @Override<br>    protected void onStart() {<br>        super.onStart();<br>        Log.i(TAG,”onStart”);<br>    }</p><pre><code>@Overrideprotected void onResume() {    super.onResume();    Log.i(TAG,"onResume");}@Overrideprotected void onPause() {    super.onPause();    Log.i(TAG,"onPause");}@Overrideprotected void onStop() {    super.onStop();    Log.i(TAG,"onStop");}@Overrideprotected void onDestroy() {    super.onDestroy();    Log.i(TAG,"onDestroy");}@Overrideprotected void onRestart() {    super.onRestart();    Log.i(TAG,"onRestart");}</code></pre><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>控件View的通用属性:宽高, 颜色, 边距, 是否可见, 内容居中, 点击事件</p><p>TextView 显示文本 CheckedTextView</p><p>EditText 编辑框 hint password lines singlines maxlines<br>phoneNumber等</p><p>Button 点击按钮 .9图</p><p>ImageButton 图片按钮 extends ImageView</p><p>ImageView 图片视图<br>    <imageview android:id="@+id/imageView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@mipmap/cc_background" android:scaletype="center" app:srccompat="@mipmap/cc1"></imageview></p><p>滑动条<br>    <seekbar android:id="@+id/seekBar" android:layout_width="match_parent" android:layout_height="wrap_content"></seekbar></p><p>进度条<br>    <progressbar android:id="@+id/progressBar" style="?android:attr/progressBarStyleHorizontal" android:layout_width="match_parent" android:layout_height="wrap_content" android:max="100" android:progress="50"></progressbar></p><p>WebView：加载网页<br>ListView：显示列表<br>GridView：显示表格式列表<br>ScrollView：内容可滚动视图<br>SufaceView：非常重要的绘图容器</p><h2 id="Android开发布局详解"><a href="#Android开发布局详解" class="headerlink" title="Android开发布局详解"></a>Android开发布局详解</h2><p>五大布局<br>线性布局：LinearLayout<br>&lt;LinearLayout<br>android:orientation=”vertical” 垂直或者水平<br>&lt;TextView<br>android:layout_weight=”1” 设置占屏幕比重<br>相对布局：RelativeLayout<br>android:layout_alignParentRight=”true” 在页面右边<br>android:layout_above=”@+id/button” 在button的上面<br>android:layout_toRightOf=”@+id/button” 在button的右面<br>android:layout_alignTop=”@+id/button” 与button上边缘对齐<br>android:layout_marginLeft=”100dp” 距离左边界100dp<br>android:paddingLeft=”40dp” 内部文字距离边框40dp</p><p>帧布局：FrameLayout<br>可重叠</p><p>绝对布局：AbsoluteLayout<br>表格布局：TableLayout</p><p>布局技巧与优化<br>官方建议布局层次 10层<br>利用相对布局，尽量减少布局层次</p><p>布局引用相同部分<br>    <include layout="@layout/activity_splash"><br>减少视图层级<br><merge><br>需要时才加载<br><viewstub></viewstub></merge></include></p><p>总结:如何优化布局</p><ol><li>减少层次</li><li>删除无用布局</li><li>布局结构要清晰</li><li>选择合适的布局<br>小技巧:</li><li>不要嵌套多个使用layout_weight属性的LinearLayout</li><li>Android lint</li><li>HierarchyViewer</li></ol><h2 id="无比重要的ListView"><a href="#无比重要的ListView" class="headerlink" title="无比重要的ListView"></a>无比重要的ListView</h2><p>常用属性：<br>    listSelector<br>    scrollingCache<br>    cacheColorHint<br>    fastScrollEnabled<br>    ……<br>常用方法<br>    addHeaderView<br>    addFooterView</p><ol><li>设置ListView视图 activity_listview_demo.xml,list_view呈现列表数据</li><li>ListViewDemoActivity中获得list_view,利用phoneBookAdapter将数据与视图绑定</li><li>phoneBookAdapter继承BaseAdapter,getView方法返回视图</li><li>mLayoutInflater.inflate(R.layout.item_phone_book_friend, null)将页面解析为视图</li><li>从解析的视图中获取TextView控键,和数据进行绑定</li></ol><p>public class ListViewDemoActivity extends Activity {</p><pre><code>//ListView视图作为一个容器，房子private ListView mphoneBookListView;private List&lt;UserInfo&gt; mUserInfos;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_listview_demo);    mphoneBookListView = (ListView)findViewById(R.id.list_view);    mUserInfos = new ArrayList&lt;&gt;();    mUserInfos.add(new UserInfo("西门吹雪", 18));    mUserInfos.add(new UserInfo("李寻欢", 17));    mUserInfos.add(new UserInfo("楚留香", 20));    mUserInfos.add(new UserInfo("陆小凤", 19));    //数据列表和数据绑定,adapter适配器，房子里的柜子，柜子放进房子    final PhoneBookAdapter phoneBookAdapter = new PhoneBookAdapter(ListViewDemoActivity.this, mUserInfos);    //房子(mphoneBookListView)里面有柜子(phoneBookAdapter)，柜子里面有格子(name_text_view)，    //格子里面放数据private String[] mNames = {"西门吹雪","李寻欢"}    mphoneBookListView.setAdapter(phoneBookAdapter);    //刷新更新数据    phoneBookAdapter.notifyDataSetChanged();    //条目点击事件    mphoneBookListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {        @Override        public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {            //点击第一条数据时更新            if(position==0){                // 新建另外一批数据                mUserInfos.clear();                mUserInfos.add(new UserInfo("我是新数据一",20));                mUserInfos.add(new UserInfo("我是新数据二",20));                mUserInfos.add(new UserInfo("我是新数据三",20));                // 替换掉老的数据,数据通过PhoneBookAdapter传递,因此要在PhoneBookAdapter中创建refreshData方法                // 刷新ListView,让他更新自己的视图                phoneBookAdapter.refreshData(mUserInfos);            }            Toast.makeText(ListViewDemoActivity.this, mUserInfos.get(position).getmUserName()+"被点击了",Toast.LENGTH_LONG).show();        }    });    //长按事件    mphoneBookListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {        @Override        public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {            Toast.makeText(ListViewDemoActivity.this, mUserInfos.get(position).getmUserName()+"被长按了",Toast.LENGTH_LONG).show();            return false;        }    });}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>D:\ASWork\app\src\main\res\layout\activity_listview_demo.xml<br>    <textview android:id="@+id/phone_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerhorizontal="true" android:text="@string/phone_book"></textview></p><pre><code>&lt;ListView    android:layout_width="match_parent"    android:layout_height="match_parent"    android:layout_below="@+id/phone_text_view"    android:id="@+id/list_view"/&gt;</code></pre><hr><p>public class PhoneBookAdapter extends BaseAdapter {</p><pre><code>private Context mcontext;//解析layoutprivate LayoutInflater mLayoutInflater;private List&lt;UserInfo&gt; mUserinfos = new ArrayList&lt;&gt;();public PhoneBookAdapter(Context mcontext, List&lt;UserInfo&gt; userInfos) {    this.mcontext = mcontext;    this.mUserinfos = userInfos;    this.mLayoutInflater = (LayoutInflater) mcontext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);}@Overridepublic int getCount() {    // 有多少条数据    return mUserinfos.size();}@Overridepublic Object getItem(int position) {    //返回某一条数据对象    return mUserinfos.get(position);}@Overridepublic long getItemId(int position) {    return position;}/** * 每一行数据显示在界面,用户能够看到,就会调用一次geiView * @param position * @param convertView * @param parent * @return */@Overridepublic View getView(int position, View convertView, ViewGroup parent) {    //返回一个视图, 柜子很多层，把数据塞进柜子，item_phone_book_friend    ViewHolder viewHolder;    //空则创建,非空则直接使用,提高代码复用率    if(convertView == null){        convertView = mLayoutInflater.inflate(R.layout.item_phone_book_friend, null);        viewHolder = new ViewHolder();        //把viewHolder存到convertView里        convertView.setTag(viewHolder);        //把名字数据塞进name_text_view        //从实现保存的ViewHolder中获取控件        viewHolder.nameTextView     = (TextView) convertView.findViewById(R.id.name_text_view);        viewHolder.ageTextView      = (TextView) convertView.findViewById(R.id.age_text_view);        viewHolder.avatarImageView = (ImageView) convertView.findViewById(R.id.avatar_image_view);    }else{        viewHolder = (ViewHolder)convertView.getTag();    }    //和数据进行绑定    viewHolder.nameTextView.setText(mUserinfos.get(position).getmUserName());    viewHolder.ageTextView.setText(mUserinfos.get(position).getmAge()+"岁");    viewHolder.avatarImageView.setImageResource(R.drawable.cc1);    return convertView;}//定义一个类把视图先保存起来class ViewHolder{    TextView nameTextView;    TextView ageTextView;    ImageView avatarImageView;}public void refreshData(List&lt;UserInfo&gt; userInfos){    //刷新数据    mUserinfos = userInfos;    //刷新视图    notifyDataSetChanged();}</code></pre><p>}</p><hr><p>D:\ASWork\app\src\main\res\layout\item_phone_book_friend.xml<br>    <imageview android:layout_width="48dp" android:layout_height="48dp" android:id="@+id/avatar_image_view"></imageview></p><pre><code>&lt;TextView    android:id="@+id/name_text_view"    android:layout_width="fill_parent"    android:layout_height="wrap_content"    android:layout_marginTop="6dp"    android:layout_toRightOf="@+id/avatar_image_view"    android:text="呈呈" /&gt;&lt;TextView    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="18岁"    android:layout_toRightOf="@+id/avatar_image_view"    android:layout_below="@+id/name_text_view"    android:id="@+id/age_text_view"/&gt;</code></pre><hr><h2 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h2><p>显示表格式列表<br>与ListView的相似之处和区别<br>相似之处：<br>    GridView extends AbsListView<br>    ListView extends AbsListView<br>    adapter，数据，点击事件，刷新都一样<br>不同之处：<br>    样式（宫格式）</p><pre><code>&lt;GridView    android:layout_width="fill_parent"    android:layout_height="wrap_content"    android:numColumns="auto_fit"    android:horizontalSpacing="10dp"    android:verticalSpacing="10dp"    android:id="@+id/grid_view"/&gt;</code></pre><h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><p>内容可滚动视图<br>不是列表的内容区滚动<br>只支持垂直滚动<br>里面只能由一个视图<br>    <scrollview android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_below="@+id/grid_view_button" android:layout_centerhorizontal="true"><br>        <linearlayout android:layout_height="match_parent" android:layout_width="match_parent" android:orientation="vertical"></linearlayout></scrollview></p><pre><code>        &lt;Button            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="我是来自于ScrollView中的"/&gt;        &lt;Button            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="我是来自于ScrollView中的"/&gt;        &lt;Button            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="我是来自于ScrollView中的"/&gt;        &lt;Button            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="我是来自于ScrollView中的"/&gt;        &lt;Button            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="我是来自于ScrollView中的"/&gt;    &lt;/LinearLayout&gt;&lt;/ScrollView&gt;</code></pre><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>px：像素点<br>dp：与像素密度密切相关<br>sp：相当于dp（用来修饰文字）<br>dip：=dp</p><p>文字的尺寸一律用sp单位<br>非文字的尺寸一律使用dp单位<br>偶尔需要使用px单位：例如需要在屏幕上画一条细的分割线：1px</p><p>LayoutInflater：将xml布局解析成实际的视图View</p><p>获得LayoutInflater实例的三种方式：<br>        mLayoutInflater = getLayoutInflater();<br>        mLayoutInflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);<br>        mLayoutInflater = LayoutInflater.from(MainActivity.this);</p><pre><code>    View view = mLayoutInflater.inflate(R.layout.activity_main,null);</code></pre><p>提取布局属性：theme&amp;style<br>    Theme是针对窗体级别的，改变窗体样式<br>    Style是针对窗体元素级别的，改变指定控件或者Layout的样式<br>    抽象view的共同属性<br>    可继承</p><pre><code>&lt;style name="CustomTextView"&gt;    &lt;item name="android:background"&gt;@color/blue&lt;/item&gt;    &lt;item name="android:textSize"&gt;20sp&lt;/item&gt;    &lt;item name="android:textColor"&gt;#FF5722&lt;/item&gt;&lt;/style&gt;&lt;style name="StudyTextView" parent="CustomTextView"&gt;    &lt;item name="android:gravity"&gt;right&lt;/item&gt;&lt;/style&gt;</code></pre><h2 id="View如何工作"><a href="#View如何工作" class="headerlink" title="View如何工作"></a>View如何工作</h2><p>构造器-&gt;初始化<br>onMesure() 定大小<br>onLayout() 定位置<br>onDraw() 绘制<br>invalidate() 刷新</p><p>自定义控件的三种主要形式</p><ol><li>继承已有的控件来实现自定义控件 如Button extends TextView</li><li>继承一个布局文件实现 如RelativeLayout</li><li>通过view类来实现    </li></ol><p>练习 需求:<br>    1. 做一个圆形的红色按钮<br>    2. 中间有一个白色的数字<br>    3. 数字起始为20<br>    4. 每点击一次减少1</p><hr><p>D:\ASWork\app\src\main\java\com\example\sqtian\TestRedButton.java</p><p>/**</p><ul><li>自定义控件</li><li><ol><li>做一个圆形的红色按钮</li></ol></li><li><ol start="2"><li>中间有一个白色的数字</li></ol></li><li><ol start="3"><li>数字起始为20</li></ol></li><li><ol start="4"><li>每点击一次减少1</li></ol></li><li>author ：HASEE</li><li>date : 2020/4/13 10:20</li><li>package：com.example.sqtian</li><li>description :</li><li>/</li></ul><p>public class TestRedButton extends View implements View.OnClickListener {</p><pre><code>private Paint mPaint;private Rect mRect;private int mNumber = 20;private int mBackgroundColor;private int mTextSize;private int mTextColor;public TestRedButton(Context context) {    this(context,null,0);}public TestRedButton(Context context, @Nullable AttributeSet attrs) {    this(context, attrs,0);}public TestRedButton(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {    super(context, attrs, defStyleAttr);    init(context,attrs);}@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)public TestRedButton(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {    super(context, attrs, defStyleAttr, defStyleRes);    init(context, attrs);}//绘制@Overrideprotected void onDraw(Canvas canvas) {    super.onDraw(canvas);    //给画布设置颜色</code></pre><p>//        mPaint.setColor(Color.RED);<br>        mPaint.setColor(mBackgroundColor);<br>        //canvas画图，画一个圆<br>        canvas.drawCircle(getWidth()/2,getHeight()/2,getWidth()/2 ,mPaint);<br>        //中间有白色数字<br>        mPaint.setColor(mTextColor);<br>        mPaint.setTextSize(mTextSize);<br>        String text = String.valueOf(mNumber);<br>        //文字边距,起始0,结束text.length()<br>        mPaint.getTextBounds(text,0,text.length(),mRect);<br>        int textWedth = mRect.width();<br>        int textHeight = mRect.height();</p><pre><code>    //把文字画在圆圈中间    canvas.drawText(text,getWidth()/2-textWedth/2,getHeight()/2+textHeight/2,mPaint);}//初始化private void init(Context context,AttributeSet attrs) {    //画布    mPaint = new Paint();    //创建一个新的空矩形    mRect = new Rect();    //点击监听    this.setOnClickListener(this);    //获取自定义的属性    @SuppressLint("Recycle") TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.TestRedButton);    mBackgroundColor = typedArray.getColor(R.styleable.TestRedButton_backgroundColor, Color.RED);    mTextSize = typedArray.getDimensionPixelSize(R.styleable.TestRedButton_textSize,18);//接收dp    mTextColor = typedArray.getColor(R.styleable.TestRedButton_textColor,Color.WHITE);}@Overridepublic void onClick(View v) {    //每点击一次减少一    if(mNumber&gt;0){        mNumber--;    }else{        mNumber = 20;    }    //刷新界面    invalidate();}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><p>D:\ASWork\app\src\main\res\layout\activity_test_red_button.xml</p><p><linearlayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"></linearlayout></p><pre><code>&lt;com.example.sqtian.TestRedButton    android:layout_width="300dp"    android:layout_height="300dp"    app:backgroundColor="@color/blue"    app:textColor="@color/splashBackgroundColor"    app:textSize="100sp"/&gt;</code></pre><hr><p>D:\ASWork\app\src\main\java\com\example\sqtian\TestViewButtonActivity.java</p><p>public class TestViewButtonActivity extends Activity {<br>    @Override<br>    public void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_test_red_button);<br>    }<br>}</p><hr><p>如何自定义视图属性<br>在哪里创建属性: values中新建源文件<br>可以创建哪些属性<br>D:\ASWork\app\src\main\res\values\attrs.xml</p><resources><pre><code>&lt;declare-styleable name="TestRedButton"&gt;    &lt;attr name="backgroundColor" format="color"/&gt;    &lt;attr name="textSize" format="dimension"/&gt;    &lt;attr name="textColor" format="color"/&gt;&lt;/declare-styleable&gt;</code></pre></resources>-----------------------------------------------------------如何使用这些属性    代码中引用    布局中设置<hr><pre><code>    //获取自定义的属性    @SuppressLint("Recycle") TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.TestRedButton);    mBackgroundColor = typedArray.getColor(R.styleable.TestRedButton_backgroundColor, Color.RED);    mTextSize = typedArray.getDimensionPixelSize(R.styleable.TestRedButton_textSize,18);//接收dp    mTextColor = typedArray.getColor(R.styleable.TestRedButton_textColor,Color.WHITE);</code></pre><hr><h2 id="使用Fragment"><a href="#使用Fragment" class="headerlink" title="使用Fragment"></a>使用Fragment</h2><p>Fragment是activity的界面中的一部分<br>多个Fragment组合到一个activity中<br>多个activity中可重用一个Fragment</p><p>activity大房子,Fragment小房间<br>总结:<br>    Fragment是activity相当于模块化的一段activity<br>    具有自己的生命周期,接收自己的事件<br>    在activity运行时被添加或删除</p><p>使用:<br>    1. Create Fragment<br>        onCreate()<br>        onCreateView()<br>        onPause()<br>    2. Add Fragment<br>        Java Code<br>        Layout<br>    3. Replace Fragment</p><p>在使用fragment的时候,先创建了一个fragment,然后为他创建布局,<br>并在oncreateview中返回载入该视图的后返回的view,<br>在activity的布局文件里,使用xml布局,用fragment的name标签直接引用这个fragment,<br>然后居然爆出来该类不是fragment的错误,表示非常不理解,<br>然后把原来fragment换成android.app.fragment就没有这些问题,<br>于是问题也就慢慢的浮出水面,xml中载入的fragment是使用的android.app.fragment,<br>假设我们的fragment引用的是v4包里面的,就会遇到该类不是fragment的问题.<br>解决的办法要么是全都引用android.app.fragment里面的fragment,<br>否则就使用动态载入的方法去载入该fragment,over,问题记录完成</p><hr><p>D:\ASWork\app\src\main\java\com\example\sqtian\TestFragment.java</p><p>//需要继承android.app.Fragment<br>public class TestFragment extends android.app.Fragment {</p><pre><code>private static final String TAG = TestFragment.class.getSimpleName();public static final String ARGUMENT_NAME = "argument_name";public static final String ARGUMENT_NUMBER = "argument_number";private int mNumber;private String mName;//传递参数进去public static TestFragment newInstance(String nameString,int number){    TestFragment testFragment = new TestFragment();    //传递参数    Bundle bundle = new Bundle();    bundle.putString(ARGUMENT_NAME,nameString);    bundle.putInt(ARGUMENT_NUMBER,number);    testFragment.setArguments(bundle);    return testFragment;}@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Log.i(TAG,"onCreate");    //获取参数,抽取成全局变量,在onCreateView中就可以直接使用了    Bundle bundle = getArguments();    if(bundle != null){        mName = bundle.getString(ARGUMENT_NAME);        mNumber = bundle.getInt(ARGUMENT_NUMBER);    }}@Nullable@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {    Log.i(TAG,"onCreateView");    View view = inflater.inflate(R.layout.item_phone_book_friend,container,false);    //把页面中的控件拿出来    TextView nameTextView = (TextView) view.findViewById(R.id.name_text_view);    nameTextView.setText(mName);    return view;}</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><p>布局使用item_phone_book_friend</p><hr><p>public class TestFragmentActivity extends Activity {<br>    @Override<br>    public void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        //1. 通过界面添加<br>        setContentView(R.layout.activity_test_fragment);</p><pre><code>    //2. 通过代码添加    // 获取管理器    FragmentManager fragmentManager = getFragmentManager();    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();    // 创建一个fragment对象实例    TestFragment testFragment =  TestFragment.newInstance("Fragment",15);    //需要传递一个ViewGroup,将其添加到ViewGroup    fragmentTransaction.add(R.id.fragment_view,testFragment).commit();}</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title="}"></a>}</h2><p>D:\ASWork\app\src\main\res\layout\activity_test_fragment.xml</p><p><relativelayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/blue"></relativelayout></p><pre><code>&lt;fragment    android:layout_width="match_parent"    android:layout_height="100dp"    android:name="com.example.sqtian.TestFragment"    android:id="@+id/fragment_test"/&gt;&lt;RelativeLayout    android:layout_width="match_parent"    android:layout_height="400dp"    android:layout_marginTop="200dp"    android:background="@color/white"    android:id="@+id/fragment_view"&gt;&lt;/RelativeLayout&gt;</code></pre><hr><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>多线程与异步</p><p>什么是Handler<br>发送处理Message和Runnable</p><p>用来做什么<br>定时执行Message和MessageQueue<br>在不同线程中执行</p><p>Message和MessageQueue<br>Message<br>2个整形数值：轻量级存储int类型的数据<br>一个Object：任意对象<br>replyTo：线程通信的时候使用<br>What：用户自定义的消息码让接收者识别消息</p><p>MessageQueue<br>Message的队列<br>每一个线程最多只可以拥有一个<br>Thread-&gt;Looper-&gt;MessageQueue</p><p>Lopper<br>消息泵<br>是MessageQueue的管理者<br>Looper.prepare()<br>每一个Looper对象和一个线程关联<br>Looper.myLooper()可以获得当前线程的Looper对象<br>Looper从MessageQueue中取出Message<br>交由Handler的handleMessage进行处理<br>调用Message.recycle()将其放入Message Pool中</p><p>实践:<br>倒计时功能<br>public class HandlerActivity extends Activity {</p><pre><code>public static final int MESSAGE_CODE = 888888;</code></pre><p>//    //先创建一个Handler<br>//    //直接使用Handler内部类容易出现内存泄漏<br>//    Handler mHandler = new Handler(){<br>//        //重写接收消息的方法<br>//        @Override<br>//        public void handleMessage(@NonNull Message msg) {<br>//            super.handleMessage(msg);<br>//            //接收消息<br>//            switch(msg.what){<br>//                case MESSAGE_CODE:<br>//                    int value = (int) msg.obj;<br>//                    mTextView.setText(String.valueOf(value/1000));<br>//<br>//                    //正在使用的message无法再用,重新创建一个msg<br>//                    msg = Message.obtain();<br>//                    msg.arg1 = 0;<br>//                    msg.arg2 = 1;<br>//                    msg.what = MESSAGE_CODE;<br>//                    //倒计时,每次-1s<br>//                    msg.obj = value-1000;<br>//<br>//                    if(value &gt; 0){<br>//                        //大于0时继续倒计时,循环发送消息<br>//                        sendMessageDelayed(msg,1000);<br>//                    }<br>//                    break;<br>//            }<br>//        }<br>//    };<br>    private TextView mTextView;<br>    private TestHandler mTestHandler = new TestHandler(this);</p><pre><code>//public TextView getTextView() {    return mTextView;}@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_handler);    mTextView = (TextView) findViewById(R.id.handler_text_view);    //创建一个Message    Message message = mTestHandler.obtainMessage();    message.arg1 = 0;    message.arg2 = 1;    //消息识别码    message.what = MESSAGE_CODE;    //传递对象    message.obj = 10000;    //发送消息,延迟一秒</code></pre><p>//        mHandler.sendMessageDelayed(message,1000);<br>        //用外部类发送<br>        mTestHandler.sendMessageDelayed(message,1000);</p><pre><code>    //handler还可以定时,延时    mTestHandler.postDelayed(new Runnable() {        @Override        public void run() {        }    },1000);}//用外部类解决内存泄漏问题,继承Handler,activity销毁后,这个类也会自动结束public  static class TestHandler extends Handler{    //弱引用HandlerActivity     public final WeakReference&lt;HandlerActivity&gt; mHandlerActivityWeakReference;    public TestHandler(HandlerActivity activity) {        mHandlerActivityWeakReference = new WeakReference&lt;&gt;(activity);    }    @Override    public void handleMessage(@NonNull Message msg) {        super.handleMessage(msg);        HandlerActivity handlerActivity = mHandlerActivityWeakReference.get();        //接收消息        switch(msg.what){            case MESSAGE_CODE:                int value = (int) msg.obj;                handlerActivity.getTextView().setText(String.valueOf(value/1000));                //正在使用的message无法再用,重新创建一个msg                msg = Message.obtain();                msg.arg1 = 0;                msg.arg2 = 1;                msg.what = MESSAGE_CODE;                //倒计时,每次-1s                msg.obj = value-1000;                if(value &gt; 0){                    //大于0时继续倒计时,循环发送消息                    sendMessageDelayed(msg,1000);                }                break;        }    }}</code></pre><h2 id="-6"><a href="#-6" class="headerlink" title="}"></a>}</h2><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>在后台长时间工作的应用主件,不会提供一个用户界面<br>不是单独的进程,也不是线程, 不能做耗时操作,需要new一个线程才可以做耗时操作<br>两种形式: start,stop  bind,unbind</p><p>public class MusicServiceActivity extends Activity implements View.OnClickListener {</p><pre><code>private Button mStartButton;private Button mStopButton;private MusicService mMusicService;private ServiceConnection mServiceConnection = new ServiceConnection() {    @Override    public void onServiceConnected(ComponentName name, IBinder service) {        //通过Binder获取了Service        MusicService.localBinder locaBinder = (MusicService.localBinder) service;        mMusicService = locaBinder.getService();        if(mMusicService != null){            int progress = mMusicService.getMusicPlayProgress();        }    }    @Override    public void onServiceDisconnected(ComponentName name) {    }};@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_music_service);    mStartButton = findViewById(R.id.start_button);    mStopButton = findViewById(R.id.stop_button);    mStartButton.setOnClickListener(this);    mStopButton.setOnClickListener(this);}@Overridepublic void onClick(View v) {    switch(v.getId()){        case R.id.start_button:            //启动服务            startService(new Intent(MusicServiceActivity.this,MusicService.class));            //bind绑定            bindService(new Intent(MusicServiceActivity.this,MusicService.class),mServiceConnection,BIND_AUTO_CREATE);            break;        case R.id.stop_button:            //如果使用了bind绑定,直接stop就停不掉了,要先解绑            unbindService(mServiceConnection);            //停止服务            stopService(new Intent(MusicServiceActivity.this,MusicService.class));            break;    }}</code></pre><p>}</p><hr><p>IntentService<br>如果想要任务按队列运行,就用IntentService</p><hr><p>public class TestIntentService extends IntentService {<br>    /**<br>     * Creates an IntentService.  Invoked by your subclass’s constructor.<br>     *<br>     * @param name Used to name the worker thread, important only for debugging.<br>     */<br>    public TestIntentService(String name) {<br>        super(name);<br>    }</p><pre><code>@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) {    //不能做太多操作, UI线程  如果&gt;10秒 --&gt; ANR application not response 应用无响应    //如果想做耗时操作,需要新建一个进程    Thread thread = new Thread(new Runnable() {        @Override        public void run() {        }    });    thread.start();    return super.onStartCommand(intent, flags, startId);}@Overrideprotected void onHandleIntent(@Nullable Intent intent) {    // 排队 --&gt; 向MessageQueue 同步操作: 排队领书,处理Intent数据}</code></pre><h2 id="-7"><a href="#-7" class="headerlink" title="}"></a>}</h2><h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p>四大组件之一，广播接收器</p><p>系统使用了很多广播<br>    通知时间改变<br>    电池电量变低<br>    拍摄了照片<br>    改变了语言<br>没有用户界面<br>extends BroadcastReceiver</p><p>需要注册，有两种注册方式<br>    1. 静态注册<br>        在manifest里注册</p><pre><code>    &lt;receiver android:name=".TestBroadcastReceiver"&gt;        &lt;intent-filter&gt;            &lt;action android:name="com.example.sqtian.broadcast"/&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;2. 动态注册    在代码里注册public class SendBroadcastActivity extends Activity {    private  TestBroadcastReceiver mTestBroadcastReceiver = new TestBroadcastReceiver();    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        //动态注册广播        IntentFilter intentFilter = new IntentFilter();        intentFilter.addAction("com.example.sqtian.broadcast");        registerReceiver(mTestBroadcastReceiver,intentFilter);    }}</code></pre><p>BroadcastReceiver生命周期<br>Register<br>SendBroadcast<br>onReceive<br>unRegister</p><p>适当的用，不能滥用广播<br>信息需要很多地方都收到时，可以用</p><hr><p>public class SendBroadcastActivity extends Activity {</p><pre><code>public static final String COM_EXAMPLE_SQTIAN_BROADCAST = "com.example.sqtian.broadcast";private  TestBroadcastReceiver mTestBroadcastReceiver = new TestBroadcastReceiver();private Button mSendBroadcastButton;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_test_broadcast);    //获取broadcastButton    mSendBroadcastButton = (Button) findViewById(R.id.send_broadcast_button);    mSendBroadcastButton.setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View v) {            Intent intent = new Intent();            intent.setAction(COM_EXAMPLE_SQTIAN_BROADCAST);            intent.putExtra("toast","this is my toast of broadcast");            //普通广播            sendBroadcast(intent);</code></pre><p>//                //有序广播,有优先级的,类似intentService<br>//                sendOrderedBroadcast()</p><p>//                //本地广播,只在本应用中的广播<br>//                LocalBroadcastManager</p><pre><code>        }    });}//在onstart中动态注册@Overrideprotected void onStart() {    super.onStart();    //动态注册广播    IntentFilter intentFilter = new IntentFilter();    intentFilter.addAction(COM_EXAMPLE_SQTIAN_BROADCAST);    registerReceiver(mTestBroadcastReceiver,intentFilter);}//在onStop中反注册@Overrideprotected void onStop() {    super.onStop();    unregisterReceiver(mTestBroadcastReceiver);}</code></pre><h2 id="-8"><a href="#-8" class="headerlink" title="}"></a>}</h2><p>D:\ASWork\app\src\main\res\layout\activity_test_broadcast.xml<br>    <button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="BroadcastButton" android:id="@+id/send_broadcast_button"></button></p><hr><p>public class TestBroadcastReceiver extends BroadcastReceiver {<br>    @Override<br>    public void onReceive(Context context, Intent intent) {<br>        // receive broadcast 接收,处理数据</p><pre><code>    //之间不能做耗时操作,new一个线程    if(intent != null){        if(TextUtils.equals(intent.getAction(),SendBroadcastActivity.COM_EXAMPLE_SQTIAN_BROADCAST)){            String toastString = intent.getStringExtra("tot");            Toast.makeText(context,toastString,Toast.LENGTH_LONG).show();        }    }}</code></pre><p>}</p><hr><h2 id="WebView：加载网页"><a href="#WebView：加载网页" class="headerlink" title="WebView：加载网页"></a>WebView：加载网页</h2><p>网页显示器<br>用处：<br>    加载线上url<br>    加载本地html<br>    和JS进行交互<br>    历史记录<br>    导航</p><p>要在manifest中声明权限 <uses-permission android:name="android.permission.INTERNET"></uses-permission></p><hr><p>public class WebViewButtonActivity extends Activity {</p><pre><code>private WebView mWebView;public class TestJSEvent{    @JavascriptInterface    public void showToast(String toast){        Toast.makeText(WebViewButtonActivity.this,toast,Toast.LENGTH_LONG).show();    }}@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_webview);    mWebView = (WebView) findViewById(R.id.web_view);    mWebView.loadUrl("http://www.baidu.com");</code></pre><p>//        // 加载自己的html<br>//        mWebView.loadUrl(“file:///android_asset/HelloWorld.html”);</p><pre><code>    //从百度页面跳转到别的页面,需要与JavaScript交互,打开才可以跳转    mWebView.getSettings().setJavaScriptEnabled(true);    //JS调用原生App方法showToast,即在HelloWorld.html里调用应用里的方法    mWebView.addJavascriptInterface(new TestJSEvent(),"TestApp");</code></pre><p>//        //原生App调用JS<br>//        mWebView.loadUrl(“javascript:(html里方法的名称)”);</p><pre><code>    //让页面在应用内部打开    mWebView.setWebViewClient(new WebViewClient(){        @Override        public boolean shouldOverrideUrlLoading(WebView view, String url) {            //是否要重新加载(拦截页面            //比如一开始访问的网页失效了,404页面,可以重新加载一个页面            if(url.contains("404")){                mWebView.loadUrl("http://www.zhihu.com");            }            return super.shouldOverrideUrlLoading(view, url);        }        @Override        public void onPageStarted(WebView view, String url, Bitmap favicon) {            //页面开始时,可以设置loading动画            super.onPageStarted(view, url, favicon);        }        @Override        public void onPageFinished(WebView view, String url) {            //页面完成后,隐藏的loading动画            super.onPageFinished(view, url);        }    });</code></pre><p>//        mWebView.setWebChromeClient(new WebChromeClient(){<br>//            @Override<br>//            public void onProgressChanged(WebView view, int newProgress) {<br>//                //进度条<br>//                super.onProgressChanged(view, newProgress);<br>//            }<br>//<br>//            @Override<br>//            public void onReceivedTitle(WebView view, String title) {<br>//                // 获取界面的title<br>//                super.onReceivedTitle(view, title);<br>//            }<br>//<br>//            @Override<br>//            public void onShowCustomView(View view, CustomViewCallback callback) {<br>//                super.onShowCustomView(view, callback);<br>//            }<br>//        });</p><pre><code>}//让返回时不会直接退出,而是返回上一网页@Overridepublic void onBackPressed() {    if(mWebView != null &amp;&amp; mWebView.canGoBack()){</code></pre><p>//            //导航<br>//            WebBackForwardList webBackForwardList = mWebView.copyBackForwardList();<br>//<br>//            WebHistoryItem historyItem = webBackForwardList.getItemAtIndex(0);<br>//<br>//            String historyUrl = historyItem.getUrl();</p><pre><code>        //回退        mWebView.goBack();</code></pre><p>//            //前进<br>//            mWebView.goForward();</p><pre><code>    }else{        super.onBackPressed();    }}</code></pre><p>}</p><hr><pre><code>&lt;WebView    android:layout_width="match_parent"    android:layout_height="match_parent"    android:id="@+id/web_view"/&gt;</code></pre><hr><p>更深入的使用：<br>    Cookie<br>    History<br>    页面导航<br>    Hybird<br>    如何拦截网络请求<br>    如何显示进度<br>    调试<br>    ……</p><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>相当于挂件<br>从一个小Demo做起<br>首先新建一个TestWidget extends AppWidgetProvider<br>在AndroidManifest中声明TestWidget<br>在xml目录定义App Widget的初始化xml文件 setting_widget.xml<br>实现Widget具体布局的widget_layout.xml<br>继承AppWidgetProvider类，实现具体的Widget业务逻辑</p><p>public class TestWidget extends AppWidgetProvider {<br>    public static final String WIDGET_BUTTON_ACTION = “widget_button_action”;<br>    //桌面上的插件和应用需要通信，因此使用了广播机制，AppWidgetProvider extends BroadcastReceiver<br>    //广播需要注册，因此Widget也需要注册</p><pre><code>@Overridepublic void onReceive(Context context, Intent intent) {    super.onReceive(context, intent);    //intent不为空且action一致时接收广播信息    if(intent != null &amp;&amp; WIDGET_BUTTON_ACTION.equals(intent.getAction())){        Log.i(WIDGET_BUTTON_ACTION,"be clicked");        RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.widget_layout);        remoteViews.setTextViewText(R.id.widget_text_view,"be clicked");        remoteViews.setTextColor(R.id.widget_text_view, Color.BLUE);        //获取appWidgetManager.updateAppWidget更新控件        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);        //没有appWidgetIds,用另一个传ComponentName的方法        ComponentName componentName = new ComponentName(context,TestWidget.class);        appWidgetManager.updateAppWidget(componentName,remoteViews);    }}@Overridepublic void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {    super.onUpdate(context, appWidgetManager, appWidgetIds);    RemoteViews remoteViews = new RemoteViews(context.getPackageName(),R.layout.widget_layout);    Intent intent = new Intent();    intent.setClass(context,TestWidget.class);    intent.setAction(WIDGET_BUTTON_ACTION);    //未来意图,将要执行的intent,点击以后才会发送广播    PendingIntent pendingIntent = PendingIntent.getBroadcast(context,0,intent,0);    remoteViews.setOnClickPendingIntent(R.id.widget_button,pendingIntent);    //更新控件    appWidgetManager.updateAppWidget(appWidgetIds,remoteViews);}</code></pre><p>}</p><hr><p>&lt;appwidget-provider xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android"</a><br>    android:layout_width=”match_parent”<br>    android:layout_height=”match_parent”<br>    android:minWidth=”140dp”<br>    android:minHeight=”140dp”<br>    android:previewImage=”@drawable/cc1”                   //预览的图片<br>    android:updatePeriodMillis=”200000”                    //更新周期<br>    android:widgetCategory = “home_screen”                 //挂件安装地点<br>    android:initialLayout=”@layout/widget_layout”&gt;</p>--------------------------------------------------------------------------------------------------------<linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"><pre><code>&lt;TextView    android:id="@+id/widget_text_view"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:layout_gravity="center"    android:text="TextView" /&gt;&lt;Button    android:id="@+id/widget_button"    android:layout_gravity="center"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:text="Button" /&gt;</code></pre></linearlayout>--------------------------------------------------------------------------------------<p>其他<br>与service通信<br>Widget控件的交互方法<br>如何做一个桌面播放器Widget</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote12_JDBCDateSource&#39;</title>
      <link href="/2020/04/06/java-ji-chu/javanote12-jdbcdatesource/"/>
      <url>/2020/04/06/java-ji-chu/javanote12-jdbcdatesource/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol><li><p>概念：其实就是一个容器（集合），存放数据库连接的容器<br> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，<br> 从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器</p></li><li><p>好处： 1. 节约资源 2. 用户访问高效</p></li></ol><a id="more"></a><ol start="3"><li><p>实现：</p><ol><li><p>标准接口：DataSource javax.sql报包下</p><ol><li><p>方法:<br> 获取连接: getConnection()<br> 归还连接:如果连接对象Connection是从连接池中获取的,那么调用Connection.close()方法不会再关闭连接,而是归还连接</p></li><li><p>一般我们不去实现它,有数据库厂商来实现</p><ol><li>C3P0: 数据库连接池技术</li><li>Druid: 数据库连接池技术,由阿里巴巴提供</li></ol></li></ol></li></ol></li><li><p>C3P0:<br>步骤1. 导入jar包c3p0-0.9.5.2.jar和mchange-commons-java-0.2.12.jar,同时不要忘记导入数据库驱动jar包</p><ol start="2"><li><p>定义配置文件<br> 名称必须是 c3p0.properties 或者 c3p0-config.xml<br> 路径: 直接将文件放在src目录下</p><pre><code> &lt;property name="driverClass"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/lovelycc?serverTimezone=GMT%2B8&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; 各参数要根据自己配置改</code></pre></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接: getConnection</p></li></ol></li></ol><p>public class C3P0Demo1 {<br>    public static void main(String[] args) throws SQLException {<br>        //1. 创建数据库连接池对象,不传参数,使用默认配置.<br>        // 可以添加不同的配置,通过 new ComboPooledDataSource(“otherc3p0”)创建<br>        DataSource ds = new ComboPooledDataSource();<br>        //2. 获取连接对象<br>        for (int i = 0; i &lt; 11; i++) {<br>            Connection connection = ds.getConnection();<br>            System.out.println(i+”:”+ connection);<br>            if (i==5){<br>                connection.close();<br>            }<br>        }<br>    }<br>}</p><hr><ol start="5"><li><p>Druid<br>步骤1. 导入jar包druid-1.0.9.jar</p><ol start="2"><li><p>定义配置文件:</p><ol><li>properties形式</li><li>可以叫任意名称,放在任意目录下</li></ol></li><li><p>获取数据库连接池对象: 通过工厂来获取 DruidDataSourceFactory.createDataSource(pro)</p></li><li><p>获取连接: ds.getConnection()<br>public class DruidDemo {<br>public static void main(String[] args) throws Exception {<br> //1. 导入jar包<br> //2. 定义配置文件<br> //3. 加载配置文件<br> Properties pro = new Properties();<br> InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(“druid.properties”);<br> pro.load(is);</p><p> //4. 获取连接池对象<br> DataSource ds = DruidDataSourceFactory.createDataSource(pro);<br> //5. 获取连接<br> Connection connection = ds.getConnection();<br> System.out.println(connection);<br>}<br>}</p></li></ol></li></ol><p>定义工具类:<br>    1. 定义一个类 JDBCUtils<br>    2. 提供静态代码块加载配置文件,初始化连接池对象<br>    3. 提供方法<br>        1. 获取连接方法: 通过连接池获取连接<br>        2. 释放资源<br>        3. 获取连接池的方法</p><p>/*<br>    Druid连接池的工具类<br> */<br>public class JDBCUtils2 {<br>    //1. 定义成员变量 DataSource<br>    private static DataSource ds;<br>    static{<br>        try {<br>            //1. 加载配置文件<br>            Properties pro = new Properties();<br>            pro.load(DruidDemo.class.getClassLoader().getResourceAsStream(“druid.properties”));<br>            //2. 获取DataSource<br>            ds = DruidDataSourceFactory.createDataSource(pro);</p><pre><code>    } catch (Exception e) {        e.printStackTrace();    }}/*    获取连接 */public static Connection getConnection() throws SQLException {    return ds.getConnection();}/*    释放资源 */public static void close(ResultSet res, Statement stmt, Connection conn){    if(res != null){        try {            res.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if(stmt != null){        try {            stmt.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if(conn != null){        try {            conn.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}//重载方法public static void close(Statement stmt, Connection conn){    close(null,stmt,conn);}/*    获取连接池的方法 */public static DataSource getDataSource(){    return ds;}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>public class DruidDemo2 {<br>    public static void main(String[] args) throws SQLException {</p><pre><code>/*    完成添加操作,给account表添加一条记录 */    Connection connection = null;    PreparedStatement pstmt = null;    //1. 获取连接     connection = JDBCUtils2.getConnection();    //2. 定义sql    String sql = "insert into account values(0,?,?)";    //3. 获取pstmt对象    pstmt = connection.prepareStatement(sql);    //4. 给?赋值    pstmt.setString(1,"傅红雪");    pstmt.setDouble(2,1000.99);    //5. 执行sql    pstmt.executeUpdate();}</code></pre><p>}</p><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>Spring框架对JDBC的简单封装提供了一个JDBCTemplate对象简化JDBC的开发步骤:     1. 导入jar包    2. 创建JdbcTemplate对象.依赖数据源DataSource        JdbcTemplate template = new JdbcTemplate(ds);    3. 调用方法JdbcTemplate的方法来完成CRUD(增删改查)的操作        update(): 执行DML语句,增删改        queryForMap(): 查询结果将结果封装为map集合,            将列名作为key,将值作为value 将记录封装为一个map集合&lt;String,Object&gt;        queryForList(): 查询结果将结果封装为List集合            将每一条记录封装为一个Map集合,再将Map集合装载到List集合中        query(): 查询结果, 将结果封装为JavaBean对象            query的参数: RowMapper                一般使用BeanPropertyRowMapper&lt;&gt;(Hero.class)实现类,可以完成数据到javaBean的自动封装        queryForObject: 查询结果,将结果封装为对象            一般用于聚合函数的查询</code></pre><p>/*<br>    JdbcTemplate入门<br> */<br>public class JdbcTemplateDemo1 {<br>    public static void main(String[] args) {<br>        //1. 导入jar包<br>        //2. 创建JdbcTemplate对象,可以传入一个DataSource对象<br>        JdbcTemplate template = new JdbcTemplate(JDBCUtils2.getDataSource());<br>        //3. 调用方法<br>        String sql = “update account set balance = 5000 where name = ?”;<br>        int count = template.update(sql, “西门吹雪”);<br>        System.out.println(count);<br>    }<br>}</p><hr><p>练习:<br>    需求:<br>        1. 修改李寻欢身高178<br>        2. 添加一条记录<br>        3. 删除刚才添加的记录<br>        4. 查询id为1的记录,将其封装为Map集合<br>        5. 查询所有的记录,将其封装为List<br>        6. 查询所有的记录,将其封装为Hero对象的List集合<br>        7. 查询总记录数</p><p>public class JdbcTemplateDemo2 {<br>    //junit单元测试,可以让方法独立执行</p><pre><code>//1. 获取JdbcTemplate对象private JdbcTemplate template = new JdbcTemplate(JDBCUtils2.getDataSource());// update执行增删改语句@Testpublic void test1(){    //2. 定义sql    String sql = "update hero set height = ? where name = ?";    //3. 执行sql    int count = template.update(sql,178,"李寻欢");    System.out.println(count);}@Testpublic void test2(){    String sql = "insert into hero values(0,?,?,?,?)";    template.update(sql,"傅红雪",20,65,175);}@Testpublic void test3(){    String sql = "delete from hero where name = ?";    template.update(sql,"傅红雪");}//查询query//4. 查询id为1的记录,将其封装为Map集合@Testpublic void test4(){    String sql = "select * from hero where id = ?";    Map&lt;String,Object&gt; map = template.queryForMap(sql,1);    System.out.println(map);//{ID=1, name=呈呈, age=18, weight=57.0, height=160.0}}@Test//5. 查询所有的记录,将其封装为Listpublic void test5(){    String sql = "select * from hero ";    List&lt;Map&lt;String,Object&gt;&gt; list = template.queryForList(sql);    for (Map&lt;String, Object&gt; stringObjectMap : list) {        System.out.println(stringObjectMap);    }}//6. 查询所有的记录,将其封装为Hero对象的List集合@Testpublic void test6(){    String sql = "select * from hero ";    // 自己实现的RowMapper&lt;Hero&gt;()类</code></pre><p>//        List<hero> list = template.query(sql, new RowMapper<hero>() {<br>//            @Override<br>//            public Hero mapRow(ResultSet resultSet, int i) throws SQLException {<br>//                Hero hero = new Hero();<br>//                int id = resultSet.getInt(“id”);<br>//                String name = resultSet.getString(“name”);<br>//                int age = resultSet.getInt(“age”);<br>//                double weight = resultSet.getDouble(“weight”);<br>//                double height = resultSet.getDouble(“height”);<br>//<br>//                hero.setId(id);<br>//                hero.setName(name);<br>//                hero.setAge(age);<br>//                hero.setWeight(weight);<br>//                hero.setHeight(height);<br>//<br>//                return hero;<br>//            }<br>//        });</hero></hero></p><pre><code>    //别人实现好的    List&lt;Hero&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;&gt;(Hero.class));    for (Hero hero : list) {        System.out.println(hero);    }}//7. 查询总记录数@Testpublic void test7(){    String sql = "select count(id) from hero ";    Long total = template.queryForObject(sql, Long.class);    System.out.println(total);}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote11_JDBC&#39;</title>
      <link href="/2020/04/06/java-ji-chu/javanote11-jdbc/"/>
      <url>/2020/04/06/java-ji-chu/javanote11-jdbc/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><ol><li><p>JDBC基本概念<br> Java DataBase Connectivity<br> Java数据库连接，Java语言操作数据库<br> JDBC本质：官方定义了一套操作所有关系型数据库的规则(接口),各个厂商去实现这套接口,提供数据库驱动jar包.</p><pre><code>       我们可以使用这套接口编程,真正执行的代码时驱动jar包中的实现类</code></pre><p> 期望使用统一的一套Java代码可以操作所有关系型数据库。<br> 每一个厂商写类自己数据库的JDBC实现类</p></li></ol><a id="more"></a><ol start="2"><li><p>快速入门<br> 步骤:</p><pre><code> 1. 导入驱动jar包     1. 复制jar文件到项目的libs目录下     2. 右键--&gt;add as Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql,接受返回结果 7. 处理结果 8. 释放资源</code></pre></li></ol><p>/**</p><ul><li>JDBC快速入门</li><li>/<br>public class JdbcDemo1 {<br>  public static void main(String[] args) throws Exception {<pre><code>  //1. 导入驱动jar包 mysql-connector-java-8.0.19.jar  //2. 注册驱动  Class.forName("com.mysql.cj.jdbc.Driver");  //3. 获取数据库连接对象  Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/lovelycc?serverTimezone=UTC", "root", "root");  //4. 定义sql语句  String sql = "update hero set weight = 57 where id = 1";  //5. 获取执行sql的对象 Statement  Statement statement = connection.createStatement();  //6. 执行sql  int count = statement.executeUpdate(sql);  //7. 处理结果  System.out.println(count);  //8. 释放资源  statement.close();  connection.close();</code></pre>  }<br>}</li></ul><ol start="3"><li><p>详解各个对象</p></li><li><p>DriverManager: 驱动管理对象<br> 功能:</p><pre><code> 1. 注册驱动: 告诉程序该使用哪一个数据库驱动jar     Class.forName("com.mysql.cj.jdbc.Driver");     在com.mysql.cj.jdbc.Driver类中存在静态代码块注册驱动     注意: mysql5之后的驱动jar包可以省略注册驱动的步骤 2. 获取数据库连接     方法: static Connection getConnection(String url, String user, String password)     参数:         url: 指定连接的路径             语法: jdbc:mysql://ip地址(域名):端口号/数据库名称                   jdbc:mysql://localhost:3306/lovelycc                   如果连接本机,端口是默认的3306,可以省略成jdbc:mysql:///lovelycc         user:用户名 root         password:密码 root</code></pre></li><li><p>Connection: 数据库连接对象</p><ol><li>功能:<ol><li>获取执行sql的对象<br> Statement createStatement()<br> PreparedStatement prepareStatement(String sql)</li><li>管理事务:<br> 开启事务: setAutoCommit(boolean autoCommit): 调用该方法设置参数为false,即开启事务<br> 提交事务: commit()<br> 回滚事务: rollback()</li></ol></li></ol></li><li><p>Statement: 执行sql的对象<br> 用于执行静态SQL语句并返回其生成结果的对象</p><ol><li>执行sql<ol><li>boolean execute(String sql): 可以执行任意的sql (了解)</li><li>int executeUpdate(String sql): 执行DML(insert,update,delete)语句,DDL(create,alter,drop)语句<br> 返回值: 影响的行数,可以通过这个影响的行数判断DML语句是否执行成功,返回值&gt;0成功,反之失败</li><li>ResultSet executeQuery(String sql): 执行DQL(select)语句</li></ol></li><li>练习:<ol><li>hero表 添加一条记录</li></ol></li></ol></li></ol><hr><p>/*<br>    hero表练习insert<br> */<br>public class JdbcDemo2 {<br>    public static void main(String[] args) {<br>        Connection connection = null;<br>        Statement statement = null;<br>        //1. 注册驱动<br>        try {<br>            Class.forName(“com.mysql.cj.jdbc.Driver”);<br>            //2. 定义sql<br>            String sql = “insert into hero values(0,’楚留香’,18,60,188)”;<br>            //3. 获取Connection对象<br>            connection = DriverManager.getConnection(“jdbc:mysql://localhost:3306/lovelycc?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8”, “root”, “root”);<br>            //4. 获取执行sql的Statement对象<br>            statement = connection.createStatement();<br>            //5. 执行sql<br>            int count = statement.executeUpdate(sql);<br>            //6. 处理结果,影响的行数<br>            if(count&gt;0){<br>                System.out.println(“添加成功”);<br>            }else{<br>                System.out.println(“添加失败”);<br>            }<br>        } catch (ClassNotFoundException e) {<br>            e.printStackTrace();<br>        } catch (SQLException e) {<br>            e.printStackTrace();<br>        }finally{<br>            //7. 释放资源<br>            //避免空指针异常<br>            if(statement != null){<br>                try {<br>                    statement.close();<br>                } catch (SQLException e) {<br>                    e.printStackTrace();<br>                }<br>            }</p><pre><code>        if(connection != null){            try {                connection.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}</code></pre><p>}</p><hr><pre><code>    2. hero表 修改记录</code></pre><p>String sql = “update hero set name = ‘陆小凤’ where id = 9”;</p><pre><code>    3. hero表 删除一条记录</code></pre><p>String sql = “update hero set name = ‘delete from hero where name = ‘ww’”;</p><pre><code>    4. DDL(create,alter,drop)语句</code></pre><p>String sql = “create table student (id int , name varchar(20))”;<br>…<br>//处理结果 DDL语句statement.executeUpdate返回值一直为0<br>sout(count)</p><pre><code>    tips: 1. The server time... 时区问题: url后面加上serverTimezone=GMT%2B8          2. 中文写进mysql变成???: url后面加上 useUnicode=true&amp;characterEncoding=utf8          最终写成: "jdbc:mysql://localhost:3306/lovelycc?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8"</code></pre><ol start="4"><li><p>ResultSet: 结果集对象, 封装查询结果<br> boolean next(): 游标向下移动一行,判断当前行是否有数据,有数据为true<br> getXxx(): 获取Xxx类型的数据</p><pre><code> 参数: int: 代表列的编号,从1开始 如: getString(1)       String: 代表列名称 如getDouble("weight")</code></pre><p> 使用步骤:</p><ol><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li></ol></li></ol><hr><p>public class JdbcDemo3 {<br>    public static void main(String[] args) {<br>        Connection connection = null;<br>        Statement statement = null;<br>        ResultSet resultSet = null;<br>        //1. 注册驱动<br>        try {<br>            Class.forName(“com.mysql.cj.jdbc.Driver”);<br>            //2. 定义sql<br>            String sql = “select * from hero “;<br>            //3. 获取Connection对象<br>            connection = DriverManager.getConnection(“jdbc:mysql://localhost:3306/lovelycc?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8”, “root”, “root”);<br>            //4. 获取执行sql的Statement对象<br>            statement = connection.createStatement();<br>            //5. 执行sql<br>            resultSet = statement.executeQuery(sql);<br>            //6. 处理结果,影响的行数<br>//            //6.1 游标向下移动一行<br>//            resultSet.next();<br>            //6.2 获取数据</p><pre><code>        //while循环判断        while(resultSet.next()){            int id = resultSet.getInt(1);            String name = resultSet.getString("name");            double weight = resultSet.getDouble("weight");            System.out.println(id+"号选手"+name+"重达"+weight+"KG");        }    } catch (ClassNotFoundException e) {        e.printStackTrace();    } catch (SQLException e) {        e.printStackTrace();    }finally{        //7. 释放资源        //避免空指针异常        if (resultSet != null) {            try {                resultSet.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if(statement != null){            try {                statement.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if(connection != null){            try {                connection.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><pre><code>练习:定义一个方法,查询hero表的数据将其封装为对象,然后装载集合,返回,打印1. 定义Hero类2. 定义方法 public List&lt;Hero&gt; findAll(){}3. 实现方法 select * from hero;</code></pre><p>/*<br>    封装Hero表数据的JavaBean<br> */</p><hr><p>public class Hero {<br>    //定义成封装类比较好,可以接受null<br>    private Integer id;<br>    private String name;<br>    private Integer age;<br>    private Double weight;<br>    private Double height;</p><pre><code>@Overridepublic String toString() {    return "Hero{" +        "id=" + id +        ", name='" + name + '\'' +        ", age=" + age +        ", weight=" + weight +        ", height=" + height +        '}';}public int getId() {    return id;}public void setId(int id) {    this.id = id;}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getAge() {    return age;}public void setAge(int age) {    this.age = age;}public double getWeight() {    return weight;}public void setWeight(double weight) {    this.weight = weight;}public double getHeight() {    return height;}public void setHeight(double height) {    this.height = height;}</code></pre><p>}</p><hr><p>/*<br>    定义一个方法,查询hero表的数据将其封装<br> */<br>public class JdbcDemo4 {<br>    public static void main(String[] args) {<br>        List<hero> list = new JdbcDemo4().findAll();<br>        System.out.println(list);<br>        System.out.println(list.size());</hero></p><pre><code>}/*    查询所有H象 */public List&lt;Hero&gt; findAll(){    Connection connection = null;    Statement statement = null;    ResultSet resultSet = null;    List&lt;Hero&gt; list = null;    //1. 注册驱动    try {        Class.forName("com.mysql.cj.jdbc.Driver");        //2. 定义sql        String sql = "select * from hero ";        //3. 获取Connection对象        connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/lovelycc?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8", "root", "root");        //4. 获取执行sql的Statement对象        statement = connection.createStatement();        //5. 执行sql        resultSet = statement.executeQuery(sql);        //6. 遍历结果集,封装对象,装载集合        list = new ArrayList&lt;Hero&gt;();        //while循环判断        while(resultSet.next()){            int id = resultSet.getInt("ID");            String name = resultSet.getString("name");            int age = resultSet.getInt("age");            double weight = resultSet.getDouble("weight");            double height = resultSet.getDouble("height");            //创建Hero对象,并赋值            Hero hero = new Hero();            hero.setId(id);            hero.setName(name);            hero.setAge(age);            hero.setWeight(weight);            hero.setHeight(height);            //装载集合            list.add(hero);        }    } catch (ClassNotFoundException e) {        e.printStackTrace();    } catch (SQLException e) {        e.printStackTrace();    }finally{        //7. 释放资源        //避免空指针异常        if (resultSet != null) {            try {                resultSet.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if(statement != null){            try {                statement.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if(connection != null){            try {                connection.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }    return list;}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>代码重复度太高<br>抽取JDBC工具类: JDBCUtils<br>目的: 简化书写<br>分析:<br>    1. 抽取注册驱动<br>    2. 抽取一个方法获取连接对象<br>        需求：不想传递参数，太麻烦，还得保证工具类的通用性<br>        解决：配置文件<br>            jdbc.properties<br>                url=<br>                user=<br>                password=<br>    3. 抽取一个方法释放资源</p><p>/*<br>    JDBC工具类<br> */<br>public class JDBCUtils {<br>    private static String url;<br>    private static String user;<br>    private  static String password;<br>    private static  String driver;</p><pre><code>/*    配置文件的读取,只需要读取一次即可拿到这些值.使用静态代码块 */static{    try {        //读取资源文件,获取值.        //1. 创建Properties集合类        Properties pro = new Properties();        //获取src路径下的文件的方式 ---&gt; ClassLoader 类加载器        //如果路径中存在空格，则会报系统找不到路径错误        ClassLoader classLoader = JDBCUtils.class.getClassLoader();        URL res = classLoader.getResource("jdbc.properties");        String path = res.toURI.getPath();//URL对象转换成字符串前，先调用toURI()方法        //2. 加载文件</code></pre><p>//            pro.load(new FileReader(“D:\IntelliJ IDEA Community Edition 2019.3.1\JDBCNote\jdbc\src\jdbc.properties”));<br>                pro.load(new FileReader(path));<br>            //3. 获取数据<br>            url = pro.getProperty(“url”);<br>            user = pro.getProperty(“user”);<br>            password = pro.getProperty(“password”);<br>            driver = pro.getProperty(“driver”);<br>            //注册驱动<br>            Class.forName(driver);<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        } catch (ClassNotFoundException e) {<br>            e.printStackTrace();<br>        } catch (URISyntaxException e) {<br>            e.printStackTrace();<br>        }<br>    }</p><pre><code>/*    获取连接    返回连接对象 */public static Connection getConnection() throws SQLException {    return DriverManager.getConnection(url,user,password);}public static void close(Statement stmt, Connection conn){        if(stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if(conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }}//重载方法public static void close(ResultSet res,Statement stmt, Connection conn){    if(res != null){        try {            res.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if(stmt != null){        try {            stmt.close();        } catch (SQLException e) {            e.printStackTrace();        }    }    if(conn != null){        try {            conn.close();        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>public List<hero> findAll2(){<br>        Connection connection = null;<br>        Statement statement = null;<br>        ResultSet resultSet = null;<br>        List<hero> list = null;</hero></hero></p><pre><code>    //1. 注册驱动    try {        //1. 获取Connection对象        connection = JDBCUtils.getConnection();        //2. 定义sql        String sql = "select * from hero ";        //4. 获取执行sql的Statement对象        statement = connection.createStatement();        //5. 执行sql        resultSet = statement.executeQuery(sql);        //6. 遍历结果集,封装对象,装载集合        list = new ArrayList&lt;Hero&gt;();        //while循环判断        while(resultSet.next()){            int id = resultSet.getInt("ID");            String name = resultSet.getString("name");            int age = resultSet.getInt("age");            double weight = resultSet.getDouble("weight");            double height = resultSet.getDouble("height");            //创建Hero对象,并赋值            Hero hero = new Hero();            hero.setId(id);            hero.setName(name);            hero.setAge(age);            hero.setWeight(weight);            hero.setHeight(height);            //装载集合            list.add(hero);        }    } catch (SQLException e) {        e.printStackTrace();    }finally{        //7. 释放资源        //避免空指针异常        JDBCUtils.close(resultSet,statement,connection);    }    return list;}</code></pre><p>练习:<br>    需求:<br>        1. 通过键盘录入用户名和密码<br>        2. 判断用户是否登录成功<br>            SELECT * FROM USER WHERE username = “” and password = “”;<br>            如果sql有查询结果,则成功,反之失败<br>    步骤:<br>        1. 创建数据库表 user表<br>CREATE TABLE USER(<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    username VARCHAR(32),<br>    PASSWORD VARCHAR(32)<br>);<br>SELECT * FROM USER;<br>INSERT INTO USER VALUES(0,’西门吹雪’,’123’);<br>INSERT INTO USER VALUES(0,’陆小凤’,’456’);<br>SELECT * FROM USER;</p><pre><code>    2. 创建登录方法</code></pre><p>public class JDBCDemo5 {<br>    public static void main(String[] args) {<br>        //1. 键盘录入<br>        Scanner sc = new Scanner(System.in);<br>        System.out.println(“请输入用户名:”);<br>        String username = sc.nextLine();<br>        System.out.println(“请输入密码:”);<br>        String password = sc.nextLine();</p><pre><code>    boolean flag = new JDBCDemo5().login(username, password);    if (flag){        System.out.println("登录成功");    }else{        System.out.println("登陆失败");    }    //2. 调用方法    //3. 判断结果,输出不同语句}/*    登录方法 */public boolean login(String username,String password){    Connection connection = null;    Statement statement = null;    ResultSet resultSet = null;    if (username == null || password == null){        return false;    }    //连接数据库判断是否登陆成功    try {        connection = JDBCUtils.getConnection();        //定义sql        String sql = "select * from user where username = '"+username+"' and password = '"+password+"'";        statement = connection.createStatement();        resultSet = statement.executeQuery(sql);        //判断是否有数据,有则登陆成功        return resultSet.next();    } catch (SQLException e) {        e.printStackTrace();    }finally{        JDBCUtils.close(resultSet,statement,connection);    }    return false;}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><ol start="5"><li><p>PreparedStatement: 执行sql的对象</p><ol><li><p>SQL注入问题: 在拼接sql时,有一些sql的特殊关键字参与字符串拼接,会造成安全性问题</p><ol><li>输入用户名随便,输入密码: a’ or ‘a’ = ‘a<br>select * from user where username = ‘sssss’ and password = ‘a’ or ‘a’ = ‘a’<br>最后恒为true,从而登陆成功</li></ol></li><li><p>解决sql注入问题: 使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL: 参数使用?作为占位符</p></li><li><p>步骤:</p><ol><li><p>导入驱动jar包</p></li><li><p>注册驱动</p></li><li><p>获取数据库连接对象 Connection</p></li><li><p>定义sql<br> 注意: sql的参数使用?作为占位符,如 select * from user where username = ? and password = ?;</p></li><li><p>获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql)</p></li><li><p>给?赋值<br> 方法: setXxx(参数1,参数2);</p><pre><code> 参数1: ?的位置 参数2: ?的值</code></pre></li><li><p>执行sql,接受返回结果,不需要再传递sql语句</p></li><li><p>处理结果</p></li><li><p>释放资源<br>public boolean login(String username,String password){<br>Connection connection = null;<br>PreparedStatement preparedstatement = null;<br>ResultSet resultSet = null;<br>if (username == null || password == null){<br> return false;<br>}<br>//连接数据库判断是否登陆成功<br>try {<br> connection = JDBCUtils.getConnection();<br> //定义sql<br>//            String sql = “select * from user where username = ‘“+username+”‘ and password = ‘“+password+”‘“;<br> String sql = “select * from user where username = ? and password = ?”;</p><p> preparedstatement = connection.prepareStatement(sql);<br> //给问号赋值<br> preparedstatement.setString(1,username);<br> preparedstatement.setString(2,password);<br> //不需要再传递sql了<br> resultSet = preparedstatement.executeQuery();<br> //判断是否有数据,有则登陆成功<br> return resultSet.next();<br>} catch (SQLException e) {<br> e.printStackTrace();<br>}finally{<br> JDBCUtils.close(resultSet,preparedstatement,connection);<br>}<br>return false;<br>}</p></li></ol></li></ol></li></ol><hr><p>注意: 后期都会使用PreparedStatement对象来完成增删改查的操作<br>    1. 可以防止SQL注入<br>    2. 效率更高</p><h2 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h2><pre><code>1. 事务: 一个包含多个步骤的业务操作.如果这个业务操作被事务管理,则这多个步骤要么同时成功,要么同时失败.2. 操作:    开启事务: setAutoCommit(boolean autoCommit): 调用该方法设置参数为false,即开启事务        在执行sql之前开启事务    提交事务: commit()        当所有sql都执行完提交事务    回滚事务: rollback()        在catch中回滚事务3. 使用Connection对象来管理事务</code></pre><p>银行转账案例:</p><p>CREATE TABLE account(<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    NAME VARCHAR(32),<br>    balance DOUBLE<br>);<br>INSERT INTO account VALUES(0,’西门吹雪’,2000.55);<br>INSERT INTO account VALUES(0,’陆小凤’,3000.77);<br>SELECT * FROM account;</p><hr><p>/*<br>    事务操作<br> */<br>public class JDBCDemo6 {<br>    public static void main(String[] args) {<br>        Connection connection = null;<br>        PreparedStatement preparedStatement1 = null;<br>        PreparedStatement preparedStatement2 = null;<br>        try {<br>            connection = JDBCUtils.getConnection();</p><pre><code>        //开启事务, 中间出现异常则停止转账,不然钱就不翼而飞了        connection.setAutoCommit(false);        //陆小凤-500,西门吹雪+500        String sql1 = "update account set balance = balance-? where name = ?";        String sql2 = "update account set balance = balance+? where name = ?";        preparedStatement1 = connection.prepareStatement(sql1);        preparedStatement2 = connection.prepareStatement(sql2);        preparedStatement1.setDouble(1,300);        preparedStatement1.setString(2,"陆小凤");        preparedStatement2.setDouble(1,300);        preparedStatement2.setString(2,"西门吹雪");        preparedStatement1.executeUpdate();        //手动制造异常        int x = 3/0;        preparedStatement2.executeUpdate();        //提交事务        connection.commit();        //改成Exception,不管出现什么异常都进入回滚,回到事务开启之前的状态    } catch (Exception e) {        //事务回滚        try {            if(connection!=null){                connection.rollback();            }        } catch (SQLException ex) {            ex.printStackTrace();        }        e.printStackTrace();    }finally {        JDBCUtils.close(preparedStatement1,connection);        JDBCUtils.close(preparedStatement2,null);    }}</code></pre><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote10_Reflect&#39;</title>
      <link href="/2020/04/02/java-ji-chu/javanote10-reflect/"/>
      <url>/2020/04/02/java-ji-chu/javanote10-reflect/</url>
      
        <content type="html"><![CDATA[<h2 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h2><p>测试分类：<br>    1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值</p><pre><code>2. 白盒测试：需要写代码，关注程序具体的执行流程</code></pre><a id="more"></a><p>junit使用：白盒测试<br>    步骤：<br>    1.定义一个测试类（测试用例）<br>        建议：<br>        测试类名：被测试的类名XXXXTest<br>        包名：XXX.XXX.XX.test<br>    2. 定义测试方法：可以独立运行<br>        建议：<br>        方法名：test测试的方法名 testAdd()<br>        返回值: void<br>        参数列表: 空参<br>    3. 给方法加@Test<br>    4. 导入junit依赖环境</p><pre><code>判定结果: 红色失败,绿色成功一般使用断言操作来处理结果补充:    @Before        修饰的方法会在测试方法之前自动被执行    @After        修饰的方法会在测试方法之后自动被执行</code></pre><p>public class CalculatorTest {<br>    /*<br>        初始化方法<br>        用于资源申请,所有测试方法在执行之前都会先执行该方法<br>     <em>/<br>    @Before<br>    public void init(){<br>        System.out.println(“init…”);<br>    }<br>    /</em><br>        释放资源方法<br>        在所有测试方法执行完后,都会自动执行该方法<br>     <em>/<br>    @After<br>    public void close(){<br>        System.out.println(“close”);<br>    }<br>    /</em><br>        测试add方法<br>     */<br>    @Test<br>    public void testAdd(){<br>        Calcaulator c = new Calcaulator();<br>        int result = c.add(1,2);<br>//        System.out.println(result);</p><pre><code>    //看的是颜色而不是输出结果    //所以一般不会输出,而是断言    Assert.assertEquals(3,result);}@Testpublic void testSub(){    Calcaulator c = new Calcaulator();    int result = c.sub(1,2);    Assert.assertEquals(-1,result);}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="反射-框架设计的灵魂"><a href="#反射-框架设计的灵魂" class="headerlink" title="反射: 框架设计的灵魂"></a>反射: 框架设计的灵魂</h2><p>框架: 半成品软件,可以在框架的基础上进行软件开发,简化编码<br>反射: 将类的各个组成部分封装为其他对象,这就是反射机制<br>    好处:<br>    1. 可以在程序运行过程中,操作这些对象<br>    2. 可以解耦,提高程序的可扩展性</p><p>Java代码在计算机中经历三个阶段<br>Source源代码阶段 .class字节码文件<br>Class类对象阶段 把类的各个组成部分封装成Class类对象<br>Runtime运行时阶段 new </p><p>获取Class对象的方式:</p><ol><li>Class.forName(“全类名”): 将字节码文件加载进内存,返回Class对象<br> 多用于配置文件,将类名定义在配置文件中.读取文件,加载类</li><li>类名.class: 通过类名的属性class来获取<br> 多用于参数的传递</li><li>对象.getClass(): getClass()方法在Object对象中<br> 多用于对象的获取字节码方式</li></ol><hr><p>public class ReflectDemo01 {<br>    public static void main(String[] args) throws Exception {<br>        //1. Class.forName(“全类名”)<br>        Class cls1 = Class.forName(“Note.Person”);<br>        System.out.println(cls1);//class Note.Person</p><pre><code>    //2. 类名.class    Class cls2 = Person.class;    System.out.println(cls2);    //3. 对象.getClass()    Person p = new Person();    Class cls3 = p.getClass();    System.out.println(cls3);    //== 比较三个对象, 说明是同一个对象    System.out.println(cls1 == cls2);//true    System.out.println(cls3 == cls2);//true}</code></pre><p>}</p><p>结论:<br>    同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次,不论通过哪一种方式获取的Class对象都是同一个</p><p>使用Class对象<br>Class对象功能:<br>    获取功能:<br>    1. 获取成员变量们<br>        Field[] getFields(): 只能获取所有public修饰的成员变量<br>        Field getField(String name) 获取指定名称的成员变量</p><pre><code>    Field[] getDeclaredFields(): 获取所有的成员变量,不考虑修饰符    Field getDeclaredField(String name)    Field:成员变量    操作: 1. 设置值 set 2. 获取值 get 3. 忽略访问权限修饰符的安全检查 setAccessible(true): 暴力反射    public class ReflectDemo02 {//1. 获取Person的Class对象public static void main(String[] args) throws Exception {    Class personClass = Person.class;    //获取成员变量    //1. Field[] getFields()    Field[] fields = personClass.getFields();    for (Field field : fields) {        System.out.println(field);    }    //2. Field getField(String name) 获取指定名称的成员变量    Field a = personClass.getField("a");    Person p = new Person();    //设置成员变量的值    a.set(p,"RNG");    //获取成员变量的值    Object value = a.get(p);    System.out.println(value);//RNG    //3. Field[] getDeclaredFields(): 获取所有的成员变量,不考虑修饰符    Field[] declaredFields = personClass.getDeclaredFields();    for (Field declaredField : declaredFields) {        System.out.println(declaredField);    }    //4. Field getDeclaredField(String name)    Field d = personClass.getDeclaredField("age");    //忽略访问权限修饰符的安全检查    d.setAccessible(true);//暴力反射    Object ageValue = d.get(p);    System.out.println(ageValue);}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><pre><code>2. 获取构造方法们    Constructor&lt;?&gt;[] getConstructors()    Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)    Constructor&lt;?&gt;[] getDeclaredConstructors()    Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)    构造方法: 创建对象 newInstance(Object... initargs)    如果使用空参数构造方法创建对象,操作可以简化:Class对象的newinstance方法    //获取构造方法</code></pre><p>public class ReflectDemo03 {<br>    public static void main(String[] args) throws Exception {<br>        Class personClass = Person.class;<br>        //Constructor<t> getConstructor(类&lt;?&gt;… parameterTypes)<br>        Constructor constructor1 = personClass.getConstructor(String.class, int.class);<br>        System.out.println(constructor1);<br>        //创建对象<br>        Object person1 = constructor1.newInstance(“张三”,23);<br>        System.out.println(person1);</t></p><pre><code>    System.out.println("-----------------------");    //空参    Constructor constructor2 = personClass.getConstructor();    System.out.println(constructor2);    Object person2 = constructor2.newInstance();    System.out.println(person2);    //空参简化    Object o = personClass.newInstance();    System.out.println(o);}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><pre><code>3. 获取成员方法们    Method[] getMethods()    Method getMethod(String name, 类&lt;?&gt;... parameterTypes)    Method[] getDeclaredMethods()    Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)    Method:方法对象    执行方法: Object invoke(Object obj,Object... args)    获取方法名称: String getName     //获取成员方法</code></pre><p>public class ReflectDemo04 {<br>    public static void main(String[] args) throws Exception {<br>        Class personClass = Person.class;<br>        //获取指定名称方法,无参<br>        Method eatMethod = personClass.getMethod(“eat”);<br>        Person p = new Person();<br>        //执行方法<br>        eatMethod.invoke(p);</p><pre><code>    //获取指定名称方法,有参    Method eatMethod2 = personClass.getMethod("eat",String.class);    //执行方法    eatMethod2.invoke(p,"饭");    System.out.println("---------------------------");    //获取所有public修饰的方法    Method[] methods = personClass.getMethods();    for (Method method : methods) {        System.out.println(method);//还包括了Object里的方法        String name = method.getName();        System.out.println(name);//方法名    }    //获取类名    String className = personClass.getName();    System.out.println(className);//全类名 Note.Person}</code></pre><p>}<br>}</p><hr><pre><code>4. 获取类名    String getName()</code></pre><h2 id="反射案例"><a href="#反射案例" class="headerlink" title="反射案例"></a>反射案例</h2><p>写一个框架,可以帮助我们创建任意类的对象,并且执行其中任意方法<br>创建一个配置文件</p><p>className=Note.Person<br>methodName=eat</p><h2 id="不改动任何代码的前提下-只要改动配置文件-达到目的"><a href="#不改动任何代码的前提下-只要改动配置文件-达到目的" class="headerlink" title="不改动任何代码的前提下,只要改动配置文件,达到目的"></a>不改动任何代码的前提下,只要改动配置文件,达到目的</h2><p>/*<br>    框架类<br> <em>/<br>public class ReflectTest {<br>    public static void main(String[] args) throws Exception {<br>        //可以使用任意类对象,任意方法<br>        /</em><br>            前提: 不能改变该类的任何代码,传统方法没有意义<br>         */<br>//        Person p = new Person();<br>//        p.eat();</p><pre><code>    /*        写一个框架,在不改变该类任何代码的前提下,帮助我们创建任意对象使用任意方法        实现:        1. 配置文件        2. 反射        步骤:        1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中        2. 在程序中加载读取配置文件        3. 使用反射技术来加载类文件进内存        4. 创建对象        5. 执行方法     */    //1. 加载配置文件    //创建Properties对象    Properties pro = new Properties();    //加载配置文件,转换为一个集合    ClassLoader classLoader = ReflectTest.class.getClassLoader();    InputStream is = classLoader.getResourceAsStream("pro.properties");    pro.load(is);    //2. 获取配置文件中定义的数据    String className = pro.getProperty("className");    String methodName = pro.getProperty("methodName");    //3. 加载该类进内存    Class cls = Class.forName(className);    //4. 创建对象    Object obj = cls.newInstance();    //5. 获取方法对象    Method method = cls.getMethod(methodName);    //执行方法    method.invoke(obj);}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解:"></a>注解:</h2><p>注释: 用文字描述程序,方便阅读.给程序员看的<br>注解: 也是用来说明程序,给计算机看的</p><p>作用分类:<br>编写文档: 通过代码里表示的注解生成文档(api里doc文档)<br>代码分析: 通过注解对代码进行分析<br>编译检查: 通过代码里表示的注解让编译器能够实现基本的编译检查</p><p>JDK中预定义的一些注解<br>@Override: 检测被该注解标注的方法是否是继承自父类<br>@Deprecated: 该注解标注的内容表示已过时,再调用此方法时会有横线划掉<br>@SuppressWarnings: 压制警告,一般传递all SuppressWarnings(“all”)</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>格式:<br>    元注解<br>    public @interface 注解名称{<br>        属性列表;<br>    }</p><p>本质: 注解本质上就是一个接口,该接口默认继承Annotation接口<br>    public interface MyAnno extends java.lang.annotation.Annotation{}</p><p>属性: 接口中可以定义的成员方法<br>    要求:<br>        1. 属性的返回值类型<br>            基本数据类型<br>            String<br>            枚举 enum<br>            注解<br>            以上类型数组<br>        2. 定义了属性,在使用是需要给属性赋值<br>            定义属性时可以使用default关键字默认初始值<br>            如果只要一个属性需要赋值,且名称是value,则value可以省略<br>            数组赋值时,值使用{}包裹,如果数组只有一个值,则{}可以省略</p><p>public @interface MyAnno {<br>    int weight();<br>    String country() default “CN”;<br>}</p><hr><p>@MyAnno(weight = 120,country = “CN”)<br>public class Person(){}</p><p>元注解: 用于描述注解的注解<br>    @Target: 描述注解能够作用的位置<br>        ElementType取值:<br>        TYPE: 可以作用在类上<br>        METHOD: 可以作用于方法上<br>        FIELD: 可以作用于成员变量上</p><pre><code>@Retention: 描述注解被保留的阶段    @Retention(RetentionPolicy.RUNTIME): 作用阶段,一班自定义用RUNTIME@Documented: 描述注解是否被抽取到api文档中@Inherited: 描述注解是否被子类继承,比如Worker类家里MyAnno注解,如果MyAnno有@Inherited,Teacher继承了Worker后,自动有MyAnno注解</code></pre><h2 id="在程序中解析-使用-注解"><a href="#在程序中解析-使用-注解" class="headerlink" title="在程序中解析(使用)注解"></a>在程序中解析(使用)注解</h2><pre><code>1. 获取注解定义位置的对象(Class,Method,Field)2. 获取指定的注解    getAnnotation(class)3. 调用注解中的抽象方法获取配置的属性值</code></pre><p>/**</p><ul><li><p>描述需要执行的类名,和方法名</p></li><li><p>/<br>@Target({ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Pro {</p><p>  String className();<br>  String methodName();</p></li></ul><h2 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h2><p>@Pro(className = “Note.Person”,methodName = “eat”)<br>public class ReflectTest2 {<br>    public static void main(String[] args) throws Exception {<br>        /*<br>            前提: 不能改变该类的任何代码,传统方法没有意义<br>         */</p><pre><code>    //1.解析注解    //1.1 获取该类的字节码文件对象    Class&lt;ReflectTest2&gt; reflectTest2Class = ReflectTest2.class;    //1.2 获取上面的注解    //其实就是在内存中生成了一个该注解接口的子类实现对象    /**     * 就相当于     * public class ProImpl implements Pro{     *         public String className(){     *             return "Note.Person"     *         }     *         public String methodName(){     *             return "eat"     *         }     *     }     */    Pro annotation = reflectTest2Class.getAnnotation(Pro.class);    //1.3 调用注解对象中定义的抽象方法,获取返回值    String className = annotation.className();    String methodName = annotation.methodName();</code></pre><p>//        System.out.println(className);//Note.Person<br>//        System.out.println(methodName);//eat</p><pre><code>    //3. 加载该类进内存    Class cls = Class.forName(className);    //4. 创建对象    Object obj = cls.newInstance();    //5. 获取方法对象    Method method = cls.getMethod(methodName);    //执行方法    method.invoke(obj);}</code></pre><p>}</p><hr><h2 id="注解案例"><a href="#注解案例" class="headerlink" title="注解案例"></a>注解案例</h2><p>/*<br>    小明定义的计算器类<br> */<br>public class MingCalculator {</p><pre><code>//加法@Checkpublic void add(){    System.out.println("1 + 0 =" + (1 + 0));}//减法@Checkpublic void sub(){    System.out.println("1 - 0 =" + (1 - 0));}//乘法@Checkpublic void mul(){    System.out.println("1 * 0 =" + (1 * 0));}//除法@Checkpublic void div(){    System.out.println("1 / 0 =" + (1 / 0));}public void show(){    System.out.println("永无bug");}</code></pre><h2 id="-5"><a href="#-5" class="headerlink" title="}"></a>}</h2><p>@Target(ElementType.METHOD)<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Check {<br>}</p><hr><p>/*<br>    简单的测试框架<br>    当主方法执行后,会自动执行被检测的所有方法<br> */<br>public class TestCheck {</p><pre><code>public static void main(String[] args) throws IOException {    //1. 创建计算器对象    MingCalculator c = new MingCalculator();    //2. 获取字节码文件对象    Class cls = c.getClass();    //3. 获取所有方法    Method[] methods = cls.getMethods();    int number = 0;//出现异常的次数    BufferedWriter bw = new BufferedWriter(new FileWriter("bug.txt"));    for (Method method : methods) {        //4. 判断方法上是否有Check注解        if(method.isAnnotationPresent(Check.class)){            //5. 有就执行            try {                method.invoke(c);            } catch (Exception e) {                //6. 捕获异常                //记录到文件中                number++;                bw.write(method.getName()+"方法出异常了");                bw.newLine();                bw.write("异常的名称:"+e.getCause().getClass().getSimpleName());                bw.newLine();                bw.write("异常的原因:"+ e.getCause().getMessage());                bw.newLine();                bw.write("-------------------");                bw.newLine();            }        }    }    bw.write("本次测试一共出现"+number+"次异常");    bw.flush();    bw.close();}</code></pre><p>}</p><hr><p>小结:</p><ol><li>以后大多数时候,我们会使用注解,而不是自定义注解</li><li>注解给谁用? <ol><li>编译器</li><li>给解析程序用</li></ol></li><li>注解不是程序的一部分,可以理解为注解就是一个标签</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote09_Reference&#39;</title>
      <link href="/2020/04/02/java-ji-chu/javanote09-reference/"/>
      <url>/2020/04/02/java-ji-chu/javanote09-reference/</url>
      
        <content type="html"><![CDATA[<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>如果在Lambda中所指定的操作方案，已经有地方存在相同方案，是否还有必要再写重复逻辑<br>方法引用符: 双冒号::<br>如果Lambda要表达的函数方案已经存在与某个方法的实现中,那么则可以通过双冒号来引用该方法作为Lambda替代者<br>方法引用就是把要做的事情交给别人做,因为别人已经做过了,而Lambda还是自己做</p><a id="more"></a><p>@FunctionalInterface<br>public interface Printable {<br>    //打印字符串的抽向方法<br>    void print(String s);<br>}</p><hr><p>public class Demo01Printable {<br>    //定义一个方法,参数传递Printable接口,对字符串进行打印<br>    public static void printString(Printable p) {<br>        p.print(“HelloWorld”);<br>    }</p><pre><code>public static void main(String[] args) {    printString((s -&gt; {        System.out.println(s);    }));    /*        分析:            Lambda表达式的目的,打印参数传递的字符串            把参数s,传递给了System.out对象,调用out对象中的方法println对字符串进行了输出            注意:                1. System.out对象已经存在                2. println方法也已经存在            所以我们可以使用方法引用来优化Lambda表达式            可以使用System.out方法直接调用println方法     */    printString(System.out::println);//replace lambda with method reference}</code></pre><p>}</p><h2 id="通过对象名引用成员方法"><a href="#通过对象名引用成员方法" class="headerlink" title="通过对象名引用成员方法"></a>通过对象名引用成员方法</h2><p>/*<br>    通过对象名引用成员方法<br>    使用前提是对象是已经存在的,成员方法也是已经存在<br>    就可以使用对象名来引用成员方法</p><p> */<br>public class Demo01ObjectMethodReference {<br>    //定义一个方法,方法的参数传递Printable接口<br>    public static void printString(Printable p){<br>        p.print(“Hello”);<br>    }</p><pre><code>public static void main(String[] args) {    //调用printString方法,方法的参数Printable是一个函数式接口    printString((s -&gt; {        //创建MethodRerObject对象        MethodRerObject obj = new MethodRerObject();        //调用成员方法        obj.printUpperCaseString(s);    }));    /*        使用方法引用优化Lambda        对象是已经存在的MethodRerObject        成员方法也是已经存在的printUpperCaseString        所以可以使用对象名引用成员方法     */    MethodRerObject obj = new MethodRerObject();    printString(obj::printUpperCaseString);}</code></pre><p>}</p><h2 id="通过类名引用静态成员方法"><a href="#通过类名引用静态成员方法" class="headerlink" title="通过类名引用静态成员方法"></a>通过类名引用静态成员方法</h2><p>类存在,静态成员方法也已经存在<br>就可以通过类名直接引用静态成员方法</p><p>@FunctionalInterface<br>public interface Calcable {<br>    //定义一个抽象方法,传递一个整数,对整数进行绝对值计算,并返回<br>    int calsAbs(int number);<br>}</p><hr><p>public class Demo01StaticMethodReference {<br>    public static int method(int number, Calcable c){<br>        return c.calsAbs(number);<br>    }</p><pre><code>public static void main(String[] args) {    //调用方法,传递计算绝对值的整数,和Lambda表达式    int number = method(-10,(n)-&gt;{        //绝对值计算        return Math.abs(n);    });    System.out.println(number);    /*        使用方法引用优化Lambda表达式        Math类已经存在        abs计算绝对值的静态方法也已经存在        所以可以直接引用     */    int number2 = method(-10, Math::abs);    System.out.println(number2);}</code></pre><p>}</p><h2 id="通过super引用成员方法"><a href="#通过super引用成员方法" class="headerlink" title="通过super引用成员方法"></a>通过super引用成员方法</h2><p>如果存在继承关系,当Lambda中需要出现super调用时,也可以使用引用方法进行替代<br>@FunctionalInterface<br>//定义一个见面的函数式接口<br>public interface Greetable {<br>    void greet();<br>}</p><hr><p>//定义一个父类<br>public class Human {<br>    public void sayHello(){<br>        System.out.println(“Hello,I’m Human”);<br>    }<br>}</p><hr><p>public class Man extends Human {<br>    @Override<br>    public void sayHello() {<br>        System.out.println(“Hello,I’m Man”);<br>    }</p><pre><code>//定义一个方法传递Greetable接口public void method(Greetable g){    g.greet();}public void show(){    //调用method方法,方法的参数Greetable时应该函数式接口    method(()-&gt;{        //创建Human对象        Human h = new Human();        //调用父类的sayHello方法        h.sayHello();    });    //因为有子父类关系,所以存在一个关键字super,代表父类,可以直接使用super调用父类的成员方法    method(()-&gt;{        super.sayHello();    });    method(super::sayHello);}public static void main(String[] args) {    new Man().show();}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="通过this引用成员方法"><a href="#通过this引用成员方法" class="headerlink" title="通过this引用成员方法"></a>通过this引用成员方法</h2><p>如果需要引用的方法就是当前类中的成员方法，那么可以使用this::成员方法的格式来使用方法引用<br>//定义一个富有的函数式接口<br>@FunctionalInterface<br>public interface Richable {<br>    //定义一个想买什么就买什么的方法<br>    void buy();<br>}</p><hr><p>/*<br>    通过this引用本类的成员方法<br> */<br>public class Husband {<br>    //定义一个买房子的方法<br>    public void buyHouse(){<br>        System.out.println(“北京二环内买一套四合院”);<br>    }</p><pre><code>//定义一个结婚的方法,参数传递Richable接口public void marry(Richable r){    r.buy();}//定义一个非常高兴的方法public void soHappy(){</code></pre><p>//        //调用结婚的方法<br>//        marry(()-&gt;{<br>//            //使用this调用本类买房子的方法<br>//            this.buyHouse();<br>//        });</p><pre><code>/*    this已经存在    本类的方法也已经存在    直接使用this引用本类的成员方法buyHouse */    marry(this::buyHouse);}public static void main(String[] args) {    new Husband().soHappy();}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><h2 id="类的构造器引用"><a href="#类的构造器引用" class="headerlink" title="类的构造器引用"></a>类的构造器引用</h2><p>由于构造器的名称与类名完全一样,并不固定,所以构造器引用使用类名称::new 的格式表示</p><p>@FunctionalInterface<br>public interface PersonBuilder {<br>    //定义一个方法,根据传递的姓名,创建Person对象<br>    Person buildPerson(String name, int age);<br>}</p><hr><p>/*<br>    类的构造器引用<br> */<br>public class Demo {</p><pre><code>public static void printName(String name,int age, PersonBuilder pb){    Person person = pb.buildPerson(name,age);    System.out.println(person.getName());}public static void main(String[] args) {    printName("西门吹雪",18,(String name,int age)-&gt;{        return new Person(name,age);    });    /*        构造方法new Person(String name,int age)已知        创建对象已知        就可以使用Person引用new创建对象     */    printName("李寻欢",19,Person::new);}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><h2 id="数组的构造器引用"><a href="#数组的构造器引用" class="headerlink" title="数组的构造器引用"></a>数组的构造器引用</h2><p>/*<br>    定义一个创建数组的函数式接口<br> */<br>@FunctionalInterface<br>public interface ArrayBuilder {<br>    //定义一个创建int类型数组的方法,参数传递数组长度<br>    int[] builderArray(int length);<br>}</p><hr><p>/*<br>    数组的构造器引用<br> <em>/<br>public class Demo02 {<br>    /</em><br>    定义一个方法<br>    方法的参数传递创建数组的长度和ArrayBuilder接口<br>    方法内部根据传递的长度使用ArrayBuilder中的方法创建数组并返回<br>     */<br>    public static int[] createArray(int length,ArrayBuilder ab){<br>        return ab.builderArray(length);<br>    }</p><pre><code>public static void main(String[] args) {    //调用createArray方法,传递数组的长度和Lambda表达式    int[] arr1 = createArray(10,(len)-&gt;{        return new int[len];    });    System.out.println(arr1.length);//10    /*        使用方法引用优化        已知创建的式int[]数组        数组的长度也已知     */    int[] arr2 = createArray(10,int[]::new);    System.out.println(arr2.length);//10}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote08_Stream&#39;</title>
      <link href="/2020/04/02/java-ji-chu/javanote08-stream/"/>
      <url>/2020/04/02/java-ji-chu/javanote08-stream/</url>
      
        <content type="html"><![CDATA[<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>/*<br>    使用传统的方式遍历集合，对集合中的数据进行过滤</p><p> */</p> <a id="more"></a><p>public class Demo01List {<br>    public static void main(String[] args) {<br>        //创建一个List集合存储姓名<br>        List<string> list = new ArrayList&lt;&gt;();<br>        list.add(“张无忌”);<br>        list.add(“周芷若”);<br>        list.add(“赵敏”);<br>        list.add(“张强”);<br>        list.add(“张三丰”);</string></p><pre><code>    //对list集合中的元素进行过滤,只要以张开头的元素,存储到一个新的集合中    List&lt;String&gt; listA = new ArrayList&lt;&gt;();    for (String s : list) {        if(s.startsWith("张")){            listA.add(s);        }    }    //对ListA过滤,只要姓名长度为三    List&lt;String&gt; listB = new ArrayList&lt;&gt;();    for (String s : listA) {        if(s.length()==3){            listB.add(s);        }    }    for (String s : listB) {        System.out.println(s);    }}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>/*<br>    使用Stream流的方式,遍历集合,对集合中的数据进行过滤<br>    关注的是做什么而不是怎么做<br> */<br>public class Demo02Stream {<br>    public static void main(String[] args) {<br>        List<string> list = new ArrayList&lt;&gt;();<br>        list.add(“张无忌”);<br>        list.add(“周芷若”);<br>        list.add(“赵敏”);<br>        list.add(“张强”);<br>        list.add(“张三丰”);</string></p><pre><code>    list.stream()        .filter(name-&gt;name.startsWith("张"))        .filter(name-&gt;name.length()==3)        .forEach(name-&gt; System.out.println(name));}</code></pre><p>}</p><p>整体来看，流式思想类似于工厂车间的生产流水线<br>Stream流是一个来自数据源的元素队列<br>元素是特定类型的对象，形成一个队列<br>数据源：流的来源，可以是集合，数组等<br>pipelining：之间操作都会返回流对象本身。这样多个操作可以串联成一个管道，对操作进行优化<br>内部迭代：流可以直接调用遍历方法</p><p>1.3 获取流<br>所以Collection集合都可以通过stream默认方法获取流<br>Stream接口的静态方法of可以获取数组对应的流<br>public class Demo02GetStream {<br>    public static void main(String[] args) {<br>        //把集合转换为Stream流<br>        List<string> list = new ArrayList&lt;&gt;();<br>        Stream<string> stream1 = list.stream();</string></string></p><pre><code>    Set&lt;String&gt; set = new HashSet&lt;&gt;();    Stream&lt;String&gt; stream2 = set.stream();    Map&lt;String,String&gt; map = new HashMap&lt;&gt;();    //获取键,存储到一个Set集合中    Set&lt;String&gt; keySet = map.keySet();    Stream&lt;String&gt; stream3 = keySet.stream();    //获取值,存储到一个Collection集合    Collection&lt;String&gt; values = map.values();    Stream&lt;String&gt; stream4 = values.stream();    //获取键值对,entrySet    Set&lt;Map.Entry&lt;String,String&gt;&gt; entries = map.entrySet();    Stream&lt;Map.Entry&lt;String,String&gt;&gt; stream5 = entries.stream();    //把数组转换为Stream流    Stream&lt;Integer&gt; stream6 = Stream.of(1,2,3,4,5);    //可变参数可以传递数组    Integer[] arr = {1,2,3,4,5};    Stream&lt;Integer&gt; stream7 = Stream.of(arr);}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>1.4 常用方法<br>延迟方法：返回值类型仍然是Stream接口自身类型的方法，因此支持链式调用。除了终结方法，其余方法均为延迟方法<br>终结方法：返回值类型不再是Stream接口自身类型的方法，不再支持链式调用。常用有count，forEach</p><p>逐一处理：forEach<br>/*<br>    forEach方法用来遍历流中的数据<br>    是一个终结方法,遍历之后就不能再调用Stream流中的其他方法<br>    该方法接收一个Consumer接口函数,会将每一个流元素交给该函数进行处理,Consumer接口可传递Lambda表达式</p><p> */<br>public class Demo02Stream_forEach {<br>    public static void main(String[] args) {<br>        //获取一个Stream流<br>        Stream<string> stream = Stream.of(“张三”, “李四”, “王五”, “赵六”, “田七”);<br>//        //使用forEach遍历<br>//        stream.forEach((String name) -&gt; {<br>//            System.out.println(name);<br>//        });<br>        //化简<br>        stream.forEach(name -&gt;System.out.println(name));<br>    }<br>}</string></p><hr><p>过滤：filter<br>/*<br>    过滤:filter,接收Predicate接口<br> */<br>public class Demo03Stream_filter {<br>    public static void main(String[] args) {<br>        Stream<string> stream = Stream.of(“张三丰”,”张无忌”,”西门吹雪”,”周芷若”,”赵敏”);<br>        //对Stream流中的元素进行过滤,只要姓张的<br>//        Stream<string> stream2 = stream.filter((String name)-&gt;{<br>//            return name.startsWith(“张”);<br>//        });<br>        //简化<br>//        Stream<string> stream2 = stream.filter(name-&gt; name.startsWith(“张”));<br>//        stream2.forEach(name-&gt; System.out.println(name));<br>        //链式<br>        stream.filter(name-&gt; name.startsWith(“张”))<br>            .forEach(name-&gt; System.out.println(name));<br>    }<br>}</string></string></string></p><hr><p>Stream流属于管道流，只能被消费(使用)一次<br>第一个Stream流调用完毕后,数据就会流到下一个Stream上,此时第一个流已经使用完毕,就会关闭<br>所以第一个流不能再调用方法了</p><p>映射:map<br>如果需要将流中的元素映射到另一个流中，可以使用map方法<br>需要Function函数式接口<br>public class Demo04Stream_map {<br>    public static void main(String[] args) {<br>        Stream<string> stream = Stream.of(“1”,”2”,”3”,”4”);<br>        //使用map方法,把字符串类型的整数,转换为Integer类型的整数<br>        Stream<integer> stream2 = stream.map((String s)-&gt;{<br>            return Integer.parseInt(s);<br>        });<br>        //遍历Stream2流<br>        stream2.forEach(i-&gt; System.out.println(i));<br>    }<br>}</integer></string></p><hr><p>统计个数：count<br>计数流中的元素个数<br>/*<br>    long count();<br>    count是一个终结方法,返回值是一个long类型的整数<br> */<br>public class Demo05Stream_count {<br>    public static void main(String[] args) {<br>        ArrayList<integer> list = new ArrayList&lt;&gt;();<br>        list.add(1);<br>        list.add(2);<br>        list.add(3);<br>        list.add(4);<br>        list.add(5);<br>        list.add(6);<br>        list.add(7);<br>        Stream<integer> stream = list.stream();<br>        long count = stream.count();<br>        System.out.println(count);<br>    }<br>}</integer></integer></p><hr><p>取用前几个：limit<br>对流进行截取，只取用前n个。<br>/*<br>    limit是一个延迟方法,用于截取流中的元素<br> */<br>public class Demo06Stream_limit {<br>    public static void main(String[] args) {<br>        String[] arr = {“西门吹雪”,”叶孤城”,”陆小凤”,”楚留香”,”李寻欢”,””};<br>        Stream<string> stream = Stream.of(arr);<br>        Stream<string> stream2 = stream.limit(3);//前三个<br>        stream2.forEach(name-&gt; System.out.println(name));<br>    }<br>}</string></string></p><hr><p>跳过前几个：skip<br>public class Demo07Stream_skip {<br>    public static void main(String[] args) {<br>        String[] arr = {“西门吹雪”,”叶孤城”,”陆小凤”,”楚留香”,”李寻欢”};<br>        Stream<string> stream = Stream.of(arr);<br>        //使用skip方法跳过前3个元素<br>        Stream<string> stream2 = stream.skip(3);//跳过前三<br>        stream2.forEach(name-&gt; System.out.println(name));//楚留香,李寻欢<br>    }<br>}</string></string></p><hr><p>组合：concat<br>public class Demo08Stream_concat {<br>    public static void main(String[] args) {<br>        Stream<string> stream1 = Stream.of(“西门吹雪”, “叶孤城”, “陆小凤”, “楚留香”, “李寻欢”);<br>        Stream<string> stream2 = Stream.of(“杨过”, “小龙女”, “郭靖”, “黄蓉”, “周伯通”);<br>        //合并<br>        Stream<string> concat = Stream.concat(stream1, stream2);<br>        concat.forEach(name-&gt; System.out.println(name));<br>    }<br>}</string></string></string></p><hr><p>练习：集合元素处理<br>传统方法：<br>/*<br>    现有两个ArrayList集合存储队伍当中的多个成员姓名，要求使用传统for循环<br>    1. 第一个队伍只要名字为3个字的成员姓名，存储到一个新集合中<br>    2. 第一个队伍筛选之后，只要前3个人，存储到一个新集合<br>    3. 第二个队伍只要姓张的成员姓名，存储到一个新集合<br>    4. 第二个队伍筛选之后不要前2个人，存储到一个新集合中<br>    5. 将两个队伍合并为一个队伍，存储到一个新集合中<br>    6. 根据姓名创建Person对象，存储到一个新集合中<br>    7. 打印整个队伍的Person对象信息</p><p> */<br>public class Demo01StreamTest {<br>    public static void main(String[] args) {<br>        //第一支队伍<br>        ArrayList<string> one = new ArrayList&lt;&gt;();<br>        one.add(“西门吹雪”);<br>        one.add(“陆小凤”);<br>        one.add(“叶孤城”);<br>        one.add(“李寻欢”);<br>        one.add(“楚留香”);<br>        ArrayList<string> one1 = new ArrayList&lt;&gt;();<br>        for (String name : one) {<br>            if(name.length()==3){<br>                one1.add(name);<br>            }<br>        }</string></string></p><pre><code>    ArrayList&lt;String&gt; one2 = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 3; i++) {        one2.add(one1.get(i));    }    //第二支队伍    ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;();    two.add("杨过");    two.add("郭襄");    two.add("小龙女");    two.add("郭靖");    two.add("郭嘉");    two.add("郭奕");    two.add("黄蓉");    ArrayList&lt;String&gt; two1 = new ArrayList&lt;&gt;();    for (String name : two) {        if(name.startsWith("郭")){            two1.add(name);        }    }    ArrayList&lt;String&gt; two2 = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 2; i++) {        two2.add(two1.get(i));    }    ArrayList&lt;String&gt; all = new ArrayList&lt;&gt;();    all.addAll(one2);    all.addAll(two2);    ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;();    for (String name : all) {        list.add(new Person(name,18));    }    for (Person person : list) {        System.out.println(person);    }}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>Stream流<br>public class Demo02StreamTest {<br>    public static void main(String[] args) {<br>        //第一支队伍<br>        ArrayList<string> one = new ArrayList&lt;&gt;();<br>        one.add(“西门吹雪”);<br>        one.add(“陆小凤”);<br>        one.add(“叶孤城”);<br>        one.add(“李寻欢”);<br>        one.add(“楚留香”);</string></p><pre><code>    Stream&lt;String&gt; oneStream = one.stream().filter(name-&gt;name.length()==3).limit(3);    //第二支队伍    ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;();    two.add("杨过");    two.add("郭襄");    two.add("小龙女");    two.add("郭靖");    two.add("郭嘉");    two.add("郭奕");    two.add("黄蓉");    Stream&lt;String&gt; twoStream = two.stream().filter(name-&gt;name.startsWith("郭")).limit(2);    Stream.concat(oneStream,twoStream)        .map(name-&gt;new Person(name,18))        .forEach(person-&gt; System.out.println(person));}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote07_TCPIP&#39;</title>
      <link href="/2020/03/30/java-ji-chu/javanote07-tcpip/"/>
      <url>/2020/03/30/java-ji-chu/javanote07-tcpip/</url>
      
        <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>1.1 软件结构<br>C/S结构：全称Client/Server结构，客户端和服务器结构。QQ迅雷等<br>B/S结构：全称Browser/Server结构，浏览器和服务器结构。谷歌火狐<br>1.2 网络通信协议<br>计算机在连接和通信时要遵守一定的规则,这些连接和通信的规则被称作网络通信协议,<br>通信双方必须同时遵守才能完成数据交换</p><p>TCP/IP协议:定义了计算机如何连入英特网,以及数据如何在他们之间传输的标准<br>内部包含一系列的用于处理数据通信的协议,并采用了4层的分层模型,每一层都呼叫他的下一层所提供的协议来完成自己的需求<br>物理层 -&gt; 数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层</p><a id="more"></a><p>1.3 协议分类<br>UDP:无连接通信协议,即在数据传输时,数据的发送端和接收端不建立逻辑链接.<br>当一台计算机像另一台计算机发送数据时,发送端不会确认接收端是否存在,就会发出数据,<br>同样接收端在收到数据时,也不会向发送端反馈是否收到数据</p><p>UDP协议消耗资源小,通信效率高,所以通常用于音频视频和普通数据的传输<br>特点: 数据被限制在64kb以内,超过这个范围就不能发送了</p><p>TCP:传输控制协议,面向连接的通信协议,传输数据之前,在发送端和接收端建立逻辑连接,然后再传输数据,<br>他提供了两台计算机之间可靠无差错的数据传输<br>在TCP连接中必须要明确客户端与服务器端,有客户端向服务器发出连接请求,每次连接的创建都要经过三次握手</p><ol><li>客户端向服务器端发出连接请求,等待服务器确认</li><li>服务器端向客户端回送一个响应,通知客户端收到了连接请求</li><li>客户端再次向服务器端发送确认信息,确认连接<br>TCP协议可以保证传输数据的安全,所以应用十分广泛,例如下载文件,浏览网页</li></ol><p>1.4 网络编程三要素</p><ol><li>协议:计算机网络通信必须遵守的规则</li><li>IP地址:指互联网协议地址,IP地址用来给一个网络中的计算机设备做唯一的编号.<br>IP地址分类: <pre><code>  IPV4:一个32位的二进制数,通常分为4段,表示成a.b.c.d的形式,例如192.168.65.100 其中abcd都是0-255之间的十进制整数,最多可以表示42亿个  IPV6:为了扩大地址空间,128位二进制数,分成16个字节,分成8段</code></pre>查看本机IP地址:ipconfig<br>检查网络是否连通:ping 192.168.1.102</li></ol><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>端口号是一个逻辑端口,我们无法直接看到,可以使用一些软件查看端口号<br>当我们使用网络软件一打开,那么操作系统就会为网络软件随机分配一个端口号<br>或者网络软件打开的时候和系统要指定的端口号<br>端口号两个字节组成,取值范围0-65535之间<br>注意:1024之前的端口号我们不能使用,已经被系统分配给已知的网络软件了,网络软件的端口号不能重复</p><p>使用IP地址加端口号,就可以保证数据正确无误地发送到对方计算机地指定软件上了</p><p>常用的端口号:</p><ol><li>80端口: 网络端口,<a href="http://www.baidu.com:80" target="_blank" rel="noopener">www.baidu.com:80</a> 正确的网址<pre><code>             www.baidu.com:70 错误的网址</code></pre></li><li>数据库: mysql:3306 oracle:1521</li><li>tomcat服务器: 8080</li></ol><h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><p>2.1 概述<br>TCP通信能实现两台计算机之间的数据交互,通信的两端,要严格区分为客户端与服务器<br>两端通信时步骤:</p><ol><li>服务端程序需要事先启动,等待客户端的连接</li><li>客户端主动连接服务器端,连接成功才能通信.服务端不可以主动连接客户端<br>客户端与服务器端建立一个逻辑连接,这个连接中包含一个对象,<br>这个对象就是IO对象,客户端与服务器端使用IO对象进行通信<br>通信数据不仅仅是字符,所以IO对象是字节流对象</li></ol><p>步骤:<br>服务器端: ip:端口号 SeverSocket类<br>2. 服务器读取客户端发送的数据<br>InputStream: 你好服务器<br>3. 服务器端给客户端发送数据<br>OutputStream:收到谢谢<br>Socket s1 = sever.accept();                        Socket s2 = sever.accept();<br>| |<br>| | 连接通路,IO流对象<br>| |<br>客户端 ip:端口号 Socket类</p><ol><li>客户端给服务器发送数据<br>OutputStream: 你好服务器</li><li>客户端读取服务器端发送的数据<br>InputStream:收到谢谢</li></ol><p>客户端和服务器端进行一个数据交互,需要4个IO流对象</p><p>服务器必须明确两件事情:</p><ol><li>多个客户端同时和服务器进行交互,服务器必须明确和哪个客户端进行的交互<br> 在服务器端accept方法获取到请求客户端的对象</li><li>服务器本身没有IO流,使用客户端Socket中提供的IO流和客户端交互</li></ol><h2 id="客户端代码实现"><a href="#客户端代码实现" class="headerlink" title="客户端代码实现"></a>客户端代码实现</h2><p>/*<br>    TCP通信的客户端：向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据<br>    表示客户端的类：<br>        java.net.Socket：此类实现客户端套接字。套接字是两台机器间通信的端点。<br>        套接字：包含了IP地址和端口号的网络单位</p><pre><code>构造方法：    Socket(String host，int port) 创建一个流套接字并将其连接到指定主机上的指定端口号    参数：        String host：服务器主机的名称/服务器的IP地址        int port：服务器的端口号成员方法：    OutputStream getOutputStream() 返回此套接字的输出流    InputStream getInputStream() 返回此套接字的输入流    void close() 关闭此套接字实现步骤:    1. 创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号    2. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象    3. 使用write方法给服务器发送数据    4. 使用Socket中的方法getInputStream()获取网络字节输入流InputStream对象    5. read方法读取服务器回写的数据    6. 释放资源(Socket)注意:    1. 客户端与服务器交互,必须使用Socket中提供的网络流,不能使用自己创建的流对象    2. 当我们创建客户端对象Socket时,就回去请求服务器和服务器经过三次握手建立连接通路        这时如果服务器没有启动,就会抛出异常        如果服务器已经启动,就可以进行交互</code></pre><p> */<br>public class TCPClient {<br>    public static void main(String[] args) throws IOException {<br>        //1. 创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号<br>        Socket socket = new Socket(“192.168.1.102”,8848);<br>        //2. 获取网络字节输出流<br>        OutputStream outputStream = socket.getOutputStream();<br>        //3. 给服务器放松数据<br>        outputStream.write(“你好服务器”.getBytes());<br>        //4. 使用Socket中的方法getInputStream()获取网络字节输入流InputStream对象<br>        InputStream inputStream = socket.getInputStream();<br>        //5. read方法读取服务器回写的数据<br>        byte[] bytes = new byte[1024];<br>        int len =inputStream.read(bytes);<br>        System.out.println(new String(bytes,0,len));<br>        //6.释放资源<br>        socket.close();<br>    }<br>}</p><h2 id="服务器端代码"><a href="#服务器端代码" class="headerlink" title="服务器端代码"></a>服务器端代码</h2><p>/*<br>    TCP通信的服务器端:接收客户端的请求,读取客户端发送的数据,给客户端回写数据<br>    表示服务器的类:<br>        java.net.ServerSocket:此类实现服务器套接字<br>        构造方法:<br>            ServerSocket(int port) 创建绑定到特定端口的服务器套接字<br>        成员方法:<br>            Socket accept() 倾听并接受到此套接字的连接</p><pre><code>    服务器实现步骤:    1. 创建服务器ServerSocket对象和系统要指定的端口号    2. 使用ServerSocket对象中的方法accept,获取到请求的客户端对象Socket    3. 使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象    4. 使用read方法读取客户端发送的数据    5. 使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象    6. 使用write方法回写数据    7. 释放资源(Socket,ServerSocket)</code></pre><p> */<br>public class TCPServer {<br>    public static void main(String[] args) throws IOException {<br>        ServerSocket serverSocket = new ServerSocket(8848);<br>        Socket socket = serverSocket.accept();<br>        InputStream is = socket.getInputStream();<br>        byte[] bytes = new byte[1024];<br>        int len =is.read(bytes);<br>        System.out.println(new String(bytes,0,len));<br>        OutputStream os = socket.getOutputStream();<br>        os.write(“收到谢谢”.getBytes());</p><pre><code>    socket.close();    serverSocket.close();}</code></pre><p>}</p><h2 id="文件上传案例"><a href="#文件上传案例" class="headerlink" title="文件上传案例"></a>文件上传案例</h2><p>TCP通信的文件上传<br>原理：客户端读取本地的文件，把文件上传到服务器，服务器再把上传的文件保存到服务器的硬盘上</p><ol><li>客户端使用本地的字节输入流读取要上传的文件</li><li>客户端使用网络字节输出流，把读取到的文件上传到服务器</li><li>服务器使用网络字节输入流，读取客户端上传的文件</li><li>服务器使用本地字节输出流，把读取到的文件，保存到服务器的硬盘上</li><li>服务器使用网络字节输出流，给客户端回写一个上传成功</li><li>客户端使用网络字节输入流读取服务器回写的数据</li><li>释放资源</li></ol><p>注意：<br>    客户端和服务器和本地硬盘进行读写，需要使用自己创建的字节流对象（本地流）<br>    客户端和服务器之间进行读写，必须使用Socket中提供的字节流对象（网络流）</p><p>/*<br>    文件上传案例的服务器端:读取客户端上传的文件,保存到服务器的硬盘,给客户端回写上传成功<br>    明确:<br>        数据源:客户端上传的文件<br>        目的地:服务器的硬盘 F:\upload</p><p> <em>/<br>public class TCPServer2 {<br>    public static void main(String[] args) throws IOException {<br>        //    1. 创建一个服务器对象,和系统要指定的端口号<br>        ServerSocket server = new ServerSocket(8848);<br>        //    2. 使用accept方法,获取Socket对象<br>        /</em><br>            优化:<br>            让服务器一直处于监听状态(死循环accept方法)<br>            有一个客户端上传文件就保存一个文件<br>            while(true)<br>         */<br>        while(true){<br>            Socket socket = server.accept();</p><pre><code>        /*            优化:                使用多线程技术,提高程序的效率                有一个客户端上传文件,就开启一个线程,完成文件的上传                run方法不能throw                只能改成try...catch了         */        new Thread(new Runnable() {            //完成文件的上传            @Override            public void run() {                try {                    //     3. 获取网络字节输入流                    InputStream is = socket.getInputStream();                    //    4. 判断文件夹是否存在                    File file = new File("F:\\upload");                    if(!file.exists()){                        file.mkdirs();                    }    /*        优化:        自定义一个文件的命名规则:防止同名的文件被覆盖        规则:域名+毫秒值+随机数     */                    String fileName = "itcast"+System.currentTimeMillis() + new Random().nextInt(999999)+".jpg";                    //    5. 创建本地字节输出流对象</code></pre><p>//        FileOutputStream fos = new FileOutputStream(file+”\1.jpg”);<br>                        FileOutputStream fos = new FileOutputStream(file+”\“+fileName);<br>                        //    6. 使用网络字节输入流中的read方法<br>                        int len = 0;<br>                        byte[] bytes = new byte[1024];<br>                        while((len = is.read(bytes))!=-1){<br>                            //    7. 使用本地字节输入流中的write方法<br>                            fos.write(bytes,0,len);<br>                        }<br>                        //    8. 使用socket对象中的方法获取网络字节输出流<br>                        //    9. 使用网络字节输出流中的write方法回写上传成功<br>                        socket.getOutputStream().write(“上传成功”.getBytes());<br>                        fos.close();</p><pre><code>                } catch (IOException e) {                    e.printStackTrace();                }finally{                    try {                        socket.close();                    } catch (IOException e) {                        e.printStackTrace();                    }                }            }        }).start();    }    //服务器不需要再关闭了    //server.close();}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>/*<br>    文件上传案例的客户端读取本地文件，上传到服务器，读取服务器回写的数据<br>    明确：<br>        数据源：E:\图片\1.jpg<br>        目的地:服务器<br> */<br>public class TCPClient2 {<br>    public static void main(String[] args) throws IOException {<br>        //1. 创建一个本地字节输入流<br>        FileInputStream fis = new FileInputStream(“E:\图片\1.jpg”);<br>        //2. 创建一个客户端Socket对象,绑定IP地址和端口号<br>        Socket socket = new Socket(“192.168.1.102”,8848);<br>        //3. 获取网络字节输出流对象<br>        OutputStream os = socket.getOutputStream();<br>        //4. 使用本地字节输入流中的read方法<br>        int len = 0;<br>        byte[] bytes = new byte[1024];<br>        while((len = fis.read(bytes))!=-1){<br>            //5. 使用网络字节输出流中的write方法<br>            os.write(bytes,0,len);<br>        }</p><pre><code>    /*        阻塞状态问题解决:上传完文件,给服务器写一个结束标记        void shutdownOutput() 禁用此套接字的输出流        对于 TCP 套接字,任何以前写入的数据都将被发送,并且后跟TCP的正常连接终止序列     */    socket.shutdownOutput();    //6. 获取网络字节输入流对象    InputStream is = socket.getInputStream();    //7. 使用网络字节输入流中的read方法读取服务器回写的数据    while((len = is.read(bytes))!=-1){        System.out.println(new String(bytes,0,len));    }    //8. 释放资源    fis.close();    socket.close();}</code></pre><p>}</p><hr><h2 id="模拟BS服务器分析"><a href="#模拟BS服务器分析" class="headerlink" title="模拟BS服务器分析"></a>模拟BS服务器分析</h2><p>浏览器访问 <a href="http://192.168.1.102:8080/Algorithms/web/TSQ.html" target="_blank" rel="noopener">http://192.168.1.102:8080/Algorithms/web/TSQ.html</a><br>=&gt;<br>GET /Algorithms/web/TSQ.html HTTP/1.1<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-Hans-CN,zh-Hans;q=0.8,en-IE;q=0.5,en;q=0.3<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362<br>Accept-Encoding: gzip, deflate<br>Host: 192.168.1.102:8080<br>Connection: Keep-Alive</p><p>/*<br>    创建BS版的TCP服务器<br>    <a href="http://192.168.1.102:8080/Algorithms/web/TSQ.html" target="_blank" rel="noopener">http://192.168.1.102:8080/Algorithms/web/TSQ.html</a></p><p> <em>/<br>public class TCPServer3 {<br>    public static void main(String[] args) throws IOException {<br>        ServerSocket serverSocket = new ServerSocket(8080);<br>        /</em><br>            浏览器解析服务器回写的html页面,页面中如果有图片,浏览器就会单独开启一个线程,去读取服务器的图片<br>            我们就得让服务器一直处于监听状态,客户端请求一次,服务器回写一次<br>         */</p><pre><code>    while(true){        Socket socket = serverSocket.accept();        new Thread(new Runnable() {            @Override            public void run() {                try {                    InputStream is = socket.getInputStream();                    //        byte[] bytes = new byte[1024];                    //        int len =0;                    //        while((len=is.read(bytes))!=-1){                    //            System.out.println(new String(bytes,0,len));                    //        }                    //把网络输入字节流转换为字符缓冲输入流                    BufferedReader br = new BufferedReader(new InputStreamReader(is));                    //把客户端请求信息的第一行读取出来 GET /Algorithms/web/TSQ.html HTTP/1.1                    String line = br.readLine();                    //切割读取信息,只要中间部分/Algorithms/web/TSQ.html                    String[] arr = line.split(" ");                    //再把路径前的杠去掉,截取Algorithms/web/TSQ.html                    //??怎么相对路径不行呢??                    String htmlpath = "D:\\IntelliJ IDEA Community Edition 2019.3.1\\"+arr[1].substring(1);                    //创建一个本地字节输入流,构造方法中绑定读取的html路径                    FileInputStream fis = new FileInputStream(htmlpath);                    //使用Socket中的方法获取网络字节输出流                    OutputStream os = socket.getOutputStream();                    //写入HTTP协议响应头,固定三行写法                    os.write("HTTP/.1 200 0k\r\n".getBytes());                    os.write("Content-Type:text/html\r\n".getBytes());                    //必须写入空行,否则浏览器不解析                    os.write("\r\n".getBytes());                    //一读一写,复制文件,把服务器读取的html文件回写到客户端                    byte[] bytes = new byte[1024];                    int len =0;                    while((len=fis.read(bytes))!=-1){                        os.write(bytes,0,len);                    }                    //释放资源                    fis.close();                } catch (IOException e) {                    e.printStackTrace();                }finally {                    try {                        socket.close();                    } catch (IOException e) {                        e.printStackTrace();                    }                }            }        }).start();    }    //serverSocket.close();}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote06_IOStream&#39;</title>
      <link href="/2020/03/26/java-ji-chu/javanote06-iostream/"/>
      <url>/2020/03/26/java-ji-chu/javanote06-iostream/</url>
      
        <content type="html"><![CDATA[<h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><p>I：input<br>O：output<br>流：数据，一个字符=2个字节=16个二进制位<br>java.io<br>字节流：一切文件数据存储时都是以二进制数字的形式保存的</p><p>字节输出流:java.io.OutputStream,此抽象类是表示输出字节流的所有类的超类<br>定义了一些子类共性的成员方法:<br>void close()<br>关闭此输出流并释放与此流相关联的任何系统资源。<br>void flush()<br>刷新此输出流并强制任何缓冲的输出字节被写出。<br>void write(byte[] b)<br>将 b.length字节从指定的字节数组写入此输出流。<br>void write(byte[] b, int off, int len)<br>从指定的字节数组写入len个字节，从偏移off开始输出到此输出流。<br>abstract void write(int b)<br>将指定的字节写入此输出流。 </p><a id="more"></a><p>java.io.FileOutputStream extends OutputStream</p><p>文件字节输出流,把内存中的数据写入到硬盘的文件中<br>构造方法:<br>FileOutputStream(String name)<br>创建文件输出流以指定的名称写入文件。<br>FileOutputStream(File file)<br>创建文件输出流以写入由指定的 File对象表示的文件。<br>构造方法的作用:</p><ol><li>创建一个FileOutputStream对象</li><li>会根据构造方法中传递的文件/文件路径,创建一个空的文件</li><li>会把FileOutputStream对象指向创建好的文件</li></ol><p>写入数据的原理(内存-&gt;硬盘)<br>    java程序-&gt;JVM-&gt;OS(操作系统)-&gt;OS调用写数据方法-&gt;把数据写入到文件中</p><p>字节输出流的使用步骤(重点)</p><ol><li>创建一个FileOutputStream对象,构造方法中传递写入数据的目的地</li><li>调用FileOutputStream对象中的方法write,把数据写入文件中</li><li>释放资源(流使用会占用一定的内存,使用完清空)</li></ol><p>public class Demo01OutputStream {<br>    public static void main(String[] args) {<br>        try {<br>            FileOutputStream fos = new FileOutputStream(“F:\a.txt”);<br>            fos.write(97);<br>            fos.close();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}</p><hr><p>public class Demo01OutputStream {<br>    public static void main(String[] args) throws IOException {</p><pre><code>    FileOutputStream fos = new FileOutputStream("F:\\a.txt");    fos.write(97);//a    fos.close();    FileOutputStream f = new FileOutputStream(new File("F:\\b.txt"));    f.write(49);    f.write(48);    f.write(48);//100    f.close();    /*        public void write(byte[] b)        一次写入多个字节        如果写入第一个字节是正数（0-127），那么显示时会查询ASCII表        如果第一个字节是负数，那么第一个字节会和第二个组成中文显示，查询系统默认码表        void write(byte[] b, int off, int len)        写入数组指定索引内容        写入字符串方法,使用String中的方法把字符串转换成字节数组     */    FileOutputStream f1 = new FileOutputStream(new File("F:\\c.txt"));    byte[] bytes1 = {65,66,67,68,69};//ABCDE    byte[] bytes2 = {-65,-66,-67,68,69};//烤紻E    f1.write(bytes1);    f1.write(bytes2);    f1.write(bytes2,1,3);//窘D    byte[] bytes3 = "你好".getBytes();    f1.write(bytes3);//你好    f1.close();    /*    追加写/续写        FileOutputStream(String name,boolean append)创建一个向具有指定name的文件中写入数据的输出文件流        FileOutputStream(File file,boolean append)创建一个向具有指定File对象表示的文件中写入数据的输出文件流        boolean append:追加写开关        true:创建对象不会覆盖原文件,继续在文件末尾写        false:创建一个新文件覆盖    写换行:    windows:\r\n    linux: /n    mac:\r     */    FileOutputStream f2 = new FileOutputStream(new File("F:\\d.txt"),true);    for (int i = 0; i &lt; 10; i++) {        f2.write("你好".getBytes());        f2.write("\r\n".getBytes());    }}</code></pre><p>}</p><h2 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h2><p>InputStream<br>int read()<br>从该输入流读取一个字节的数据。<br>int read(byte[] b)<br>从该输入流读取最多 b.length个字节的数据为字节数组。<br>void close()<br>关闭此文件输入流并释放与流相关联的任何系统资源</p><p>java。io.FileInputStream extends InputStream<br>文件字节输入流<br>把硬盘文件中的数据读入到内存中使用<br>构造方法：<br>FileInputStream(String name)<br>通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。<br>FileInputStream(File file)<br>通过打开与实际文件的连接创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</p><p>读取数据原理（内存-&gt;硬盘)<br>    java程序-&gt;JVM-&gt;OS(操作系统)-&gt;OS调用读取数据方法-&gt;读取文件</p><p>public class Demo01InputStream {<br>    public static void main(String[] args) throws IOException {<br>        //1. 创建对象<br>        FileInputStream fis = new FileInputStream(“F:\a.txt”);//abcd<br>        //2. read方法读取<br>        int len = fis.read();//97<br>        System.out.println(len);<br>        len = fis.read();//98<br>        System.out.println(len);<br>        len = fis.read();//99<br>        System.out.println(len);<br>        len = fis.read();//100<br>        System.out.println(len);<br>        len = fis.read();//读到末尾返回-1<br>        System.out.println(len);<br>        fis.close();</p><pre><code>    //一次读入多字节    FileInputStream fis2 = new FileInputStream("F:\\a.txt");//abcd    byte[] bytes = new byte[2];    int len2 = fis2.read(bytes);//读取的有效字节数    System.out.println(len2);//2    System.out.println(Arrays.toString(bytes));//[97,98]    System.out.println(new String(bytes));//ab    fis2.close();}</code></pre><p>}</p><hr><h2 id="练习：文件复制"><a href="#练习：文件复制" class="headerlink" title="练习：文件复制"></a>练习：文件复制</h2><p>/*<br>    文件复制<br>    一读一写<br>    数据源:E:\图片\头像\1.jpg<br>    目的地:E:\图片\1.jpg<br>    复制步骤<br>    1. 创建一个字节输入流对象,构造方法中绑定要读取的数据源<br>    2. 创建一个字节输出流对象,构造方法中绑定要写入的目的地<br>    3. 使用字节输入流中的read读取文件<br>    4. 使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中<br>    5. 释放资源<br> */<br>public class Demo01CopyFile {<br>    public static void main(String[] args) throws IOException {<br>        //1,创建输入流<br>        FileInputStream fis = new FileInputStream(“E:\图片\头像\1.jpg”);<br>        //2. 创建输出流<br>        FileOutputStream fos = new FileOutputStream(“E:\图片\1.jpg”);<br>        //3. read<br>//        //一次读取一个字节,写入一个字节的方式<br>//        int len = 0;<br>//        while((len = fis.read())!=-1){<br>//            fos.write(len);<br>//        }</p><pre><code>    //使用数组缓冲读取多个字节,写入多个字节    byte[] bytes = new byte[1024];    int len = 0;    while((len = fis.read(bytes))!=-1){        fos.write(bytes,0,len);    }    //5. 释放资源,先关写的,再关读的    fos.close();    fis.close();}</code></pre><p>}</p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>使用字节流读取中文的问题，编码不同使用字节流容易出现问题，使用字符流</p><p>字符输入流<br>java.io.Reader 字符输入流最顶层的父类<br>共性成员方法:<br>    int read() 读一个字符<br>    int read(char[] cbuf) 将字符读入数组。<br>    void close() 关闭流并释放与之相关联的任何系统资源。 </p><p>/*<br>    java.io.FileReader extends InputStreamReader extends Reader<br>    FileReader:文件字符输入流<br>    作用:把硬盘文件中的数据以字符的方式读取<br>    构造方法:<br>    FileReader(String fileName)<br>    FileReader(File file)</p><p> <em>/<br>public class Demo01Reader {<br>    public static void main(String[] args) throws IOException {<br>        FileReader fr = new FileReader(“F:\a.txt”);<br>//        int len = 0;<br>//        while((len = fr.read())!=-1){<br>//            System.out.print((char) len);//你好abcd<br>//<br>//        }<br>        //一次读取多个字符<br>        char[] cs = new char[1024];<br>        int len = 0;<br>        while((len = fr.read(cs))!=-1){<br>            /</em><br>                String构造方法<br>                把字符数组转换成字符串<br>             */<br>            System.out.println(new String(cs,0,len));//你好abcd<br>        }<br>        fr.close();<br>    }<br>}</p><h2 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h2><p>java.io.Writer:字符输出流,是所有字符输出流的最顶层的父类,是一个抽象类<br>共性的成员方法:<br>void write(int c)  写一个字符<br>void write(char[] cbuf) 写入一个字符数组。<br>abstract void write(char[] cbuf, int off, int len) 写入字符数组的一部分。<br>void write(String str) 写一个字符串<br>void write(String str, int off, int len) 写一个字符串的一部分。<br>abstract void<br>flush() 刷新流。<br>abstract void<br>close() 关闭流，先刷新。  </p><p>/*<br>java.io.FileWriter extends OutputStreamWriter extends Writer<br>FileWriter: 文件字符输出流<br>作用:把内存中的字符数据写到文件中<br>构造方法:<br>FileWriter(File file)<br>FileWriter(String fileName)</p><p> */<br>public class Demo01Writer {<br>    public static void main(String[] args) throws IOException {<br>        //1. 创建FileWriter对象<br>        FileWriter fw = new FileWriter(“F:\d.txt”);<br>        //2. write方法把数据写入到内存缓冲区<br>        fw.write(97);<br>        //3. flush把内存缓冲区的数据刷新到文件中<br>        fw.flush();<br>        //刷新后流可以继续使用<br>        fw.write(98);</p><pre><code>    fw.close();    FileWriter fw2 = new FileWriter("F:\\d.txt",true);    char[] cs = {'a','b','c','d'};    fw2.write(cs);    fw2.write("\r\n");    fw2.write(cs,1,3);    fw2.flush();    fw2.close();}</code></pre><p>}</p><hr><h2 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h2><p>public class Demo02TryCatch {<br>    public static void main(String[] args) {<br>        //提高变量fw的作用域,需要初始化值<br>        FileWriter fw = null;<br>        try {<br>            fw = new FileWriter(“F:\d.txt”);<br>            fw.write(99);<br>            fw.write(98);<br>            fw.write(97);<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }finally {<br>            //如果创建对象失败了,fw默认是空,会出现空指针异常,加一个判断<br>            if(fw!=null){<br>                try {<br>                    fw.flush();<br>                    fw.close();<br>                } catch (IOException e) {<br>                    e.printStackTrace();<br>                }<br>            }</p><pre><code>    }}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>JDK7之后，在try后边增加一个(),在括号中可以定义流对象<br>那么这个流对象的作用域就在try中有效<br>try中的代码执行完毕,会自动把流对象释放,不用写finally<br>格式:<br>try(定义流对象;定义流对象…){<br>    可能出现异常的代码<br>}catch(异常类变量 变量名){<br>    异常的处理逻辑<br>}</p><p>public class Demo02CopyFile {<br>    public static void main(String[] args) {<br>        try(//1,创建输入流<br>            FileInputStream fis = new FileInputStream(“E:\图片\头像\1.jpg”);<br>            //2. 创建输出流<br>            FileOutputStream fos = new FileOutputStream(“E:\图片\1.jpg”)){<br>            byte[] bytes = new byte[1024];<br>            int len = 0;<br>            while((len = fis.read(bytes))!=-1){<br>                fos.write(bytes,0,len);<br>            }<br>        }catch(IOException e){<br>            System.out.println(e);<br>        }<br>    }<br>}</p><hr><p>JDK9新特性<br>try前面可以定义流对象<br>在try后面的()中可以直接引入流对象的名称(变量名)<br>在try代码执行完毕后,流对象也可以释放掉,不要写finally<br>格式:<br>    A a = new A();<br>    B b = new B();<br>    try(a,b){<br>    }catch(){<br>    }</p><h2 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h2><p>Properties 类表示一个持久的属性集。<br>Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串<br>/*<br>    java.util.Properties集合 extends Hashtable&lt;k,v&gt; implements Map&lt;k,v&gt;<br>    Properties集合是唯一一个和IO流相结合的集合<br>     可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘存储<br>     load,把硬盘中保存的文件(键值对),读取到集合中使用</p><p> */<br>public class Demo01Properties {<br>    public static void main(String[] args) throws IOException {<br>        show01();<br>        System.out.println(“————————————“);<br>        show02();<br>        System.out.println(“————————————“);<br>        show03();<br>    }</p><pre><code>/*    使用Properties集合存储数据,遍历取出Properties集合中的数据    Properties集合是一个双列集合,key和value默认都是字符串    Properties集合有一些操作字符串的特有方法        Object setProperty(String key,String value) 调用Hashtable 的方法put        String getProperty(String key) 通过key找到value值,此方法相当于Map集合中的get(key)方法        Set&lt;String&gt; stringPropertyNames() 返回此属性列表 */private static void show01() {    //创建Properties集合对象    Properties prop = new Properties();    //使用setProperty往集合中添加数据    prop.setProperty("田世庆","172");    prop.setProperty("呈呈","160");    prop.setProperty("西门吹雪","180");    //prop.put(1,true);    //使用stringPropertyNames把Properties集合的到一个Set集合中    Set&lt;String&gt; set = prop.stringPropertyNames();    //遍历set集合,取出每一个键    for(String key:set){        //使用getProperty方法通过key获取value        String value = prop.getProperty(key);        System.out.println(key+"="+value);    }}/*    void store(OutputStream out,String comments)    void store(Writer writer,String comments)    参数:        OutputStream out: 字节输出流,不能写入中文        Writer writer: 字符输出流,可以写中文        String comments: 注释,用来解释说明保存的文件是做什么的,不能使用中文,默认是unicode编码    使用步骤:        1. 创建Properties集合对象,添加数据        2. 创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地        3. 使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储        4. 释放资源 */private static void show02() throws IOException {    //创建Properties集合对象    Properties prop = new Properties();    //使用setProperty往集合中添加数据    prop.setProperty("田世庆","172");    prop.setProperty("呈呈","160");    prop.setProperty("西门吹雪","180");    //创建字符流输出对象    FileWriter fw = new FileWriter("F:\\d.txt");    prop.store(fw,"save data");    fw.close();}/*    使用load方法,把硬盘中保存的文件(键值对),读取到集合中使用    void load(InputStream inStream)    void load(Reader reader)    参数:        InputStream inStream: 字节输入流,不能读取含有中文的键值对        Reader reader: 字符输入流,能读取含有中文的键值对    使用步骤:        1. 创建Properties集合对象        2. 使用Properties集合对象中的方法load读取保存键值对的文件        3. 遍历Properties集合    注意:        1. 存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)        2. 存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取        3. 存储键值对的文件中,键与值默认都是字符串,不用再加引号 */private static void show03() throws IOException {    Properties prop = new Properties();    prop.load(new FileReader("F:\\d.txt"));    Set&lt;String&gt; set = prop.stringPropertyNames();    for (String key : set) {        String value = prop.getProperty(key);        System.out.println(key+"="+value);    }}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>字节缓冲输入流，给基本的字节输入流增加一个缓冲区(数组)提高基本的字节输入流的读取效率<br>BufferedInputStream(new FileInputStream)</p><p>缓冲流的基本原理,是在创建流对象的同时,创建一个内置的默认大小的缓冲区数组,通过缓冲区读写,<br>减少系统IO次数,从而提高读写的效率</p><p>字节缓冲流: BufferedInputStream,BufferedOutputStream<br>字符缓冲流: BufferedReader, BufferedWriter</p><p>/*<br>    java.io.BufferedOutputStream extends OutputStream<br>    BufferedOutputStream: 字节缓冲输出流</p><pre><code>构造方法:    BufferedOutputStream(OutputStream out) 创建一个新的缓冲流,以将数据写入指定的底层输出流    BufferedOutputStream(OutputStream out, int size) 创建一个新的缓冲输出流,以将指定缓冲区大小数据写入指定的底层输出流使用步骤:    1. 创建FileOutputStream对象,构造方法中绑定要输出的目的地    2. 创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象    3. write    4. flush    5. close</code></pre><p> */<br>public class Demo01BufferedOutputStream {<br>    public static void main(String[] args) throws IOException {<br>        FileOutputStream fos = new FileOutputStream(“F:\d.txt”);<br>        BufferedOutputStream bos = new BufferedOutputStream(fos);<br>        bos.write(“我把数据写入到内部缓冲区中”.getBytes());<br>        bos.flush();<br>        bos.close();</p><pre><code>    /*        java.io.BufferedInputStream extends InputStream        BufferedInputStream: 字节缓冲输出流        构造方法:            BufferedInputStream(InputStream in) 创建一个新的缓冲流,以将数据写入指定的底层输入流            BufferedInputStream(InputStream in, int size) 创建一个新的缓冲输出流,以将指定缓冲区大小数据写入指定的底层输入流     */    FileInputStream fis = new FileInputStream("F:\\d.txt");    BufferedInputStream bis = new BufferedInputStream(fis);    int len = 0;    while((len = bis.read())!=-1){        System.out.println(len);    }    bis.close();}</code></pre><p>}</p><p>使用缓冲流效率更高</p><h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p>public class Demo03BufferedWriter {<br>    /*<br>        java.io.BufferedWriter extends Writer<br>        特有的成员方法:<br>            void newLine() 写入一个行分隔符,会根据不同的操作系统,获取不同的行分隔符<br>     */<br>    public static void main(String[] args) throws IOException {<br>        BufferedWriter bw = new BufferedWriter(new FileWriter(“F:\d.txt”));<br>        for (int i = 0; i &lt; 10; i++) {<br>            bw.write(“田世庆”);<br>            //bw.write(“\r\n”);<br>            bw.newLine();//自动换行<br>        }<br>        bw.flush();<br>        bw.close();</p><pre><code>    /*        字符缓冲输入流        特有的方法:            String readLine() 读取一行数据     */    BufferedReader br = new BufferedReader(new FileReader("F:\\d.txt"));    String line1 = br.readLine();    System.out.println(line1);    br.close();}</code></pre><p>}</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h2><p>对文本内容进行排序<br>(3.入其城，则四顾萧条，寒水自碧，暮色渐起，戍角悲吟。<br>2.夜雪初霁，荠麦弥望。<br>8.自胡马窥江去后，废池乔木，犹厌言兵。<br>4.予怀怆然，感慨今昔，因自度此曲。<br>5.千岩老人以为有“黍离”之悲也。<br>7.过春风十里，尽荠麦青青。<br>11.纵豆蔻词工，青楼梦好，难赋深情。<br>9.渐黄昏，清角吹寒，都在空城。<br>10.杜郎俊赏，算而今、重到须惊。<br>12.二十四桥仍在，波心荡、冷月无声。<br>1.淳熙丙申至日，予过维扬。<br>13.念桥边红药，年年知为谁生。<br>6.淮左名都，竹西佳处，解鞍少驻初程。)</p><p>/*<br>    分析:<br>        1. 创建一个HashMap对象,可以存储每行文本的序号(1,2,3,…);value:存储每行文本<br>        2. 创建字符缓冲输入流对象,构造方法中绑定字符输入流<br>        3. 创建字符缓冲输出流对象<br>        4. 使用字符缓冲输入流中的方法readline,逐行读取文本<br>        5. 对读取到的文本切割,获取行中的序号和文本内容<br>        6. 把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3…)<br>        7. 遍历HashMap,获取每一个键值对<br>        8. 把每一个键值对,拼接为一个文本行<br>        9. 把拼接好的文本,使用字符缓冲输出流中的方法write写入文件中<br>        10.释放资源</p><p> <em>/<br>/</em><br>    分析:<br>        1. 创建一个HashMap对象,可以存储每行文本的序号(1,2,3,…);value:存储每行文本<br>        2. 创建字符缓冲输入流对象,构造方法中绑定字符输入流<br>        3. 创建字符缓冲输出流对象<br>        4. 使用字符缓冲输入流中的方法readline,逐行读取文本<br>        5. 对读取到的文本切割,获取行中的序号和文本内容<br>        6. 把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3…)<br>        7. 遍历HashMap,获取每一个键值对<br>        8. 把每一个键值对,拼接为一个文本行<br>        9. 把拼接好的文本,使用字符缓冲输出流中的方法write写入文件中<br>        10.释放资源</p><p> */<br>public class Demo01SortTxt {<br>    public static void main(String[] args) throws IOException {<br>        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();<br>        BufferedReader br = new BufferedReader(new FileReader(“F:\扬州慢.txt”));//要用utf8编码存储<br>        BufferedWriter bw = new BufferedWriter(new FileWriter(“F:\扬州慢2.txt”));<br>        String line;<br>        while ((line = br.readLine())!=null){<br>            String[] arr = line.split(“\.”);<br>            map.put(arr[0],arr[1]);<br>        }</p><pre><code>    for (String key : map.keySet()) {        String s = key+ "." + map.get(key);</code></pre><p>//            System.out.println(s);<br>            bw.write(s);<br>            bw.newLine();<br>        }<br>        bw.flush();<br>        bw.close();<br>        br.close();<br>    }<br>}</p><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>FileReader可以读取IDE默认编码格式（UTF-8）的文件<br>FileReader读取系统默认编码（中文GBK）会产生乱码<br>要读取默认编码，需要转换流<br>InputStreamReader 字节流通向字符流的桥梁<br>OutputStreamWriter 字符流通向字节流的桥梁</p><p>/*<br>    java.io.OutputStreamWriter extends Writer<br>    OutputStreamWriter: 可使用指定的字符集将写入流中的字符编码成字节<br>    构造方法:<br>    OutputStreamWriter(OutputStream out)创建使用默认字符编码的OutputStreamWriter<br>    OutputStreamWriter(OutputStream out,String charsetName)创建使用指定字符编码的OutputStreamWriter,不指定默认使用utf-8<br>    使用步骤:<br>    1. 创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称<br>    2. 使用OutputStreamWriter对象中的方法writer,吧字符转换为字节存储缓冲区中(编码)<br>    3. 使用OutputStreamWriter对象中的方法flush<br>    4.close</p><p> */<br>public class Demo01OutputStreamWriter {<br>    public static void main(String[] args) throws IOException {<br>        write_utf_8();<br>        write_gbk();</p><pre><code>    read_utf_8();    System.out.println("--------------------------");    read_gbk();}private static void write_gbk() throws IOException {    OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("F:\\gbk.txt"),"gbk");    osw.write("你好");    osw.flush();    osw.close();}private static void write_utf_8() throws IOException {    OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("F:\\utf-8.txt"),"utf-8");    osw.write("你好");    osw.flush();    osw.close();}/*    java.io.InputStreamReader extends Reader    构造方法:    InputStreamReader(InputStream in)    InputStreamReader(InputStream in,String charsetName)    注意事项:    构造方法中指定的编码表名称要和文件的编码相同,否则会乱码 */private static void read_utf_8() throws IOException {    InputStreamReader isr = new InputStreamReader(new FileInputStream("F:\\utf-8.txt"));//不指定默认使用u8    int len = 0;    while((len = isr.read())!=-1){        System.out.println((char)len);    }    isr.close();}private static void read_gbk() throws IOException {    InputStreamReader isr = new InputStreamReader(new FileInputStream("F:\\gbk.txt"),"gbk");    int len = 0;    while((len = isr.read())!=-1){        System.out.println((char)len);    }    isr.close();}</code></pre><p>}</p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>转换文件编码</p><p>/*<br>    练习:转换编码<br>    将GBK编码的文件转换为UTF-8的文本文件<br>    分析:<br>        1. 创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK<br>        2. 创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8<br>        3. 使用InputStreamReader对象中的方法read读取文件<br>        4. 使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中<br>        5. 释放</p><p> */</p><p>public class ChangeCode {<br>    public static void main(String[] args) throws IOException {<br>        InputStreamReader isr = new InputStreamReader(new FileInputStream(“F:\gbk.txt”),”gbk”);<br>        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“F:\gbk2u8.txt”),”utf-8”);<br>        int len = 0;<br>        while((len = isr.read())!=-1){<br>            osw.write(len);<br>        }<br>        osw.flush();<br>        osw.close();<br>        isr.close();<br>    }<br>}</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>Person p = new Person(“TT”,18);<br>把对象以流的方式,写入到文件中保存,叫写对象,也叫对象的序列化<br>对象中包含的不仅仅是字符,使用字节流<br>ObjectOutputStream:对象的序列化流</p><p>把文件中保存的对象,以流的方式读取出来,叫做读对象,也叫对象的反序列化<br>读取的文件保存的都是字节,使用字节流<br>ObjectInputStream:对象的反序列化流</p><p>/*<br>    java.io.ObjectOutputStream extends OutputStream<br>    ObjectOutputStream:对象的序列化流<br>    作用:把对象以流的方式写入到文件中保存<br>    构造方法:<br>    ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的ObjectOutputStream<br>    特有的成员方法:<br>    void writeObject(Object obj) 将指定的对象写入ObjectOutputStream<br>    使用步骤:<br>    1. 创建ObjectOutputStream,构造方法中传递字节输出流<br>    2. 使用writeObject方法,把对象写入到文件中<br>    3. 释放资源</p><pre><code>类通过实现Serializable接口以启用序列化功能</code></pre><p> */<br>public class Demo01ObjectOutputStream {<br>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br>        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“F:\person.txt”));<br>        oos.writeObject(new Person(“TT”,16));<br>        oos.close();</p><pre><code>    /*        java.io.ObjectInputStream extends InputStream        把文件中保存的对象以流的方式读取出来        构造方法:        ObjectInputStream(InputStream in) 创建指定InputStream读取的ObjectInputStream        特有的成员方法:        Object readObject() 从ObjectInputStream读取对象        使用步骤:            1. 创建ObjectInputStream,构造方法中传递字节输入流            2. 使用readObject方法,把对象写入到文件中            3. 释源            4.使用读取出来的对象        readObject方法声明抛出了ClassNotFoundException(class文件找不到异常);        当不存在对象的class文件时抛出异常        反序列化的前提:        1. 类必须实现Serializable        2. 必须存在类对应class文件     */    ObjectInputStream ois = new ObjectInputStream(new FileInputStream("F:\\person.txt"));    Object o = ois.readObject();    ois.close();    System.out.println(o);}</code></pre><p>}</p><h2 id="transient关键字：瞬态关键字"><a href="#transient关键字：瞬态关键字" class="headerlink" title="transient关键字：瞬态关键字"></a>transient关键字：瞬态关键字</h2><p>static：静态关键字，优先于非静态加载到内存中（静态优先于对象进入内存），被static修饰的成员不能被序列化，序列化的都是对象<br>transient：修饰后，不能被序列化。如果只是不想某变量被序列化，就用transient</p><p>Person类修改后，序列号会发生改变，反序列化会失败<br>问题：每次修改类的定义，都会给class文件生成一个新的序列号<br>解决方案：无论是否对类的定义进行修改，都不重新生生成序列号，可以手动给类添加一个序列号<br>private static final long serialVersionUID = 1L;</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p>/*<br>    练习:序列化集合<br>    当我们想在文件中保存多个对象的时候<br>    可以把多个对象存储到一个集合中<br>    对集合进行序列化和反序列化<br>    分析:<br>    1. 定义一个存储Person对象的ArrayList集合<br>    2. 往ArrayList集合中存储Person对象<br>    3. 创建一个序列化流ObjectOutputStream对象<br>    4. 使用writeObject对集合序列化<br>    5. 创建一个反序列化对象<br>    6. 使用readObject读取文件中保存的集合<br>    7. 把Object类型的集合转换成ArrayList类型<br>    8. 遍历ArrayList集合<br>    9. 释放资源</p><p> */<br>public class SerializationExercise {<br>    public static void main(String[] args) throws IOException, ClassNotFoundException {<br>        ArrayList<person> list = new ArrayList&lt;&gt;();<br>        list.add(new Person(“TT”,16));<br>        list.add(new Person(“CC”,18));<br>        list.add(new Person(“YY”,15));<br>        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“F:\list.txt”));<br>        oos.writeObject(list);<br>        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“F:\list.txt”));<br>        Object o =ois.readObject();<br>        ArrayList<person> list2 = (ArrayList<person>)o;</person></person></person></p><pre><code>    for (Person person : list2) {        System.out.println(person);    }    ois.close();    oos.close();}</code></pre><p>}</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>java.io.PrintStream:打印流,为其他输出流添加了功能,使他能够方便地打印各种数据值表示形式<br>PrintStream特点:</p><ol><li>只负责数据的输出,不负责数据的读取</li><li>与其他输出流不同,PrintStream 永远不会抛出 IOException</li><li>有特有的方法,print,println</li></ol><p>注意:如果使用继承父类的write方法写数据,那么查看数据的时候会查询编码表,使用自己的就原样输出</p><p>PrintStream ps = new PrintStream(“F:\d.txt”);<br>ps.write(97); //=&gt; a<br>ps.println(91) //=&gt; 97<br>ps.close();</p><p>可以改变输出语句的目的地<br>输出语句默认在控制台输出,使用System.setOut方法改变输出语句的目的地为参数中传递的打印流目的地</p><p>sout(“控制台输出”);</p><p>PrintStream ps = new PrintStream(“F:\d.txt”);<br>System.setOut(ps);//把输出语句目的地改为d.txt<br>sout(“目的地输出”);//会打印在d.txt中</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote05_Lambda&#39;</title>
      <link href="/2020/03/19/java-ji-chu/javanote05-lambda/"/>
      <url>/2020/03/19/java-ji-chu/javanote05-lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>3.1 函数式编程思想概述<br>尽量忽略面向对象的复杂语法，强调做什么，而不是以什么形式做</p><p>面向对象的思想：做一件事情，找一个能解决这个事情的对象，调用对象的方法，完成事情<br>函数式编程思想：只要能获取到结果，怎么做的都不重要，重视的是结果，不重视过程</p><a id="more"></a><p>3.2 冗余的Runnable代码<br>传统写法<br>public class Demo01Runnable {<br>    public static void main(String[] args) {<br>        RunnableImpl run = new RunnableImpl();<br>        Thread t = new Thread(run);<br>        t.start();<br>        for (int i = 0; i &lt; 20; i++) {<br>            System.out.println(Thread.currentThread().getName()+”–&gt;”+i);<br>        }<br>    }<br>}</p><hr><p>匿名内部类简化：<br>public class Demo01Runnable {<br>    public static void main(String[] args) {<br>        Runnable task = new Runnable() {<br>            @Override<br>            public void run() {<br>                System.out.println(“多任务执行”);<br>            }<br>        };<br>        new Thread(task).start();<br>    }<br>}</p><hr><p>为了实现任务不得不创建了匿名内部类，但真正希望做的事情是：将run方法体内的代码传递给Thread类知晓<br>传递一段代码才是真正的目的<br>public class Demo02Lambda {<br>    public static void main(String[] args) {<br>        //使用匿名内部类的方式实现多线程<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                System.out.println(Thread.currentThread().getName()+”多任务执行”);<br>            }<br>        }).start();</p><pre><code>    //使用Lambda表达式实现多线程    new Thread(()-&gt; {            System.out.println(Thread.currentThread().getName()+"多任务执行");        }    ).start();}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>匿名内部类的好处和弊端<br>一方面可以帮助我们省去实现类的定义，另一方面，语法太复杂</p><p>Lambda语法中<br>()-&gt; System.out.println(Thread.currentThread().getName()+”多任务执行”);<br>()即run方法的参数,接口中抽象方法的参数列表<br>-&gt; 表示将参数传递给后面的代码<br>后面的输出语句即业务逻辑代码,重写抽象方法的方法体</p><p>标准格式: (参数类型 参数名称) -&gt; {代码语句}</p><h2 id="有参数有返回"><a href="#有参数有返回" class="headerlink" title="有参数有返回"></a>有参数有返回</h2><p>/*<br>    Lambda表达式有参数有返回值的练习<br>    需求:<br>        使用数组存储多个Person对象<br>        对数组中多个Person对象使用Arrays方法通过年龄进行升序排序<br> */<br>public class Demo01Arrays {<br>    public static void main(String[] args) {<br>        //使用数组存储多个Person对象<br>        Person[] arr = {new Person(“CC”,18),<br>            new Person(“TT”,15),<br>            new Person(“AB”,8)};<br>        Arrays.sort(arr, new Comparator<person>() {<br>            @Override<br>            public int compare(Person o1, Person o2) {<br>                return o1.getAge()-o2.getAge();<br>            }<br>        });</person></p><pre><code>    //遍历数组    for (Person p : arr) {        System.out.println(p);    }    // 使用Lambda表达式简化匿名内部类,换成降序    Arrays.sort(arr,(Person o1, Person o2) -&gt;{        return o2.getAge()-o1.getAge();    });    for (Person p : arr) {        System.out.println(p);    }}</code></pre><p>}</p><hr><p>给定一个计算器Calculator接口,内含抽象方法calc可以将两个int数字相加得到和值<br>public interface Calculator {<br>    int calc(int a,int b);<br>}</p><p>使用Lambda标准格式调用invokeCalc方法,完成120,130的相加计算<br>public class Demo01Calculator {<br>    public static void main(String[] args) {<br>        //匿名内部类<br>        invokeCalc(10, 20, new Calculator() {<br>            @Override<br>            public int calc(int a, int b) {<br>                return a+b;<br>            }<br>        });</p><pre><code>    //Lambda表达式    invokeCalc(120, 130,(int a, int b)-&gt;{return a+b;});}public static void invokeCalc(int a,int b,Calculator c) {    int sum = c.calc(a,b);    System.out.println(sum);}</code></pre><p>}</p><h2 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h2><p>可推导可省略<br>可以省略的内容:<br>    1. (参数列表):括号中的参数列表的数据类型,可以省略不写<br>    2. (参数列表:括号中的参数如果只有一个,那么类型和()都可以省略<br>    3. {一些代码}:如果{}中的代码只有一行,无论是否有返回值,都可以省略({},return,分号)<br>        注意:要省略,{},return,分号就得一起省略</p><p>Lambda方法的使用前提</p><ol><li>使用Lambda必须具有接口,且要求接口中有且仅有一个抽象方法</li><li>使用Lambda必须具有上下文推断,也就是方法的参数或局部变量类型必须为Lambda对应的接口类型,<br>才能使用Lambda作为该接口的实例<br>有且仅有一个抽象方法的接口称为函数式接口</li></ol><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口在Java中指有且只有一个抽象方法的接口<br>/*<br>    函数式接口只有一个抽象方法，<br>    当然接口中可以包含其他的方法(默认,静态,私有)<br>    @FunctionalInterface注解,检测接口是否是一个函数式接口<br> */<br>@FunctionalInterface<br>public interface MyFunctionalInterface {<br>    //定义一个抽象方法<br>    public abstract void method();<br>}</p><p>使用：<br>/*<br>    函数式接口的使用:一般作为方法的参数和返回值类型<br> */<br>public class Demo {<br>    //定义一个方法,参数使用函数式接口<br>    public static void show(MyFunctionalInterface myinter) {<br>        myinter.method();<br>    }</p><pre><code>public static void main(String[] args) {    //调用show方法,方法参数是一个接口,所以可以传递接口的实现类对象MyFunctionalInterfaceImpl    //或者使用匿名内部类    show(new MyFunctionalInterface() {        @Override        public void method() {            System.out.println("使用匿名内部类重写接口中的抽象方法");        }    });    //或者lambda表达式    show(() -&gt; System.out.println("使用Lambda表达式重写接口中的抽象方法"));}</code></pre><p>}</p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能的浪费，Lambda表达式是延迟执行的，正好可以作为解决方案</p><p>性能浪费的日志案例<br>注：日志可以帮助我们快速定位问题，记录程序运行中的情况，以便项目的监控和优化<br>/*<br>    使用Lambda优化日志案例<br>    Lambda特点:延迟加载<br>    Lambda使用前提:存在函数式接口<br> */<br>public class Demo02Lambda {<br>    //定义一个显示日志方法,参数传递等级和MessageBuilder接口<br>    public static void showLog(int level,MessageBuilder mb) {<br>        //对日志的等级进行判断<br>        if(level == 1){<br>            System.out.println(mb.builderMessage());<br>        }<br>    }</p><pre><code>public static void main(String[] args) {    //定义三个日志信息    String msg1 = "Hello";    String msg2 = "world";    String msg3 = "Java";    //函数式接口使用Lambda    showLog(1,()-&gt;{        return msg1+msg2+msg3;    });    /*        使用Lambda表达式作为参数传递,仅仅是把参数传递到showLog方法中        只有满足条件,日志的等级是1级,才会调用接口        才会进行字符串的拼接        如果条件不满足        MessageBuilder接口中的方法builderMessage就不会执行     */}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>Lambda作为参数和返回值<br>public class Demo01Runnable {<br>    //定义一个方法startThread(Runnable run)<br>    public static void startThread(Runnable run) {<br>        new Thread(run).start();<br>    }</p><pre><code>public static void main(String[] args) {    startThread(()-&gt; System.out.println(Thread.currentThread().getName()+"--&gt;"+"线程启动了"));}</code></pre><p>}</p><p>返回函数式接口<br>/*<br>    如果一个方法的返回值类型是一个函数式接口,那么就可以直接返回一个Lambda表达式<br>    当需要通过一个方法获取一个java.util.Comparator接口类型的对象作为排序器时,就可以调该方法获取</p><p> */<br>public class Demo02Comparator {<br>    //定义一个方法,方法的返回值类型使用函数式接口Comparator<br>    public static Comparator<string> getComparator(){<br>        //方法返回值是一个函数式接口,使用Lambda<br>//        return (String o1, String o2)-&gt; {<br>//                //降序<br>//                return o2.length()-o1.length();<br>//        };<br>        //进一步优化,String可以省略,大括号省略,return省略<br>        return (o1, o2)-&gt; o2.length()-o1.length();<br>    }</string></p><pre><code>public static void main(String[] args) {    //创建一个字符串组    String[] arr = {"aaa","b","ccccc","dddddddddddddd"};    //输出排序前的数组    System.out.println(Arrays.toString(arr));//[aaa, b, ccccc, dddddddddddddd]    //调用Arrays中的sort方法排序    Arrays.sort(arr,getComparator());    System.out.println(Arrays.toString(arr));//[dddddddddddddd, ccccc, aaa, b]}</code></pre><p>}</p><h2 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h2><p>java.util.function</p><ol><li><p>Supplier接口<br>/*<br> Supplier<t>接口仅包含一个无参方法:T get() 用来获取一个泛型参数指定类型的对象数据<br> Supplier<t>接口被称为生产型接口,指定接口的泛型是什么类型,那么接口中的get方法就会产生声明类型的数据</t></t></p><p>*/<br>public class Demo01Supplier {<br> //定义一个方法,方法的参数传递Supplier<t>接口,泛型执行String,get方法就会返回一个String<br> public static String getString(Supplier<string> sup){</string></t></p><pre><code> return sup.get();</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> //调用getString方法,方法的参数Supplier是一个函数时接口 String s = getString(()-&gt;{     //生产一个字符串,并返回     return "TSQ"; }); System.out.println(s);</code></pre><p> }<br>}</p></li></ol><p>练习：<br>使用Supplier接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值<br>提示：接口泛型使用Integer<br>public class Demo02Test {<br>    //定义一个方法,用于获取int数据类型数组中元素的最大值,方法参数传递Supplier接口,泛型使用Integer<br>    public static int getMax(Supplier<integer> sup){<br>        return sup.get();<br>    }</integer></p><pre><code>public static void main(String[] args) {    //定义一个int类型的数组,并赋值    int[] arr = {100,0,-50,88,99,33,-30};    //调用getMax方法,方法的参数Supplier是一个函数式接口,可传递Lambda表达式    int maxValue = getMax(()-&gt;{        //获取数组的最大值,并返回        //定义一个变量,把数组中第一个元素赋值给该变量,记录数组中元素的最大值        int max = arr[0];        for (int i : arr) {            if(i&gt;max){                max = i;            }        }        return max;    });    System.out.println(maxValue);}</code></pre><p>}</p><hr><ol start="2"><li>Consumer接口<br>Cunsumer接口是一个消费型接口，泛型执行什么类型，就可以使用accept方法消费什么类型的数据</li></ol><p>public class Demo01Consumer {<br>    /*<br>        定义一个方法<br>        方法的参数传递一个字符串的姓名<br>        方法的参数传递Consumer接口,泛型使用String<br>        可以使用Consumer接口消费字符串的姓名</p><pre><code> */public static void method(String name, Consumer&lt;String&gt; con) {    con.accept(name);}public static void main(String[] args) {    //调用method方法,传递字符串姓名,方法的另一个参数时Consumer接口    method("西门吹雪",(String name)-&gt;{        //对传递的字符串进行消费        //消费方式:直接输出字符串        System.out.println(name);        //消费方式:把字符串进行反转输出        String reName = new StringBuilder(name).reverse().toString();        System.out.println(reName);    });}</code></pre><p>}</p><hr><p>默认方法：andThen<br>/*<br>    Consumer接口的默认方法andThen<br>    作用:需要两个Consumer接口,可以把两个Consumer接口组合到一起,再对数据进行消费<br>    例如:<br>    Consumer<string> con1<br>    Consumer<string> con2<br>    String s = “hello”;<br>    con1.accept(s);<br>    con2.accept(s);<br>    //等同于<br>    con1.andThen(con2).accept(s);//谁写前面谁先消费</string></string></p><p> */<br>public class Demo02AndThen {<br>    //定义一个方法,方法传递一个字符串和两个Consumer接口<br>    public static void method(String s, Consumer<string> con1,Consumer<string> con2){<br>        con1.accept(s);<br>        con2.accept(s);<br>        //使用andThen方法把两个接口连接到一起<br>        con1.andThen(con2).accept(s);<br>    }</string></string></p><pre><code>public static void main(String[] args) {    method("Hello",(t)-&gt;{        //消费方式,把字符串转换为大写输出        System.out.println(t.toUpperCase());    },(t)-&gt;{        System.out.println(t.toLowerCase());    });}</code></pre><p>}</p><p>练习：<br>格式化打印信息<br>public class Demo03Test {<br>    public static void printInfo(String[] arr, Consumer<string> con1,Consumer<string> con2){<br>        //遍历字符串数组<br>        for (String message : arr) {<br>            con1.andThen(con2).accept(message);<br>        }<br>    }</string></string></p><pre><code>public static void main(String[] args) {    //定义一个字符串类型的数组    String[] arr = {"西门吹雪,男","绯村剑心,男","小龙女,女"};    //调用printInfo方法,传递一个字符串数组,和两个Lambda表达式    printInfo(arr,(message)-&gt;{        //消费方式:对message切割,获取姓名,按照指定格式输出        String name = message.split(",")[0];        System.out.print("姓名:"+name);    },(message)-&gt;{        String age = message.split(",")[1];        System.out.println("。性别:"+age+"。");    });}</code></pre><p>}</p><ol start="3"><li><p>Predicate接口<br>对某种类型的数据进行判断<br>public class Demo01Predicate {<br> /*</p><pre><code> 定义一个方法 参数传递一个String类型的字符串 传递一个Predicate接口，泛型使用String 使用Predicate中的方法test对字符串进行判断，并把判断的结果返回</code></pre><p>  */<br> public static boolean checkString(String s, Predicate<string> pre) {</string></p><pre><code> return pre.test(s);</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> //定义一个字符串 String s = "abcde"; //调用checkString方法对字符串进行校验 boolean b = checkString(s,(String str)-&gt;{     //对参数传递的字符串进行判断,判断字符串的长度是否大于5     return str.length()&gt;5; }); System.out.println(b);</code></pre><p> }<br>}</p></li></ol><hr><p>默认方法：and<br>/*<br>    逻辑表达式:可以连接多个判断条件<br>    &amp;&amp;:与运算符,有false则false<br>    //:或运算符,有true则true<br>    !:非,取反</p><pre><code>需求:判断一个字符串,有两个判断条件    1. 判断字符串的长度是否大于5    2. 判断字符串是否包含a    两个条件同时满足,我们可以用&amp;&amp;连接两个条件    Predicate接口中有一个方法and,也可以用于连接两个判断条件</code></pre><p> <em>/<br>public class Demo02Predicate_and {<br>    /</em><br>        定义一个方法,传递一个字符串,两个Predicate接口<br>        一个判断条件一,一个判断条件二</p><pre><code> */public static boolean checkString(String s, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2) {    //return pre1.test(s) &amp;&amp; pre2.test(s);    //等价于    return pre1.and(pre2).test(s);}public static void main(String[] args) {    //定义一个字符串    String s = "abcdef";    boolean b = checkString(s,(String str)-&gt;{        return str.length()&gt;5;    },(String str)-&gt;{        return str.contains("a");    });    System.out.println(b);}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>默认方法：or<br>或<br>//return pre1.test(s) || pre2.test(s);<br>//等价于<br>return pre1.or(pre2).test(s);<br>默认方法：negate<br>取反<br>//return !pre.test(s);<br>return pre.negate().test(s);</p><p>练习:<br>集合信息筛选<br>/*<br>    练习:集合信息筛选<br>    数组当中有多条”姓名+性别”的信息如下,<br>    String[] arr = {“西门吹雪,男”,”绯村剑心,男”,”小龙女,女”,”杨过,男”};<br>    通过Predicate接口的拼装将符合条件的字符串筛选到ArrayList中<br>    同时满足<br>    1. 男生<br>    2. 姓名4个字<br> */<br>public class Demo05Test {<br>    public static ArrayList<string> filter(String[] arr, Predicate<string> pre1,Predicate<string> pre2){<br>        ArrayList<string> list = new ArrayList&lt;&gt;();<br>        for (String s : arr) {<br>            boolean b = pre1.and(pre2).test(s);<br>            if(b){<br>                //条件满足,信息存入list<br>                list.add(s);<br>            }<br>        }<br>        return list;<br>    }</string></string></string></string></p><pre><code>public static void main(String[] args) {    String[] arr = {"西门吹雪,男","绯村剑心,男","小龙女,女","杨过,男"};    ArrayList&lt;String&gt; list = filter(arr,(String s)-&gt;{        return s.split(",")[0].length()==4;    },(String s)-&gt;{        return s.split(",")[1].equals("男");    });    //遍历集合    for (String s : list) {        System.out.println(s);    }}</code></pre><p>}</p><ol start="4"><li><p>Function接口<br>用来根据一个类型的数据得到另一个类型的数据<br>抽象方法:R apply(T t), 根据类型T的参数获取类型R的结果<br>public class Demo01Function {<br> /*</p><pre><code> 定义一个方法 方法参数传递一个字符串类型的整数 方法的参数传递一个Function接口,泛型使用&lt;String,Integer&gt; 使用Function接口中的方法apply,把字符串类型的整数转换为Integer类型的整数</code></pre><p>  */</p><p> public static void change(String s, Function&lt;String,Integer&gt; fun){</p><pre><code> Integer in = fun.apply(s); System.out.println(in);</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> //定义一个字符串类型的整数 String s = "1234"; //调用change方法 change(s,(String str)-&gt;{     //把字符串类型的整数转换为Integer类型的整数返回     return Integer.parseInt(str); });</code></pre><p> }<br>}</p></li></ol><hr><p>默认方法:andThen<br>import java.util.function.Function;</p><p>/*<br>    Function接口中的默认方法andThen:用来进行组合操作<br>    需求:<br>        把String类型的”123”,转换为Integer类型,把转换后的结果加10<br>        把增加后的Integer类型数据转换为String类型<br>    分析:<br>        转换流两次<br>        第一次是把String类型转换为Integer类型<br>            所以我们可以使用Function&lt;String,Integer&gt; fun1<br>            Integer i = fun1.apply(“123”)+10;<br>        第二次把Integer转换为String类型<br>            String s = fun2.apply(i);</p><pre><code>    我们可以使用andThen方法,把两次转换组合到一起使用    String s = fun1.andThen(fun2).apply("123");</code></pre><p> */<br>public class Demo02Function_andThen {<br>    public static void change(String s, Function&lt;String,Integer&gt; fun1, Function&lt;Integer,String&gt; fun2){<br>        String ss = fun1.andThen(fun2).apply(s);<br>        System.out.println(ss);<br>    }</p><pre><code>public static void main(String[] args) {    //定义一个字符串方法    String s = "123";    //调用change方法    change(s,(String str)-&gt;{        //把字符串转换为整数+10        return Integer.parseInt(str)+10;    },(Integer in)-&gt;{        //把整数转换为字符串        return in+"";    });}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><p>练习:<br>自定义函数模型拼接<br>/*<br>    练习:自定义函数模型拼接<br>    请使用Function进行函数模型的拼接,按照顺序需要执行的多个函数操作为<br>        String str = “西门吹雪,20”;<br>    分析:<br>    1. 将字符串截取数字年龄部分,得到字符串;<br>        Function&lt;String,String&gt; “西门吹雪,20”-&gt;”20”<br>    2. 将上一步字符串转换为int类型<br>    Function&lt;String,Integer&gt; “20”-&gt;20<br>    3. 将上一步的int数字累加100,得到int数字<br>    Function&lt;Integer,Integer&gt; 20-&gt;120</p><p> */<br>public class Demo06Test {<br>    public static int change(String s, Function&lt;String,String&gt; fun1,<br>                             Function&lt;String,Integer&gt; fun2,Function&lt;Integer,Integer&gt; fun3){<br>        //使用andThen<br>        return fun1.andThen(fun2).andThen(fun3).apply(s);<br>    }</p><pre><code>public static void main(String[] args) {    String str = "西门吹雪,20";    //调用change方法    int num = change(str,(String s)-&gt;{        return s.split(",")[1];    },(String s)-&gt;{        return Integer.parseInt(s);    },(Integer i)-&gt;{        return i+100;    });    System.out.println(num);}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote04_Thread&#39;</title>
      <link href="/2020/03/18/java-ji-chu/javanote04-thread/"/>
      <url>/2020/03/18/java-ji-chu/javanote04-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol><li>并发与并行<br>并发：指两个或多个事件在同一时间段内发生<br>   交替执行,一个人吃两个馒头<br>并行：指两个或多个事件在同一时刻发生(同时发生)<br>   同时执行,两个人一人一个个馒头</li></ol><a id="more"></a><ol start="2"><li>线程与进程<br>进程:一个内存中运行的应用程序</li></ol><p>硬盘:永久存储ROM<br>内存:所有应用程序都需要进入内存中执行,临时存储RAM<br>点击应用程序执行,进入到内存中占用一些内存执行,进入到内存的程序叫进程<br>结束进程,就把进程从内存中清除了</p><p>一个程序运行后至少有一个进程,一个进程可以包含多个线程<br>CPU:中央处理器,对数据进行计算,指挥电脑中的软件和硬件工作<br>4核8线程<br>8线程:同时执行8个任务<br>点击电脑管家运行,会进入到内存中,就是一个进程.点击功能(病毒查杀,清理垃圾,电脑加速)执行,<br>就会开启一条应用程序到cpu的执行路径,cpu就可以通过这个路径执行功能,这个路径就叫线程<br>线程属于进程,是进程中的一个执行单元,负责程序的执行</p><p>单核心单线程CPU:cpu在多个线程之间做高速的切换,轮流执行多个线程,效率低<br>4核心8线程:同时执行8个线程,8个线程在多个任务之间高速切换,效率提高了8倍</p><p>线程调度:<br>分时调度:所有线程轮流使用CPU,平均分配每个线程占用CPU的时间<br>抢占式调度:优先让优先级高的线程占用</p><ol start="3"><li>创建线程类<br>主线程: 执行main方法的线程<br>单线程程序:Java程序中只有一个线程,执行从main开始,从上到下依次执行<br>public class Demo01MainThread {<br> public static void main(String[] args) {<pre><code> Person p1 = new Person("小强",10); p1.run();//单线程从上而下,p2全打印完了才继续运行p2,如果p1出现了异常,p2就运行不了了 Person p2 = new Person("旺财",8); p2.run();</code></pre> }<br>}</li></ol><p>//1.创建一个Thread类的子类<br>public class MyThread extends Thread {<br>    //2. 在Thread类的子类中重写Thread类中的run方法,设置线程任务</p><pre><code>@Overridepublic void run() {    for (int i = 0; i &lt; 10000; i++) {        System.out.println("run:" + i);    }}</code></pre><p>}</p><p>/*<br>    创建多线程程序的第一种方式:创建Thread类的子类<br>    实现步骤:<br>        1. 创建一个Thread类的子类<br>        2. 在Thread类的子类中重写Thread类的run方法,设置线程任务(开启线程要做什么)<br>        3. 创建Thread类的子类对象<br>        4. 调用Thread类中的方法start方法,开启新的线程,执行run方法<br>            void start() 使线程开始执行; Java 虚拟机调用该线程的run方法<br>            结果是两个线程并发的运行当前线程(main线程)和另一个线程(创建的新线程,执行其run方法)<br>            多次启动一个线程是非法的,特别是当线程已经结束执行后,不能再重新启动<br>        java程序属于抢占式调度,哪个线程优先级高,哪个线程优先执行,同一优先级随机选择一个执行</p><p> */<br>public class Demo01Thread {<br>    public static void main(String[] args) {<br>        //3. 创建Thread类子类对象<br>        MyThread mt = new MyThread();<br>        //4. 调用start<br>        mt.start();</p><pre><code>    //主线程    for (int i = 0; i &lt; 10000; i++) {        System.out.println("main:" + i);    }}</code></pre><p>}</p><h2 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h2><p>JVM执行main方法,找OS开辟一条main方法通向cpu的路径,这个路径叫main线程,主线程<br>cpu通过这个线程,这个路径可以执行main方法</p><p>mythread.start() 执行run方法,开辟一条通向cpu的新路径,用来执行run方法<br>对于cpu而言,就有了两条执行的路径,cpu就有了选择的权力,cpu随机选择</p><p>start开辟新的栈空间,执行run方法,多个栈的线程互不影响</p><h2 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h2><p>获取线程名称：</p><ol><li>使用Thread类中的方法getName()<br> String getName() 返回该线程的名称</li><li>可以先获取到当前正在执行的线程,使用线程方法getName()获取当前线程名称<pre><code> current Thread() </code></pre></li></ol><p>设置线程名称:</p><ol><li>使用Thread类中的方法setName</li><li>创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造,把线程名称传递给父类,让父类给子线程起一个名字</li></ol><p>//1.创建一个Thread类的子类<br>public class MyThread extends Thread {<br>    //2. 在Thread类的子类中重写Thread类中的run方法,设置线程任务</p><pre><code>public MyThread() {}public MyThread(String name) {    super(name);//}@Overridepublic void run() {    //获取线程名称</code></pre><p>//        String name = getName();<br>//        System.out.println(name);//Thread-0</p><p>//        Thread t = Thread.currentThread();<br>//        System.out.println(t);//Thread[Thread-0,5,main]<br>//        String name = t.getName();<br>//        System.out.println(name);//Thread-0<br>        System.out.println(Thread.currentThread().getName());</p><pre><code>}</code></pre><h2 id=""><a href="#" class="headerlink" title="}"></a>}</h2><p>/*<br>    线程的名称：<br>    主线程：main<br>    新线程：Thread-0，Thread-1…<br> */<br>public class Demo01GetThreadName {<br>    public static void main(String[] args) {<br>        //创建Thread子类对象<br>        MyThread mt = new MyThread();<br>        //1. 直接设置线程名称<br>        mt.setName(“CC”);<br>        mt.start();</p><pre><code>    //2. 父类构造方法设置名称    new MyThread("TT").start();}</code></pre><p>}</p><p>sleep方法<br>使当前正在执行的线程以指定的毫秒数暂停<br>毫秒数结束后,线程继续执行</p><p>public class Demo01Sleep {<br>    public static void main(String[] args) {<br>        //模拟秒表<br>        for (int i = 0; i &lt; 60; i++) {<br>            System.out.println(i);<br>            //使用Thread静态方法sleep睡眠一秒钟<br>            try {<br>                Thread.sleep(1000);<br>            } catch (InterruptedException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}</p><h2 id="创建多线程的另一种方式"><a href="#创建多线程的另一种方式" class="headerlink" title="创建多线程的另一种方式"></a>创建多线程的另一种方式</h2><p>实现Runnable接口<br>Runnable接口应该由那些打算通过某一线程执行其实例的类来实现,类必须定义一个称为run的无参方法<br>实现步骤:</p><ol><li>创建一个Runnable接口的实现类</li><li>在实现类中重写Runnable接口的run方法,设置线程任务</li><li>创建一个Runnable接口的实现类对象</li><li>创建Thread类的对象,构造方法中传递Runnable接口的实现类对象</li><li>调用Thread类中的方法start方法,开启新的线程</li></ol><p>public class RunnableImpl implements Runnable{</p><pre><code>@Overridepublic void run() {    for (int i = 0; i &lt; 20; i++) {        System.out.println(Thread.currentThread().getName()+"--&gt;"+i);    }}</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>public class Demo01Runnable {<br>    public static void main(String[] args) {<br>        RunnableImpl run = new RunnableImpl();<br>        Thread t = new Thread(run);<br>        t.start();<br>        for (int i = 0; i &lt; 20; i++) {<br>            System.out.println(Thread.currentThread().getName()+”–&gt;”+i);<br>        }<br>    }<br>}</p><h2 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h2><p>实现Runnable接口创建多线程的好处:<br>    1. 避免了单继承的局限性<br>        一个类只能继承一个类,类继承了Thread类就不能继承其他的类了<br>        实现Runnable接口,还可以继承其他的类,实现其他接口<br>    2. 增强了程序的扩展性,降低了程序的耦合性<br>        实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离<br>        实现类中,重写了run方法:用来设置线程任务<br>        创建Thread类对象,调用start方法:用来开启新线程<br>        Thread t = new Thread(run);分离后可以传递不同的Runnable接口的实现类对象</p><p>尽量通过Runnable接口的形式</p><h2 id="匿名内部类的方式创建"><a href="#匿名内部类的方式创建" class="headerlink" title="匿名内部类的方式创建"></a>匿名内部类的方式创建</h2><p>把子类继承父类,重写父类方法,创建子类对象合一步完成<br>把实现类实现接口,重写接口中的方法,创建实现类对象合成一步完成</p><p>匿名内部类最终产物:子类对象/实现类对象,而这个类没有名字</p><p>格式:<br>    new 父类/接口(){<br>        重写方法<br>    };</p><p>public class Demo01InnerClassThread {<br>    public static void main(String[] args){<br>        //线程的父类是Thread<br>        // new MyThread().start();</p><pre><code>    //匿名内部类    new Thread(){        @Override        public void run() {            for (int i = 0; i &lt; 20; i++) {                System.out.println(Thread.currentThread().getName()+"--&gt;"+i+"TT");            }        }    }.start();    //接口方式    //Runnable r = new RunnableImpl();//多态    //匿名内部类    Runnable r = new Runnable(){        @Override        public void run() {            for (int i = 0; i &lt; 20; i++) {                System.out.println(Thread.currentThread().getName()+"--&gt;"+i+"CC");            }        }    };    new Thread(r).start();    new Thread(new Runnable(){        @Override        public void run() {            for (int i = 0; i &lt; 20; i++) {                System.out.println(Thread.currentThread().getName()+"--&gt;"+i+"AB");            }        }    }).start();}</code></pre><p>}</p><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>卖票案例:</p><ol><li>只有一个窗口卖1-100号票,单线程,线程安全</li><li>三个窗口,分别卖1-33,34-66,67-100,多线程程序,没有访问共享数据,也不会出现问题</li><li>三个窗口,都在卖1-100号,多线程访问了共享数据,就会出现线程安全问题</li></ol><p>public class RunnableImpl implements Runnable{<br>/*<br>     实现卖票案例</p><p> */</p><pre><code>//定义一个多线程共享的票源private int ticket = 100;//设置线程任务:卖票@Overridepublic void run() {    //使用循环,让卖票重复进行    while(ticket&gt;0){        //票存在,卖票        System.out.println(Thread.currentThread().getName()+"正在卖第"+ ticket +"张票");        ticket--;    }}</code></pre><h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>/*<br>    模拟卖票<br>    创建3个线程,同时开启,对共享的票进行出售<br> */</p><p>public class Demo01Ticket {<br>    public static void main(String[] args) {<br>        //创建Runnable接口的实现类对象<br>        RunnableImpl run = new RunnableImpl();<br>        Thread t1 = new Thread(run);<br>        Thread t2 = new Thread(run);<br>        Thread t3 = new Thread(run);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    }<br>}</p><h2 id="解决线程安全问题"><a href="#解决线程安全问题" class="headerlink" title="解决线程安全问题"></a>解决线程安全问题</h2><p>运用同步机制<br>!. 同步代码块<br>2. 同步方法<br>3. 锁机制</p><ol><li>同步代码块<br>public class RunnableImpl implements Runnable{<br>/*<br>  实现卖票案例<br>  出现了线程安全问题<br>  卖出了不存在的票和重复的票<br>  使用同步代码块解决<br>  格式:<pre><code>  synchronized(锁对象){      可能会出现线程安全问题的代码块  }</code></pre>  注意:<pre><code>  1. 通过代码块中的锁对象,可以使用任意的对象  2. 但是必须保证多个线程使用的锁对象是同一个  3. 锁对象作用:把同步代码块锁住,只让一个线程在同步代码块中执行</code></pre></li></ol><p> */</p><pre><code>//定义一个多线程共享的票源private int ticket = 100;//设置线程任务:卖票//创建一个锁对象Object obj = new Object();@Overridepublic void run() {    //使用循环,让卖票重复进行    while(true){        synchronized(obj){            if(ticket &gt; 0){                //票存在,卖票                System.out.println(Thread.currentThread().getName()+"正在卖第"+ ticket +"张票");                ticket--;            }        }    }}</code></pre><hr><p>同步技术的原理:<br>使用了一个锁对象,这个锁对象叫做同步锁,也叫对象锁,也叫对象监视器<br>3个线程一起抢夺cpu执行权,谁抢到了谁执行run方法进行卖票,<br>t0抢到了执行权,执行run方法,遇到synchronized代码块,<br>这是t0会检查synchronized代码块是否有锁对象,<br>发现有,就会获取到锁对象,进入到同步中执行<br>t1抢到了cpu的执行权,遇到synchronized代码块,<br>这是t1检查锁对象,发现没有,t1就会进入阻塞状态,会一直等待t0归还锁对象<br>t0执行完同步代码块中的代码,才会归还锁对象</p><ol start="2"><li>同步方法解决<br>使用步骤:</li><li>把访问了共享数据的代码抽取出来,放到一个方法中</li><li>在方法上添加synchronized修饰符</li></ol><p>格式: 定义方法的格式<br>修饰符 synchronized 返回值类型 方法名(参数列表){<br>    可能出现线程安全问题的代码(共享数据的代码)<br>}</p><p>@Override<br>    public void run() {<br>        payTicket();<br>    }</p><pre><code>/*    定义一个同步方法    同步方法也会把方法内部的代码锁住    只让一个线程执行    同步方法的锁对象就是实现类对象 new RunnableImpl()    也就是this */public synchronized void payTicket(){    //使用循环,让卖票重复进行    while(ticket &gt; 0){        synchronized(obj){            //票存在,卖票            System.out.println(Thread.currentThread().getName()+"正在卖第"+ ticket +"张票");            ticket--;        }    }}</code></pre><p>静态同步方法</p><p>public class RunnableImpl implements Runnable{<br>    //静态访问静态<br>    private static int ticket = 100;<br>    //设置线程任务:卖票</p><pre><code>@Overridepublic void run() {    payTicket();}public static synchronized void payTicket(){    //使用循环,让卖票重复进行    while(ticket &gt; 0){        synchronized(obj){            //票存在,卖票            System.out.println(Thread.currentThread().getName()+"正在卖第"+ ticket +"张票");            ticket--;        }    }}</code></pre><p>静态方法的锁对象不能是this，this是创建对象后产生的，静态方法优先于对象<br>静态方法的锁对象是本类的class属性 –&gt; class文件对象 RunnableImpl.class</p><ol start="3"><li><p>Lock锁<br>Lock接口可获得更广泛的锁定结构<br>lock获取锁<br>unlock释放锁</p><pre><code> /*     第三种方案:Lock锁     ReentrantLock implements Lock 接口     使用步骤:         1. 在成员位置创建一个ReentrantLock对象         2. 在可能出现安全问题的代码前调用Lock接口中的lock方法获取锁         3. 在可能出现安全问题的代码后调用Lock接口中的unlock方法释放锁  */</code></pre><p> Lock l = new Reentrant Lock();</p><p> @Override<br> public void run() {</p><pre><code> //使用循环,让卖票重复进行 l.lock(); while(ticket &gt; 0){     synchronized(obj){             //票存在,卖票             System.out.println(Thread.currentThread().getName()+"正在卖第"+ ticket +"张票");             ticket--;     } } l.unlock();</code></pre><p> }</p></li></ol><p>如果try…catch异常,把unlock放在finally语句里,无论程序是否异常,都会把锁释放<br>    @Override<br>    public void run() {<br>        //使用循环,让卖票重复进行<br>        l.lock();<br>        while(ticket &gt; 0){</p><pre><code>        try {            Thread.sleep(1000);            //票存在,卖票                System.out.println(Thread.currentThread().getName()+"正在卖第"+ ticket +"张票");                ticket--;        } catch (InterruptedException e) {            e.printStackTrace();        }finally{            l.unlock();        }        }}</code></pre><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>NEW 新建状态<br>BLOCKED 阻塞状态  RUNNABLE 运行状态<br>TIMED_WAITING 休眠状态  WAITING 无限等待状态<br>TERMINATED 死亡状态</p><p>TIMED_WAITING 休眠状态  sleep<br>BLOCKED 阻塞状态    lock</p><p>WAITING 无限等待状态<br>一个正在无限等待另一个线程执行一个特别的唤醒动作的线程处于这一状态<br>卖包子案例：<br>顾客要买包子，和老板说明买包子的数量和种类，顾客就等着老板做包子(调用wait方法) Waiting状态 无限等待</p><p>老板开始做包子,做好包子告诉顾客(调用notify方法)</p><p>/*<br>    等待唤醒案例：线程之间的通信<br>        创建一个顾客线程（消费者）：告知老板要的包子种类和数量，调用wait，放弃cpu执行，进入无限等待<br>        创建一个老板线程（生产者）：花了5秒做包子，做好包子后调用notify唤醒顾客<br>    注意：<br>        顾客和老板线程必须使用同步代码包裹起来，保证等待和唤醒只能有一个执行<br>        同步使用的锁对象必须保证唯一<br>        只有锁对象才能调用wait和notify方法<br>    Object类中的方法<br>    void wait()<br>        在其他线程调用此对象的notify()方法或notifyAll()方法前,导致当前线程等待<br>    void notify()<br>        唤醒在此对象监视器上等待的单个线程<br>        会继续执行wait方法之后的代码</p><p> */<br>public class Demo01WaitAndNotify {<br>    public static void main(String[] args) {<br>        //创建锁对象保证唯一<br>        Object obj = new Object();<br>        //创建一个顾客线程<br>        new Thread(){<br>            @Override<br>            public void run() {<br>                //保证等待和唤醒的线程只能有一个执行,需要使用同步技术<br>                synchronized (obj){<br>                    System.out.println(“告知老板包子的种类和数量”);<br>                    //调用wait方法<br>                    try {<br>                        obj.wait();<br>                    } catch (InterruptedException e) {<br>                        e.printStackTrace();<br>                    }<br>                    //唤醒之后执行的代码<br>                    System.out.println(“包子做好了,真香”);<br>                }<br>            }<br>        }.start();</p><pre><code>    //创建一个老板线程    new Thread(){        @Override        public void run() {            //花了五秒做包子            try {                Thread.sleep(5000);            } catch (InterruptedException e) {                e.printStackTrace();            }            //保证等待和唤醒的线程只能有一个执行,需要使用同步技术            synchronized (obj){                //调用notify唤醒顾客                System.out.println("唤醒顾客");                obj.notify();            }        }    }.start();}</code></pre><p>}</p><p>进入TimeWaiting有两种方式<br>    1. 使用sleep(Long m)方法,计时结束后自动进入Runnable/Blocked状态<br>    2. 使用wait(Long m)方法,毫秒结束后如果还没有被唤醒,自动进入Runnable/Blocked状态</p><p>唤醒的方法:<br>    notify() 唤醒单个线程,如果有多个,随机唤醒一个<br>    notifyAll() 唤醒监视器上等待的所有线程</p><h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p>线程间通信<br>多个线程在处理同一个资源,但是处理的动作(线程的任务)却不相同<br>比如:线程A生产包子,线程B吃包子,包子是同一资源,但是线程A线程B处理的动作不同,就存在线程通信问题</p><p>包子案例实现:</p><p>public class BaoZi {<br>    //皮<br>    String pi;<br>    //馅<br>    String xian;<br>    //包子的状态<br>    boolean flag = false;<br>}</p><hr><p>/*<br>    包子铺线程和顾客线程关系–&gt;通信(互斥)<br>    必须使用同步技术保证两个线程只有一个执行<br>    锁对象必须保证唯一,可以使用包子对象作为锁对象<br>    包子铺类和顾客类就需要把包子对象作为参数传递进来<br>        1. 需要在成员位置创建一个包子变量<br>        2. 使用带参数构造方法,为包子变量赋值<br> */<br>public class BaoZiPu extends Thread{<br>    private BaoZi bz;</p><pre><code>public BaoZiPu(BaoZi bz) {    this.bz = bz;}//设置线程生产包子@Overridepublic void run() {    int count = 0;    //让包子一直生产到100个包子    while(count&lt;100){        //同步技术        synchronized (bz){            if(bz.flag == true){                //包子铺调用wait方法进入等待状态                try {                    bz.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            //被唤醒后生产包子            //交替生产两种包子            if(count%2 == 0){                //生产薄皮三鲜馅儿                bz.pi = "薄皮";                bz.xian = "三鲜馅儿";            }else{                //生产冰皮牛肉大葱馅儿                bz.pi = "冰皮";                bz.xian = "牛肉大葱馅儿";            }            count++;            System.out.println("包子铺正在做"+bz.pi+bz.xian+"的包子");            //做一个包子五秒钟            try {                Thread.sleep(5000);            } catch (InterruptedException e) {                e.printStackTrace();            }            //做好包子,flag改成有            bz.flag = true;            bz.notify();            System.out.println("包子铺做好了"+bz.pi+bz.xian+"的包子");    }    }}</code></pre><p>}</p><hr><p>public class ChiHuo extends Thread {<br>    private BaoZi bz;</p><pre><code>public ChiHuo(BaoZi bz) {    this.bz = bz;}@Overridepublic void run() {    int count=0;    while(count&lt;100){        synchronized (bz){            if(bz.flag == false){                try {                    bz.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            //被唤醒后吃包子            System.out.println("顾客在吃"+bz.pi+bz.xian+"的包子");            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            //吃完包子修改状态为没有            bz.flag = false;            count++;            //唤醒包子铺继续生产            bz.notify();            System.out.println("顾客把"+bz.pi+bz.xian+"的包子吃完了");            System.out.println("--------------------------------------");        }    }}</code></pre><p>}</p><hr><p>public class Demo {<br>    public static void main(String[] args) {<br>        //创建包子对象<br>        BaoZi bz = new BaoZi();<br>        //创建包子铺线程,开始生产包子<br>        new BaoZiPu(bz).start();<br>        //创建顾客线程,开始吃包子<br>        new ChiHuo(bz).start();<br>    }<br>}</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是存在一个问题：<br>如果并发线程数量很多，并且每一个线程都执行一个时间很短的任务就结束了，<br>这样频繁创建线程会大大降低系统的效率，<br>需要一种办法使线程可以复用，执行完一个任务，并不被销毁，而是可以继续执行其他的任务</p><p>线程池：一个容器–&gt;集合(ArrayList,HashSet,LinkedList<thread>,HashMap)</thread></p><p>当程序第一次启动的时候,创建多个线程,保存到一个集合中,<br>当我们想要使用线程的时候,就可以从集合中取出来线程使用<br>Thread t = list.remove(0):返回的使被移除的元素,线程只能被一个任务使用<br>或者 Thread t = linked.removeFirst();<br>当我们使用完毕线程,需要把线程归还给线程池<br>list.add(t);<br>或者linked.addLast(t);</p><p>JDK1.5之后,JDK内置了线程池,可以直接使用</p><p>//2. 创建一个类,实现Runnable接口,重写run方法,设置线程任务<br>public class RunnableImpl2 implements Runnable{</p><pre><code>@Overridepublic void run() {    System.out.println(Thread.currentThread().getName()+"创建一个新的线程执行");}</code></pre><h2 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h2><p>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;</p><p>/*<br>    java.util.concurrent.Executor: 线程池的工厂类,用来生成线程池<br>    Executors类中的方法:<br>        static ExecutorService newFixed Thread Pool(int nThreads) 创建一个可重用固定线程数的线程池<br>        参数:<br>            int nThreads:创建线程池中包含的线程数量<br>            返回值:<br>                ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程)<br>    java.util.concurrent.ExecutorService:线程池接口<br>        用来从线程池中获取线程,调用start方法执行线程任务<br>            submit(Runnable task)提交一个 Runnable 任务用于执行<br>        关闭线程池的方法: void shutdown()<br>    线程池的使用步骤:<br>        1. 使用线程的工厂类Executors里提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池<br>        2. 创建一个类,实现Runnable接口,重写run方法,设置线程任务<br>        3. 调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法<br>        4. 调用ExecutorService中的方法shutdown销毁线程池(不建议执行)</p><p> */<br>public class Demo01ThreadPool {<br>    public static void main(String[] args) {<br>        //1. 使用线程的工厂类Executors里提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池<br>        ExecutorService es = Executors.newFixedThreadPool(2);<br>        //3. 调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法<br>        es.submit(new RunnableImpl2());//pool-1-thread-1创建一个新的线程执行<br>        es.submit(new RunnableImpl2());//pool-1-thread-2创建一个新的线程执行<br>        es.submit(new RunnableImpl2());//pool-1-thread-1创建一个新的线程执行<br>        es.shutdown();<br>    }<br>}</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote03_Exception&#39;</title>
      <link href="/2020/03/16/java-ji-chu/javanote03-exception/"/>
      <url>/2020/03/16/java-ji-chu/javanote03-exception/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>指执行过程出现非正常情况,Java处理异常的方式是中断处理<br>Throwable 异常的根类<br>Error: extends Throwable,不能处理只能尽量避免<br>Exception: extends Throwable,由于使用不当导致,可以避免</p><a id="more"></a><p>// Exception:编译期异常,进行编译时出现的问题<br>// RuntimeException:运行期异常,运行过程中出现的问题</p><ol><li>psvm throws XXXException{}</li><li>try{<pre><code>//可能会出现异常的代码    </code></pre> }catch(XXXException e){<pre><code> //异常的处理逻辑 e.printStackTrace();</code></pre> }</li></ol><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>// throw关键字:在指定的方法中抛出指定的异常<br>使用格式:<br>throw new XXXException(“异常产生的原因”)</p><p>注意:</p><ol><li>throw关键字必须写在方法的内部</li><li>throw关键字后面new的对象必须是Exception或者Exception的子类对象</li><li>throw关键字抛出指定的异常对象,我们就必须处理这个异常对象<br> throw关键字后面创建的是RuntimeException或其子类对象时我们可以不处理,默认交给JVM处理(打印异常对象,中断程序)<br> throw关键字后面创建的是编译异常(写代码的时候报错),我们就必须处理这个异常,要么throw,要么try…catch</li></ol><p>public class Demo03Throw {<br>    /*<br>        定义一个方法,获取数组指定索引处的元素<br>        参数:<br>        int[] arr<br>        int index<br>        我们首先必须对方法传递过来的参数进行合法性校验<br>        如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法调用者,传递的参数有问题</p><pre><code>    NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理 */public static void main(String[] args) {</code></pre><p>//        int[] arr = null;<br>//        getElement(arr,0);<br>        int[] arr1 = new int[3];<br>        getElement(arr1, 3);</p><pre><code>}public static int getElement(int[] arr, int index) {    /*        对传递过来的参数进行合法性校验        如果arr时null,我们就抛出空指针异常,告知调用者,"传递的数组的值是null"     */    if (arr == null) {        throw new NullPointerException("传递的数组的值是null");    }    /*        如果index的范围不在数组索引范围类,就抛出数组索引越界异常,        告知方法的调用者"传递的索引超出了数组的使用范围"     */    if (index &lt; 0 || index &gt; arr.length - 1) {        throw new ArrayIndexOutOfBoundsException("传递的索引超出了数组的使用范围");    }    int ele = arr[index];    return ele;}</code></pre><p>}</p><p>// Object非空判断<br>Objects类中的静态方法<br>public static <t> T requireNonNull(T obj):查看指定引用对象不是null<br>public static int getElement(int[] arr, int index) {<br>        //不用自己写校验合法性的代码,可以简化代码<br>        Objecs.requireNonNull(obj,”传递的数组的值是null”);</t></p><pre><code>    int ele = arr[index];    return ele;}</code></pre><p>// throws关键字: 异常处理的第一种方式,交给别人处理<br>    作用:<br>        当方法内部抛出异常对象的时候,我们必须处理这个异常对象<br>    使用格式:<br>    修饰符 返回值类型 方法名(参数列表) throws AAAException{ton,BBBException{ton…{<br>    throw new AAAException(“产生原因”);<br>    throw new BBBException(“产生原因”);<br>    …<br>    }</p><p>public class Demo05Throws {<br>    public static void main(String[] args) throws IOException {<br>        readFile(“c:\a.txd”);<br>        readFile(“d :\a.txt”);</p><pre><code>}/*    定义一个方法,对传递的文件路径进行合法判断    如果路径不是"c:\\a.txt",就抛出文件找不到异常对象    注意:FileNotFoundException是编译异常,抛出编译异常就必须处理         可以使用throws继续声明抛出FileNotFoundException这个异常对象,让方法调用者处理         FileNotFoundException extends IOException,直接声明父类异常即可 */public static void readFile(String filename) throws IOException {    if(!("c:\\a.txt").equals(filename)){        throw new FileNotFoundException("传递路径错误");    }    /*        如果传递路径不是.txt结尾        那么我们就抛出IO异常对象,告知方法的调用者,文件后缀名不对     */    if(!filename.endsWith(".txt")){        throw new IOException("文件后缀名错误");    }    System.out.println("路径正确,读取文件");}</code></pre><p>}</p><p>//  try…catch:异常处理的第二种方式,自己处理异常<br>    格式:<br>        try{<br>            可能产生异常的代码<br>        }catch(定义一个异常的变量,用来接受try中抛出的异常对象){<br>            异常的处理逻辑,怎么处理异常对象<br>            一班会把异常信息记录到一个日志中<br>        }<br>        …<br>        catch(异常类名 变量名){<br>        }</p><pre><code>注意:    1. try中可能会抛出多个异常对象,那么就可以使用多个catch来处理这些异常对象    2. 如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try...catch后面的代码       如果try中没有产生异常,那么就不会执行catch中异常的出路逻辑,执行完try中代码,继续执行try...catch后面的代码</code></pre><p>public class Demo01TryCatch {<br>    public static void main(String[] args) {<br>        try{<br>            readFile(“c:\a.txd”);<br>        }catch(IOException e){// try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象<br>            System.out.println(“文件后缀名错误”);<br>        }<br>        System.out.println(“后续代码”);<br>    }<br>    public static void readFile(String filename) throws IOException {</p><pre><code>    if(!filename.endsWith(".txt")){        throw new IOException("文件后缀名错误");    }    System.out.println("路径正确,读取文件");}</code></pre><p>}</p><p>// Throwable类中的3个异常处理方法<br>String getMessage() 返回此throwable的简短描述<br>String toString() 返回此 throwable 的详细消息字符串<br>void printStackTrace() JVM打印异常对象,默认此方法,异常消息最全面</p><pre><code>    try{        readFile("c:\\a.txd");    }catch(IOException e){// try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象</code></pre><p>//            System.out.println(“文件后缀名错误”);<br>//            System.out.println(e.getMessage());//文件后缀名错误<br>//            System.out.println(e.toString());//java.io.IOException: 文件后缀名错误<br>            e.printStackTrace();//最全面<br>        }        </p><p>// finally代码块<br>        try{<br>            可能产生异常的代码<br>        }catch(定义一个异常的变量,用来接受try中抛出的异常对象){<br>            异常的处理逻辑,怎么处理异常对象<br>            一班会把异常信息记录到一个日志中<br>        }<br>        …<br>        catch(异常类名 变量名){<br>        }finally{<br>            无论是否出现异常都会执行<br>        }<br>        注意:<br>            1. finally不能单独使用,必须和try一起使用<br>            2. finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放</p><pre><code>public static void main(String[] args) {    try{        readFile("c:\\a.txd");    }catch(IOException e){        e.printStackTrace();    }finally{        System.out.println("资源释放");    }}如果finally有return语句,永远返回finally中的结果,避免该情况,所以尽量不要在finally里面写return</code></pre><p>// 多异常的捕获处理</p><ol><li>多个异常分别处理:<br> 有一个异常用一次try…catch</li><li>多个异常一次捕获,多次处理<br> 一个try多个catch<br> 注意:catch里面定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上面,否则会报错</li><li>多个异常一次捕获一次处理<br> catch父类<br> try{}catch(Exception e){}</li></ol><p>// 子父类异常<br>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常<br>父类方法没有抛出异常,子类重写父类该方法时也不可以抛出异常,此时子类产生该异常,只能捕获处理,不能声明抛出<br>注意: 父类异常时什么样,子类异常就什么样<br>public class Fu {<br>    public void show01() throws NullPointerException,ClassCastException{}<br>    public void show02() throws IndexOutOfBoundsException{}<br>    public void show03() throws IndexOutOfBoundsException{}<br>    public void show04(){}<br>    public void show05(){}</p><p>}<br>class Zi extends Fu{<br>    //重写父类方法时抛出和父类相同的异常<br>    public void show01() throws NullPointerException,ClassCastException{}<br>    //或者抛出父类异常的子类<br>    public void show02() throws ArrayIndexOutOfBoundsException{}<br>    //或者不声明异常<br>    public void show03(){}</p><pre><code>//父类没有抛出异常,子类也不能抛出异常public void show04(){}//如果产生该异常,只能捕获处理,try...catchpublic void show05(){    try {        throw new Exception("编译器异常");    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>}</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>自定义一个注册异常<br>/*<br>    自定义异常类<br>    格式:<br>    public class XXXException extends Exception/RuntimeException{<br>        添加一个空参数的构造方法<br>        添加一个带异常信息的构造方法<br>    }<br>    注意:<br>        1. 自定义异常类一班都是以Exception结尾,说明是一个异常类<br>        2. 必须继承Exception/RuntimeException<br> */<br>public class RegisterException extends Exception {<br>    //添加一个空参数的构造方法</p><pre><code>public RegisterException() {    super();}/*    添加一个带异常信息的构造方法    所有异常类都会有一个带异常信息的构造方法,方法内部会调用父类异常信息的构造方法,让父类来处理这个异常信息 */public RegisterException(String message) {    super(message);}</code></pre><p>}</p><p>/*<br>    要求:模拟注册操作,如果用户名已注册,则抛出异常,并提示:该用户名已被注册<br>    分析:<br>    1. 使用数组保存已经注册过的用户名(数据库)<br>    2. 使用Scanner获取用户输入的注册用户名<br>    3. 定义一个方法,对用户输入中注册的用户名进行判断<br>        遍历存储已经注册过用户名的数组,获取一个用户名<br>        使用获取到的用户名和用户名比较<br>        true:已存在,抛出异常<br>        false:继续遍历比较<br>        循环结束没有找到重名,注册成功</p><p> */<br>public class Demo01RegisterException {<br>    //1. 使用数组保存已经注册过的用户名<br>    static String[] usernames = {“张三”,”李四”,”王八”};</p><pre><code>public static void main(String[] args) throws RegisterException {    //2. Scanner获取    Scanner sc = new Scanner(System.in);    System.out.println("请输入要注册的用户名:");    String username = sc.next();    checkUsername(username);}//3. 定义判断方法public static void checkUsername(String username) throws RegisterException {    //遍历存储用户名    for (String name : usernames) {        if(name.equals(username)){            throw new RegisterException("该用户名已被注册");        }    }    System.out.println("注册成功");}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote02_Collection&#39;</title>
      <link href="/2020/03/12/java-ji-chu/javanote02-collection/"/>
      <url>/2020/03/12/java-ji-chu/javanote02-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>学习集合的目标：</p><ol><li>会使用集合存储数据</li><li>会遍历集合，把数据取出来</li><li>掌握每种集合的特性</li></ol><a id="more"></a><p>集合框架<br>Collection接口-&gt;1. List接口 -&gt;2. Set接口<br>定义的是所有单列集合中共性的方法，都可以使用的方法 (没有带索引的方法)<br>集合框架的学习方式：</p><ol><li>学习顶层：学习顶层接口/抽象类中共性的方法，所有的子类都可以使用</li><li>使用底层：顶层不是接口就是抽象类，无法创建对象使用，需要使用子类</li></ol><p>-&gt;List接口：</p><ol><li>有序的集合(存储和取出元素顺序相同)</li><li>允许存储重复的元素</li><li>有索引，阔以使用普通的for循环遍历</li></ol><p>–&gt;Vecter集合<br>–&gt;ArrayList集合<br>–&gt;LinkedList集合</p><p>-&gt;Set接口</p><ol><li>不允许存放重复元素</li><li>没有索引(不能使用普通的for循环遍历)</li><li>TreeSet集合和HashSet集合是无序的集合(存储和取出元素顺序可能不一致)，LinkedHashSet集合是有序的集合</li></ol><p>–&gt;TreeSet集合<br>–&gt;HashSet集合            —&gt;LinkedHashSet集合</p><h2 id="第一章-Collection接口"><a href="#第一章-Collection接口" class="headerlink" title="第一章 Collection接口"></a>第一章 Collection接口</h2><p>Collection 常用功能<br>    public boolean add(E e); 把给定对象添加到当前集合中<br>    public void clear();  清空集合中所有元素<br>    public boolean remove(E e);  把给定对象在当前集合中删除<br>    public boolean contains(E e);  判断当前集合中是否包含给定对象<br>    public boolean isEmpty();   判断当前集合是否为空<br>    public int size();  返回集合中元素的个数<br>    public Object[] toArray();  把集合中的元素存储到数组中</p><p>public class Demo01Collection {<br>    public static void main(String[] args) {<br>        //创建集合对象，可以使用多态<br>        Collection<string> coll = new ArrayList&lt;&gt;();<br>        System.out.println(coll);</string></p><pre><code>    coll.add("TT");//返回一个布尔值，一般是true，所以可以不用接收    coll.add("CC");    coll.add("YY");    System.out.println(coll);    coll.remove("YY");//返回一个布尔值，集合中存在元素，删除成功返回true，不存在则返回false    System.out.println(coll.contains("YY"));    System.out.println(coll);    System.out.println(coll.isEmpty());    int size = coll.size();    System.out.println(size);    Object[] arr = coll.toArray();    for (int i = 0; i &lt; arr.length; i++) {        System.out.println(arr[i]);    }    coll.clear();//清空集合，但集合还在    System.out.println(coll.isEmpty());}</code></pre><p>}</p><h2 id="第二章-Iterator接口"><a href="#第二章-Iterator接口" class="headerlink" title="第二章 Iterator接口"></a>第二章 Iterator接口</h2><p>迭代：即Collection集合元素的通用获取方式。在取元素之前要先判断集合中有没有元素，<br>如果有，就把这个元素取出来，继续再判断，一直到把集合中所有元素取出</p><p>iterator接口常用方法<br>public E next(): 返回迭代的下一个元素<br>public boolean hasNext(): 如果仍有元素可以迭代，则返回true</p><p>增强for循环，也称for each 循环<br>专门用来遍历数组和集合<br>格式：<br>    for(集合/数组的数据类型 变量名：集合名/数组名){<br>    }</p><p>public class Demo01Foreach {<br>    public static void main(String[] args) {<br>        demo01();<br>        demo02();<br>    }<br>    //增强for循环遍历集合<br>    private static void demo02() {<br>        ArrayList<string> list = new ArrayList&lt;&gt;();<br>        list.add(“CC”);<br>        list.add(“TT”);<br>        list.add(“YY”);<br>        for(String s:list){<br>            System.out.println(s);<br>        }</string></p><pre><code>}//增强for循环遍历数组private static void demo01() {    int[] arr = {1,2,3,4,5};    for(int i:arr){        System.out.println(i);    }}</code></pre><p>}</p><h2 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h2><p>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型<br>泛型也可以看成是一个变量，用来接收数据类型<br>E代表未知的类型</p><p>public class Demo01Generic {</p><pre><code>public static void main(String[] args) {    /*    创建集合对象    不使用泛型：    好处：默认的类型就是Object类型，可以存储任意类型的数据    弊端：不安全，会引发异常     */    demo01();    /*    使用泛型    好处：1. 避免了类型转换的麻烦         2. 把运行期异常，提升到了编译期    弊端：泛型是什么类型，就只能存储什么类型的数据     */    demo02();    }private static void demo01() {    ArrayList list = new ArrayList();    list.add("abc");    list.add(1);    //使用迭代器遍历    //获取迭代器    Iterator it = list.iterator();    //使用迭代器的方法遍历集合    while(it.hasNext()) {        Object obj = it.next();        System.out.println(obj);        //如果想使用String类特有的方法，length获取字符串长度，由于多态不能使用        //向下转型        //int 无法强转，容易出现错误,需要使用instanceof避免        if (obj instanceof String) {            String s = (String) obj;            System.out.println(obj + " length:"+s.length());        }else{            System.out.println(obj+" not String");        }    }}private static void demo02() {    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add("abc");    list.add("cc");    list.add("tt");    for(String s: list){        System.out.println(s+" length:"+s.length());    }}</code></pre><p>}</p><p>泛型的定义与使用<br>定义使用含有泛型的类；<br>格式：<br>修饰符 class 类名&lt;代表泛型的变量&gt;{}</p><p>public class GenericClass<e> {<br>    private E name;</e></p><pre><code>public E getName() {    return name;}public void setName(E name) {    this.name = name;}</code></pre><p>}</p><p>public class Demo02GenericClass {<br>    public static void main(String[] args) {</p><pre><code>    //不写泛型默认为Object    GenericClass gc = new GenericClass();    gc.setName("只能是字符串");    Object name = gc.getName();    System.out.println(name);    //创建泛型为Integer类型    GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;();    gc2.setName(123);    Integer iname = gc2.getName();    System.out.println(iname);    //创建泛型为String类型    GenericClass&lt;String&gt; gc3 = new GenericClass&lt;&gt;();    gc3.setName("TT");    String sname = gc3.getName();    System.out.println(sname);}</code></pre><p>}</p><p>定义含有泛型的方法：泛型定义在方法的修饰符和返回值类型之间<br>格式：<br>修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){<br>    方法体<br>}<br>含有泛型的方法，在调用方法的时候确定泛型的数据类型<br>传递什么类型的参数，泛型就是什么类型<br>public class GenericMethod {<br>    //定义一个含泛型的方法<br>    public <m> void method01(M m){<br>        System.out.println(m);<br>    }</m></p><pre><code>//定义一个有泛型的静态方法public static &lt;S&gt; void method02(S s){    System.out.println(s);}</code></pre><p>}</p><p>public class Demo03GenericMethod {<br>    public static void main(String[] args) {<br>        //创建GenericMethod对象<br>        GenericMethod gm = new GenericMethod();<br>        gm.method01(222);<br>        gm.method01(“TTT”);<br>        gm.method02(“CCC”);//静态方法不建议对象使用</p><pre><code>    //静态方法直接类名.方法使用    GenericMethod.method02("lalala");}</code></pre><p>}</p><p>含有泛型的接口：<br>格式：<br>修饰符 interface接口名&lt;代表泛型的变量&gt;{}</p><p>public interface GenericInterface<i> {<br>    public abstract void method(I i);<br>}</i></p><p>第一种实现方式：</p><p>public class GenericInterfaceImpl implements GenericInterface<string> {<br>    /*<br>    含有泛型的接口，第一种使用方式：定义接口的实现类，实现接口，指定接口的泛型<br>    public interface Iterator<e>{}<br>     */<br>    @Override<br>    public void method(String s) {<br>        System.out.println(s);<br>    }<br>}</e></string></p><p>第二种实现方式：<br>public class GenericInterfaceImpl2<i> implements GenericInterface<i>{<br>    /*<br>    第二种实现方式，接口使用什么泛型，实现类就使用什么泛型，类跟着接口走<br>    就相当于定义了一个含有泛型的类<br>     */<br>    @Override<br>    public void method(I i) {<br>        System.out.println(i);<br>    }<br>}</i></i></p><p>测试：<br>public class Demo04GenericInterface {<br>    /*<br>    测试含有泛型的接口<br>     */<br>    public static void main(String[] args) {<br>        //第一种<br>        GenericInterfaceImpl gil = new GenericInterfaceImpl();<br>        gil.method(“字符串”);<br>        //第二种<br>        GenericInterfaceImpl2<double> gi2 = new GenericInterfaceImpl2&lt;&gt;();<br>        gi2.method(2.2);<br>    }<br>}</double></p><p>泛型通配符：<br>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示，<br>但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用<br>此时只能接收数据，不能往该集合中存储数据</p><p>/*<br>使用方式：不能创建对象使用，只能作为方法的参数使用<br> */<br>public class Demo05Generic {<br>    public static void main(String[] args) {<br>        ArrayList<integer> list01 = new ArrayList&lt;&gt;();<br>        list01.add(1);<br>        list01.add(2);</integer></p><pre><code>    ArrayList&lt;String&gt; list02 = new ArrayList&lt;&gt;();    list02.add("a");    list02.add("b");    printArray(list01);    printArray(list02);}/*定义一个方法，能遍历所有类型的ArrayList集合，这时候我们不知道ArrayList集合使用什么数据类型，可以用泛型的通配符？来接收数据类型注意:    泛型没有继承概念，想都接收，里面不能写Object */public static void printArray(ArrayList&lt;?&gt; list){    //迭代器遍历集合    Iterator&lt;?&gt; it = list.iterator();    while (it.hasNext()){        System.out.println(it.next());    }}</code></pre><p>}</p><p>通配符的高级使用—受限泛型<br>可以设置泛型的上限和下限</p><p>/*<br>    泛型的上限限定： ? extends E 代表泛型只能是E类型的子类/本身<br>    泛型的下限限定： ? super E 代表使用的泛型只能是E类的父类/本身<br> <em>/<br>public class Demo06Generic {<br>    public static void main(String[] args) {<br>        Collection<integer> list1 = new ArrayList&lt;&gt;();<br>        Collection<string> list2 = new ArrayList&lt;&gt;();<br>        Collection<number> list3 = new ArrayList&lt;&gt;();<br>        Collection<object> list4 = new ArrayList&lt;&gt;();<br>        /</object></number></string></integer></em>类与类之间继承关系：<br>            Integer extends Number Extends Object<br>            String extends Object<br>        */<br>        getElement1(list1);<br>        //getElement1(list2);//报错<br>        getElement1(list3);<br>        //getElement1(list4);//报错</p><pre><code>    //getElement2(list1);//报错    getElement2(list2);    //getElement2(list3);//报错    getElement2(list4);}//泛型的上限，此时的泛型?,必须是Number或Number的子类private static void getElement1(Collection&lt;? extends Number&gt; coll1) { }//泛型的下限，此时的泛型?,必须是String或String的父类private static void getElement2(Collection&lt;? super String&gt; coll2) { }</code></pre><p>}</p><h2 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h2><p>案例介绍：<br>按照斗地主的规则，完成洗牌发牌动作<br>具体规则：使用54张牌打乱顺序，三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌</p><ol><li>准备牌：54张牌，存储到一个集合中去<br>特殊牌：大王，小王<br>其他52张牌： 定义一个数组/集合，存储四种花色。定义一个数组/集合，存储13个序号<br>循环嵌套遍历两个数组/集合，组装52张牌</li><li>洗牌：使用集合工具类Collection的方法<pre><code>  shuffle打乱集合中元素的顺序</code></pre></li><li>发牌：<pre><code> 要求：1人17张，剩余三张作为底牌，一人一张轮流发牌，集合的索引(0-53)%3 定义4个集合，存储三个玩家的牌和底牌 索引%3有三个值：0%3=0，1%3=1，2%3=2，3%3=0 索引&gt;=51,改底牌发牌</code></pre></li><li>看牌<pre><code> 直接打印集合，遍历存储玩家和底牌的集合</code></pre></li></ol><p>/*</p><ol><li><p>准备牌</p></li><li><p>洗牌</p></li><li><p>发牌</p></li><li><p>看牌</p><p>*/<br>public class Doudizhu {<br> public static void main(String[] args) {</p><pre><code> //1.准备牌 //定义一个存储54张牌的Arraylist集合，泛型使用String ArrayList&lt;String&gt; poker = new ArrayList&lt;&gt;(); //定义两个数组，一个数组存储牌的花色，一个数组存储牌的序号 String[] colors = {"♠", "♥", "♣", "♦"}; String[] numbers = {"2", "A", "K", "Q", "J", "10", "9", "8", "7", "6", "5", "4", "3"}; //先把大王小王存储到poker中 poker.add("大王"); poker.add("小王"); //循环嵌套遍历两个数组，组装52张牌 for (String number : numbers) {     for (String color : colors) {         //把组装好的牌存入poker中</code></pre><p>//                System.out.println(color+number);</p><pre><code>         poker.add(color + number);     } } //2. 洗牌 Collections.shuffle(poker); //3. 发牌 //定义四个集合，存储玩家的牌和底牌 ArrayList&lt;String&gt; player01 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player02 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; player03 = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; poker.size(); i++) {     if (i &lt; 51) {         if (i % 3 == 0) {             player01.add(poker.get(i));         } else if (i % 3 == 1) {             player02.add(poker.get(i));         } else {             player03.add(poker.get(i));         }     } else {         dipai.add(poker.get(i));     } } //4. 看牌 System.out.println("赌神：" + player01); System.out.println("赌侠：" + player02); System.out.println("赌怪：" + player03); System.out.println("底牌：" + dipai);</code></pre><p> }<br>}</p></li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>栈：先进后出<br>入栈123，出栈321<br>队列：先进先出<br>存储123，取出123</p><p>数组：查询快：数组的地址是连续的，我们通过数组的首地址可以找到数组，通过数组的索引可以快速查找某一个元素<br>      增删慢：数组的长度是固定的，我们想要增加/删除一个元素，必须创建一个数组，把源数组的数据复制过来</p><p>链表：查询慢：链表中地址不是连续的，每次查询元素都必须从头开始查询<br>      增删快：链表结构增加/删除一个元素，对链表的整体结构没有影响，所以增删快。<br>    链表中每一个元素也称为一个节点<br>    一个节点包含了一个数据源（存储数组），两个指针域（存储地址）<br>    自己的地址|数据|下一个节点的地址<br>    单向链表：链表中只有一条链子，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）<br>    双向链表：链表中有两条链子，有一条专门记录元素的顺序，是一个有序的集合</p><p>红黑树：趋近于平衡树，查询速度非常快，查询叶子节点最大次数和最小次数不能超过2倍<br>        约束：1. 节点可以是红色的或者是黑色的<br>              2. 根节点是黑色的<br>              3. 叶子节点(空节点）是黑色的<br>              4. 任何一个节点到其每一个叶子节点的所有路径上的黑色节点数相同</p><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>继承了Collection接口<br>特点：<br>    1. 有序的集合，存储元素和取出元素的顺序是一致的(存储123，取出123)<br>    2. 有索引，包含了一些带索引的方法<br>    3. 允许存储重复的元素</p><p>List接口中带索引的方法(特有)<br>    add(int index,E element): 将指定的元素添加到该集合指定位置上<br>    get(int index): 返回集合中指定位置的元素<br>    remove(int index): 移除列表中指定位置的元素，返回的是被移除的元素<br>    set(int index,E element): 用指定元素替换集合中指定位置的元素，返回更新前的元素<br>注意： 操作索引时，一定要防止索引越界异常<br>public class Demo01List {<br>    public static void main(String[] args) {<br>        //创建一个List集合对象，多态<br>        List<string> list = new ArrayList&lt;&gt;();<br>        //使用add的方法往集合中添加元素<br>        list.add(“a”);<br>        list.add(“b”);<br>        list.add(“c”);<br>        list.add(“a”);<br>        //打印集合<br>        System.out.println(list); //[a,b,c,a] 有序，允许重复<br>        list.add(3,”TT”);<br>        System.out.println(list); //[a, b, c, TT, a]<br>        list.remove(2); //返回c<br>        System.out.println(list); //[a, b, TT, a]<br>        list.set(3,”A”); //返回a<br>        System.out.println(list); //[a, b, TT, A]<br>    }<br>}</string></p><p>List的实现类<br>    ArrayList集合：底层使用的是数组，因此增删慢，查找快</p><pre><code>LinkedList集合：1. List接口的链表实现，查询慢，增删快2. 包含大量首尾元素方法3. 使用特有方法时，不能使用多态addFirst(E e): 将指定元素插入此列表开头 addLast(E e): 将指定元素添加到此列表结尾push(E e): 将元素推入此列表表示的堆栈pop(): 从堆栈弹出一个元素getFirst(): 返回列表第一个元素getLast():返回此列表最后一个元素removeFirst(): 移除并返回此列表第一个元素removeLast(): 一处并返回此列表最后一个元素isEmpty(): 从此列表所表示的堆栈处弹出一个元素LinkedList&lt;String&gt; linked = new LingkedList&lt;&gt;();</code></pre><h2 id="Set接口："><a href="#Set接口：" class="headerlink" title="Set接口："></a>Set接口：</h2><p>继承了Collection接口</p><ol><li>不允许存储重复的元素</li><li>没有带索引的方法，也不能使用普通的for循环遍历</li></ol><p>Set的实现类<br>    HashSet：<br>    1. 不允许存储重复元素<br>    2. 没有带索引的方法，也不能使用普通的for循环遍历<br>    3. 是一个无序的集合，存储元素与取出元素有可能不一致<br>    4. 底层是一个哈希表结构(查询速度非常快)<br>    public class Demo01Set {<br>    public static void main(String[] args) {<br>        Set<integer> set = new HashSet&lt;&gt;();<br>        set.add(1);<br>        set.add(3);<br>        set.add(2);<br>        set.add(1);<br>        //使用迭代器遍历<br>        Iterator<integer> it = set.iterator();<br>        while (it.hasNext()) {<br>            System.out.println(it.next());//1 2 3<br>        }</integer></integer></p><pre><code>}</code></pre><p>}</p><p>哈希值：是一个十进制的整数，由系统随即给出(就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是实际存储的物理地址(16进制)，进制不同)<br>        Obje类中有一个方法，可以获取对象的哈希值<br>        int hashCode() 返回对象哈希码值<br>哈希表：采用数组+链表+红黑树实现，当链表长度超过阈值(8)时，将链表转换为红黑树，大大减少查找时间</p><p>存储数据到集合中，先计算元素的哈希值<br>数组结构：把元素进行了分组，(相同哈希值的元素是一组)链表/红黑树结构把相同哈希值的元素连接到了一起<br> 0 | 1 | 2 |…| 15 |  初始容量16<br> a   c<br> a   c<br>哈希值相同的元素用链表存在同一个组里，超过8个就会把链表转换成红黑树</p><p>Set集合不允许存储重复元素的原理<br>public class Demo02HashSetSaveString {<br>    public static void main(String[] args) {<br>        //创建HashSet集合对象<br>        HashSet<string> set = new HashSet&lt;&gt;();<br>        String s1 = new String(“abc”);<br>        String s2 = new String(“abc”);</string></p><pre><code>    set.add(s1);    set.add(s2);    set.add("重地");    set.add("通话");    set.add("abc");    System.out.println(set);//[重地, 通话, abc]}</code></pre><p>}</p><p>Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法，判断是否重复<br>set.add(s1);<br>add方法会调用s1的hashCode方法，计算字符串“abc”的哈希值，哈希值是96354<br>在集合中找有没有96354这个哈希值的元素，发现没有<br>就会把s1存到集合中</p><p>set.add(s2);<br>add方法会调用s2的hashCode方法，计算字符串“abc”的哈希值，哈希值是96354<br>在集合中找有没有96354这个哈希值的元素，发现有(哈希冲突)<br>s2会调用equals方法和哈希值相同的元素进行比较s2.equals(s1),返回true<br>两个元素哈希值相同，equals方法返回true，认定两个元素相同<br>就不会把s2存到集合中</p><p>set.add(“重地”);<br>add方法会调用”重地”的hashCode方法，计算字符串”重地”的哈希值，哈希值是1179395<br>在集合中找有没有1179395这个哈希值的元素，发现没有<br>就会把”重地”存到集合中</p><p>set.add(“通话”);<br>add方法会调用”通话”的hashCode方法，计算字符串”通话”的哈希值，哈希值是1179395<br>在集合中找有没有1179395这个哈希值的元素，发现有(哈希冲突)<br>“通话”会调用equals方法和哈希值相同的元素进行比较”通话”.equals(“重地”),返回false<br>两个元素哈希值相同，equals方法返回true，认定两个元素不同<br>就会把”通话”存到集合中</p><p>HashSet存储自定义类型元素<br>给HashSet中存放自定义元素时，需要重写对象中的hashCode和equals方法，<br>建立自己的比较方式，才能保证HashSet集合中的对象唯一<br>    @Override<br>    public boolean equals(Object o) {<br>        if (this == o) return true;<br>        if (o == null || getClass() != o.getClass()) return false;<br>        Person person = (Person) o;<br>        return age == person.age &amp;&amp;<br>            Objects.equals(name, person.name);<br>    }</p><pre><code>@Overridepublic int hashCode() {    return Objects.hash(name, age);}</code></pre><p>LinkedHashSet集合<br>继承了HashSet<br>底层是一个哈希表+链表，多了一条链表记录元素的存储顺序，保证元素有序<br>有序的，也不允许重复元素</p><p>可变参数：<br>如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式<br>修饰符 返回值类型 方法名(参数类型… 形参名){}</p><p>使用前提：当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数<br>public class Demo01VarArgs {<br>    public static void main(String[] args) {<br>        /*<br>        定义计算（0-n）整数和的方法<br>        已知：计算整数的和，数据类型确定为int<br>        但是参数个数不确定，不知道要计算几个整数的和，就可以使用可变参数<br>        add();就会创建一个长度为0的数组，new int[0]<br>        add(10);就会创建一个长度为1的数组，new int[]{10}<br>        add(10,20);就会创建一个长度为2的数组，new int[]{10,20}</p><pre><code>    注意事项：    1. 一个方法的参数列表，只能有一个可变参数    2. 如果方法的参数有多个，那么可变参数必须在参数列表的末尾     */    int i = add();    System.out.println(i);}public static int add(int... arr) {    System.out.println(arr);    return 0;}//可变参数终极写法,用Object接收所有类型public static void method(Object... obj) {}</code></pre><p>}</p><h2 id="Colletions"><a href="#Colletions" class="headerlink" title="Colletions"></a>Colletions</h2><p>集合工具类，用来对集合进行操作<br>部分方法：<br>Collections.addAll(Collection<t> c, T… elements):往集合中添加一些元素<br>Collections.shuffle(List<!--?--> list) 打乱集合顺序Collections.sort(List<!--?-->  list): 将集合中元素按照默认规则排序。<br>Collections.sort(List<t> list,Comparator&lt;? super T&gt;):将集合中元素按照制定规则排序<br>注意：sort方法使用前提，被排序的集合里面存储的元素，必须实现Comparable接口，重写接口中的compareTo方法定义排序的规则</t></t></p><p>Collections.sort(List&lt;?&gt;  list):<br>public class Person implements Comparable<person>{<br>    private String name;<br>    private int age;<br>    @Override<br>    public int compareTo(Person o) {<br>        //自定义比较的规则，比较两个人的年龄<br>        //return this.getAge() - o.getAge();//年龄升序排序<br>        return o.getAge() - this.getAge();//年龄降序排序</person></p><pre><code>}</code></pre><p>}</p><p>Comparable接口排序规则：<br>    自己(this) - 参数：升序</p><p>Collections.sort(List<t> list,Comparator&lt;? super T&gt;):<br>Comparator和Comparable的区别<br>    Comparable：自己(this)和别人(参数)比较，自己需要实现Comparable接口，重写比较的规则compareTo方法<br>    Comparator：相当于找一个第三方的裁判，比较两个</t></p><p>Collections.sort(list01,new Comparator<integer>(){     //匿名内部类<br>    //重写比较规则<br>    publicinterestingcompare（Integer o1，Integer o2){<br>        //return o1-o2;//升序<br>        return o2-o1;//降序<br>    }<br>});</integer></p><h2 id="day04-Map"><a href="#day04-Map" class="headerlink" title="day04 Map"></a>day04 Map</h2><p>第一章 Map集合<br>Map&lt;K,V&gt;<br>将键映射到值的对象，一个映射不能包含重复的键，每个键最多只能映射一个值<br>特点：1. Map集合是一个双列集合，一个元素包含两个值(一个是key,一个是value)<br>      2. Map集合中的元素,key和value的数据类型可以相同,也可以不同<br>      3. Map集合中的元素,key不允许重复,value是可以重复的<br>      4. Map集合中的元素,key和value是一一对应的</p><h2 id="Map接口常用实现类"><a href="#Map接口常用实现类" class="headerlink" title="Map接口常用实现类"></a>Map接口常用实现类</h2><p>I. HashMap&lt;K,V&gt;集合:<br>    1. HashMap集合底层是哈希表;查询速度特别快.<br>    jdk1.8之后:数组+单向链表/红黑树<br>    2. HashMap集合是一个无序的集合,存储元素和取出元素的顺序可能不一致</p><pre><code>LinkedHashMap&lt;K,V&gt;集合 extends HashMap&lt;K,V&gt;集合LinkedHashMap&lt;K,V&gt;集合的特点:1. LinkedHashMap集合底层是哈希表+链表(保证迭代顺序)2. LinkedHashMap集合是有序的集合,存储元素和取出元素是一致的</code></pre><p>Map接口中的常用方法:<br>public class Demo01Map {<br>    public static void main(String[] args) {<br>        show01();//put方法<br>        show02();//remove方法<br>        show03();//get方法</p><pre><code>}/*    public V put(K key,V value): 把指定的键与指定的值添加到Map集合中     返回值：V         存储键值对时，key不重复，返回值V是null。key重复，会使用新的value替换map中重复的value，返回被替换的value值 */private static void show01() {    //创建Map集合对象，多态    Map&lt;String,String&gt; map = new HashMap&lt;&gt;();    String v1 = map.put("TT","CC");    System.out.println("v1："+v1);//v1：null    String v2 = map.put("TT","YY");    System.out.println("v2："+v2);//key重复，返回v2：CC    System.out.println(map);//{TT=YY}    map.put("杨过","小龙女");    map.put("尹志平","小龙女");    System.out.println(map);//{TT=YY, 杨过=小龙女, 尹志平=小龙女}}/*    public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除,返回被删除元素的值     返回值：V         key存在,v返回被删除的值         key不存在,v返回null */private static void show02() {    //创建Map对象    Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();    map.put("TT",172);    map.put("CC",160);    map.put("YY",178);    System.out.println(map);//{TT=172, CC=160, YY=178}    Integer v1 = map.remove("YY");    System.out.println("v1:"+v1);//v1:178    System.out.println(map);//{TT=172, CC=160}}/*public V get(Object key)根据指定的键,在Map集合中获取对应的值    返回值:        key存在,返回对应值,key不存在则返回null */private static void show03() {    Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();    map.put("TT",172);    map.put("CC",160);    map.put("YY",178);    Integer t = map.get("TT");    Integer c = map.get("bao");    System.out.println("t:"+t +" c:" + c);//t:172 c:null    //containsKey(Object key) 判断是否包含指定键,包含返回true,不包含返回false    System.out.println(map.containsKey("TT"));//true}</code></pre><p>}</p><p>Map集合的遍历：<br>第一种：<br>Set<k> keySet() 把Map集合中所有的key取出来存储在Set集合中 -&gt; 使用迭代器/增强for遍历set集合获取每一个key -&gt; get(key)获取键值<br>/*<br>    Map集合第一种遍历方式:通过键找值<br>    Set<k> keySet() 返回此映射中包含的键的视图<br> */<br>public class Demo02KeySet {<br>    public static void main(String[] args) {<br>        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br>        map.put(“TT”,172);<br>        map.put(“CC”,160);<br>        map.put(“YY”,178);</k></k></p><pre><code>    //1. 取出key放到集合    Set&lt;String&gt; set = map.keySet();    //2. 迭代器遍历set集合    Iterator&lt;String&gt; it = set.iterator();    while (it.hasNext()){        String key = it.next();        //3. get        Integer value = map.get(key);        System.out.println(key+"="+value);    }    //增强for    for (String key:map.keySet()){        Integer value = map.get(key);        System.out.println("foreach:"+key+"="+value);    }}</code></pre><p>}</p><p>第二种：<br>Entry键值对对象：Map.Entry&lt;K,V&gt;<br>在Map接口中有一个内部接口Entry<br>作用：当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象,键与值的映射关系)<br>entrySet(): 把Map集合内部的多个entry对象取出来存储到一个Set集合中 -&gt; 遍历Set集合中的每一个Entry对象 </p><p>Entry对象中的两个方法:getKey()获取所有key,getValue()获取所有value</p><p>/*<br>    Map集合遍历的第二种方式:使用Entry对象遍历<br>    Map集合中的方法:<br>        Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此映射中包含的映射关系的Set视图<br> */<br>public class Demo03EntrySet {<br>    public static void main(String[] args) {<br>        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();<br>        map.put(“TT”,172);<br>        map.put(“CC”,160);<br>        map.put(“YY”,178);</p><pre><code>    //1. 使用Map集合中的方法entry Set(),把Map中多个Entry出来,存储到Set集合中    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();    //2. 遍历Set    //迭代器    Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it = set.iterator();    while(it.hasNext()){        Map.Entry&lt;String,Integer&gt; entry = it.next();        System.out.println(entry);        System.out.println(entry.getKey());        System.out.println(entry.getValue());    }    System.out.println("-------------------------------------");    //增强for    for (Map.Entry&lt;String,Integer&gt; entry:set) {        System.out.println(entry);    }}</code></pre><p>}</p><p>HashMap存储自定义类型键值:<br>/*<br>    HashMap存储自定义类型键值<br>    Map集合保证key唯一:作为key的元素,必须重写hashCode方法和equals方法,以保证key唯一<br> */<br>public class Demo01HashMapSavePerson {<br>    public static void main(String[] args) {<br>        show01();<br>        System.out.println(“——————————-“);<br>        show02();<br>    }</p><pre><code>/*    HashMap存储自定义类型键值    key:String类型        String类重写了hashCode方法和equals方法,可以保证key唯一    value:Person类型        value可以重复(同名同年龄) */private static void show01() {    HashMap&lt;String,Person&gt; map = new HashMap&lt;&gt;();    map.put("TT",new Person("田世庆",18));    map.put("CC",new Person("呈呈",18));    map.put("YY",new Person("杨二",15));    map.put("ZZ",new Person("阿爆",17));    map.put("TT",new Person("阿浪",18));    Set&lt;String&gt; set = map.keySet();    for (String key:set) {        System.out.println(key+"--&gt;"+map.get(key));    }    /*        TT--&gt;Person{name='阿浪', age=18}        CC--&gt;Person{name='呈呈', age=18}        YY--&gt;Person{name='杨二', age=15}        ZZ--&gt;Person{name='阿爆', age=17}        key唯一     */}/*    HashMap存储自定义类型键值    key:Person类型        Person类必须重写hashCode方法和equals方法,保证key唯一    value:String类型        String可以重复 */private static void show02() {    HashMap&lt;Person,String&gt; map = new HashMap&lt;&gt;();    map.put(new Person("田世庆",18),"TT");    map.put(new Person("呈呈",18),"CC");    map.put(new Person("杨二",15),"YY");    map.put(new Person("阿爆",17),"ZZ");    map.put(new Person("田世庆",18),"Tian");    Set&lt;Person&gt; set = map.keySet();    for (Person key:set) {        System.out.println(key+"--&gt;"+map.get(key));    }    /*        Person{name='杨二', age=15}--&gt;YY        Person{name='呈呈', age=18}--&gt;CC        Person{name='田世庆', age=18}--&gt;Tian        Person{name='阿爆', age=17}--&gt;ZZ        重写hashCode和equals后保证了唯一     */}</code></pre><p>}</p><p>LinkedHashMap&lt;K,V&gt;<br>extends HashMap&lt;K,V&gt;<br>有序的,存储abc,打印abc<br>public class Demo01LinkedHashMap {<br>    public static void main(String[] args) {<br>        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();<br>        map.put(“a”,”A”);<br>        map.put(“c”,”C”);<br>        map.put(“b”,”B”);<br>        System.out.println(map);//{a=A, b=B, c=C},key不允许重复,无序</p><pre><code>    LinkedHashMap&lt;String,String&gt; linked = new LinkedHashMap&lt;&gt;();    linked.put("a","A");    linked.put("c","C");    linked.put("b","B");    System.out.println(linked);//{a=A, c=C, b=B},key不允许重复,有序}</code></pre><p>}</p><h2 id="Map接口常用实现类-1"><a href="#Map接口常用实现类-1" class="headerlink" title="Map接口常用实现类"></a>Map接口常用实现类</h2><p>II. HashTable&lt;K,V&gt;<br>/*<br>    Hashtable:底层也是一个哈希表,是一个线程安全的集合,是单线程集合,速度慢<br>    HashMap:底层是一个哈希表,是一个线程不安全的集合,多线程,速度快<br>    HashMap集合(之前学的所有集合):可以存储null值,null键<br>    Hashtable集合,不能存储null值,null键</p><pre><code>Hashtable和vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了Hashtable的子类Properties依然活跃在历史舞台Properties集合是一个唯一和IO流相结合的集合</code></pre><p> */<br>public class Demo02Hashtable {<br>    public static void main(String[] args) {<br>        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();<br>        map.put(null,”a”);<br>        map.put(“b”,null);<br>        map.put(null,null);<br>        System.out.println(map);//{null=null, b=null},允许空值空键</p><pre><code>    Hashtable&lt;String,String&gt; table = new Hashtable&lt;&gt;();    //map.table(null,"a");    //map.table("b",null);都会空指针异常}</code></pre><p>}</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>计算一个字符串中每个字符出现次数<br>使用Scanner获取用户输入的一个字符串<br>aaabbbcca<br>a            4<br>b            4<br>c            2<br>不能重复 可以重复<br>字符     统计个数<br>=&gt; 使用HashMap&lt;Character,Integer&gt;<br>=&gt; 遍历字符串,获取每一个字符</p><ol><li>String类的方法toCharArray,把字符串转为为一个字符数组,遍历数组</li><li>String类的方法length() + charAt(索引)</li></ol><p>=&gt; 使用Map集合中的方法判断获取到的字符是否存储在Map集合中</p><ol><li>使用Map集合中的方法containsKey(获取到的字符),返回布尔值<br>  true:<br>  value++<br>  false:<br>  把字符作为key,value设为1</li><li>使用Map集合的get(key)也可以判断</li></ol><p>/*<br>    练习<br>        计算一个字符串中每个字符出现次数<br> */<br>public class Exercise01 {<br>    public static void main(String[] args) {<br>        //1.使用Scanner获取用户输入的一个字符串<br>        Scanner sc = new Scanner(System.in);<br>        System.out.println(“请输入一个字符串:”);<br>        String str = sc.next();<br>        //2. 创建HashMap集合<br>        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();<br>        //3. 遍历字符串<br>        for(char c:str.toCharArray()){<br>            //4. 判断集合中是否已存在<br>            if(map.containsKey(c)){<br>                map.put(c,map.get(c)+1);<br>            }else{<br>                map.put(c,1);<br>            }<br>        }<br>        System.out.println(map);<br>    }<br>}</p><h2 id="JDk9对集合添加的优化"><a href="#JDk9对集合添加的优化" class="headerlink" title="JDk9对集合添加的优化"></a>JDk9对集合添加的优化</h2><p>新特性:List接口,Set接口,Map接口里面增加了一个静态的方法of,可以给集合一次性添加多个元素<br>static <e> List<e> of (E… elements)<br>使用前提:当集合中存储的元素的个数已经确定,不再改变时使用<br>注意: 1. of方法只适用于List接口,Set接口,Map接口,不适用于接口的实现类<br>      2. of方法的返回值是一个不能改变的集合,集合不能再使用add,put方法添加元素,会抛出异常<br>      3. Set接口和Map接口在调用of方法的时候,不能有重复的元素,否则会抛出异常</e></e></p><p>List<string> list = List.of(“a”,”b”,”a”);</string></p><h2 id="Debug追踪"><a href="#Debug追踪" class="headerlink" title="Debug追踪"></a>Debug追踪</h2><p>/*<br>    Debug调试程序:<br>        可以让代码逐行执行,查看代码执行的过程<br>    使用方式:在行号右边,左键单击,添加断点(每个方法的第一行,哪里有bug添加哪里)<br>    右键,选择Debug执行<br>    程序会停止在添加的第一个断点处<br>    执行程序:<br>        f8:逐行执行程序<br>        f7:进入方法中<br>        shift+f8:跳出方法<br>        f9:跳到下一个断点,没有则结束程序<br>        ctrl+f2:退出debug<br> */</p><h2 id="斗地主案例2"><a href="#斗地主案例2" class="headerlink" title="斗地主案例2"></a>斗地主案例2</h2><p>有序版本</p><ol><li>准备牌：<br>54张牌，存储到一个集合中去<br>特殊牌：大王，小王<br>其他52张牌： 定义一个数组/集合，存储四种花色。定义一个数组/集合，存储13个序号<br>循环嵌套遍历两个数组/集合，组装52张牌</li><li>Map存储52张牌<br>牌的索引  组装好的牌<br>key       value<br>0         大王<br>1         小王<br>2         ♠2<br>.         .<br>.         .<br>.         .<br>53        ♦3</li></ol><p>创建一个List保存索引,对牌的索引shuffle<br>3. 发牌<br>一人一张每人17张<br>集合索引%3<br>最后三张给底牌<br>4. 排序<br>Collections方法soft(List)<br>5.看牌:可以使用查表法<br>遍历List集合,根据索引key获取Map的value<br>/*<br>    有序版本<br>    1. 准备牌<br>    2. 洗牌<br>    3. 发牌<br>    4. 排序<br>    5. 看牌<br> */<br>public class Doudizhu2 {<br>    public static void main(String[] args) {<br>        //1.准备牌<br>        HashMap&lt;Integer,String&gt; poker = new HashMap&lt;&gt;();<br>        //创建一个集合存放索引<br>        List<integer> pokerIndex = new ArrayList&lt;&gt;();<br>        //组装牌<br>        String[] colors = {“♠”,”♥”,”♣”,”♦”};<br>        String[] numbers = {“2”, “A”, “K”, “Q”, “J”, “10”, “9”, “8”, “7”, “6”, “5”, “4”, “3”};<br>        int index = 0;<br>        poker.put(index,”大王”);<br>        pokerIndex.add(index);<br>        index++;<br>        poker.put(index,”小王”);<br>        pokerIndex.add(index);<br>        index++;</integer></p><pre><code>    for (String number : numbers) {        for (String color : colors) {            poker.put(index,color+number);            pokerIndex.add(index);            index++;        }    }    //System.out.println(poker);    //2. 洗牌    Collections.shuffle(pokerIndex);    //3. 发牌    List&lt;Integer&gt; player1 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; player2 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; player3 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; dipai = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; pokerIndex.size(); i++) {        if(i&lt;51){            if(i%3==0){                player1.add(pokerIndex.get(i));            }else if(i%3==1){                player2.add(pokerIndex.get(i));            }else{                player3.add(pokerIndex.get(i));            }        }else{            dipai.add(pokerIndex.get(i));        }    }    //4. 排序    Collections.sort(player1);    Collections.sort(player2);    Collections.sort(player3);    Collections.sort(dipai);    //5. 看牌    show("周星驰",player1,poker);    show("周润发",player2,poker);    show("卢本伟",player3,poker);    show("底牌",dipai,poker);}private static void show(String name,List&lt;Integer&gt; player,HashMap&lt;Integer,String&gt; poker) {    System.out.print(name+": ");    for (Integer key : player) {        System.out.print(poker.get(key) + " ");    }    System.out.println();    System.out.println("--------------------------------");}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaNote01&#39;</title>
      <link href="/2020/03/12/java-ji-chu/javanote01/"/>
      <url>/2020/03/12/java-ji-chu/javanote01/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h2><p>2.1 Date类<br>    表示日期时间的类，精确到毫秒，特定的瞬间<br>    当前日期：2088-01-01<br>    时间原点：1970-01-01 00:00:00(英国格林威治)</p><a id="more"></a><p>public class Demo01Date{<br>    public static void main(String[] args){<br>        System.out.println(System.currentTimeMiLLis());//获取时间原点到当前时间经历了多少毫秒</p><pre><code>}</code></pre><p>}</p><p>public class Demo02Date {<br>    public static void main(String[] args) {<br>//        demo01();<br>        demo02();<br>        demo03();<br>    }</p><pre><code>//成员方法 Long getTime() 把日期转换为毫秒private static void demo03() {    Date date = new Date();    long time = date.getTime();    System.out.println(time);//1583119265044}//带参数的构造方法//Date(Long date) 传递毫秒值，把毫秒值转换为Date日期private static void demo02() {    Date date = new Date(1583119265044L);    System.out.println(date);}// Date类空参数构造方法private static void demo01() {    Date date = new Date();    System.out.println(date);}</code></pre><p>}</p><p>2.2 DateFormat类<br>    java.text<br>    日期时间格式化子类的抽象类</p><p>public class Demo01DateFormat {<br>    /*<br>    成员方法：<br>    String format(Date date) 按照指定模式，把Date日期格式化为符合模式的字符串<br>    Date parse(String source) 把符合模式的字符串解析为Date日期 throws 抛出异常<br>    构造方法：<br>    SimpleDateFormat(String pattern) 用给定模式构造<br>    y 年 M 月 d 日 H 时 m 分 s 秒<br>    写对应的模式，会把模式替换为对应的日期和时间<br>    ‘yyyy-MM-dd HH:mm:ss’<br>    注意：<br>    模式中的字母不能改，连接模式的符号可以改<br>    ‘yyyy年MM月dd日 HH时mm分ss秒’</p><pre><code> */public static void main(String[] args) throws ParseException {    demo01();    demo02();}private static void demo01() {    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");    Date date = new Date();    String d = sdf.format(date);    System.out.println(date);    System.out.println(d);}private static void demo02() throws ParseException {    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");    Date date = sdf.parse("2020年03月02日 13时05分54秒");    System.out.println(date);}</code></pre><p>}</p><p>2.4 Calendar类<br>    是一个抽象类，里面提供了很多操作日历字段的方法<br>    无法直接创建对象使用，里面有一个静态方法叫个体Instance(),该方法返回Calendar子类对象</p><pre><code>/*</code></pre><p>常用成员方法：<br>public int get(int field): 返回给定日历字段的值<br>public void set(int field,int value): 将指定日历字段设置为给定值<br>public abstract void add(int field,int amount): 根据日历的规则，为给定日历字段添加或减去指定的时间量<br>public Date getTime(): 返回一个表示此Calendar时间值的Date对象</p><p> */<br>public class CalendarClass {<br>    public static void main(String[] args) {</p><pre><code>    demo01();}private static void demo01() {    Calendar c = Calendar.getInstance();    System.out.println(c);    int year = c.get(Calendar.YEAR);    System.out.println(year);    int month = c.get(Calendar.MONTH) + 1;//计算机中从0开始    System.out.println(month);    int date = c.get(Calendar.DATE);    System.out.println(date);    //set 方法    c.set(Calendar.YEAR, 200);    c.set(Calendar.MONTH, 3);    int year2 = c.get(Calendar.YEAR);    System.out.println("after setting" + year2);    int month2 = c.get(Calendar.MONTH) + 1;//计算机中从0开始    System.out.println("after setting" + month2);    //同时设置年月日    c.set(1997, 3, 10);    int year3 = c.get(Calendar.YEAR);    System.out.println("after setting" + year3);    int month3 = c.get(Calendar.MONTH) + 1;//计算机中从0开始    System.out.println("after setting" + month3);    //add方法    c.add(Calendar.YEAR, 8);    c.add(Calendar.MONTH, -2);    int year4 = c.get(Calendar.YEAR);    System.out.println("after setting" + year4);    int month4 = c.get(Calendar.MONTH) + 1;//计算机中从0开始    System.out.println("after setting" + month4);    //getTime方法    Date d = c.getTime();    System.out.println(d);}</code></pre><p>}</p><h2 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h2><p>提供大量静态方法，可以获取与系统相关的信息或系统级操作<br>常用方法：<br>public static long currentTimeNillis(): 返回以毫秒为单位的当前时间<br>public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int,length): 将数组中指定数据拷贝到另一个数组中</p><p>public class Demo01System {<br>    public static void main(String[] args) {<br>        demo01();<br>        demo02();<br>    }</p><pre><code>private static void demo01() {    //public static long currentTimeNillis;//返回以毫秒为单位的当前时间,用来看程序的效率    //程序开始前，获取一次    long s = System.currentTimeMillis();    //执行for循环    for (int i = 1; i &lt;= 9999; i++) {        System.out.println(i);    }    //程序执行后，获取一次毫秒值    long e = System.currentTimeMillis();    System.out.println("total"+(e-s)+"ms");}private static void demo02() {    /*public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int,length)    src 源数组    srcPos 源数组中的起始位置(起始索引)    dest 目标数组    destPos 目标数组中的起始位置    length 要复制的数组元素的数量     */    // 将src前三个数字复制到dest前三个位置上    int [] src = new int[]{1,2,3,4,5};    int [] dest = {6,7,8,9,0};    System.out.println("before copying"+ Arrays.toString(dest));    System.arraycopy(src,0,dest,0,3);    System.out.println("after copying"+ Arrays.toString(dest));}</code></pre><p>}</p><h2 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h2><p>String类是常量，创建之后不可改变。进行字符串相加，内存中就会有多个字符串，占用空间多，效率低下<br>StingBuilder类 字符串缓冲区，可以提高字符串的操作效率底层是一个数组，但没有被final修饰，可以改变长度<br>StringBuilder在内存中始终是一个数组，占用空间少，效率高。初始长度16，如果超出容量，会自动扩容</p><p>public class StringBuilderClass {<br>    /*<br>    构造方法：<br>        StringBuilder() 无参构造<br>        StringBuilder(String str) 带参构造，初始化为指定字符串内容，可用于String-&gt;StringBuilder<br>    常用成员方法：<br>         public StringBuilder append(): 添加任意类型数据的字符串形式，并返回当前对象自身<br>         public String toString(): 将当前StringBuilder对象转换为String，可用于StringBuilder-&gt;String</p><pre><code> */public static void main(String[] args) {    //无参构造    StringBuilder bu = new StringBuilder();    System.out.println("bu:"+bu);    //带参构造    StringBuilder bu2 = new StringBuilder("abc");    System.out.println("bu2:"+bu2);    StringBuilder bu1 = bu.append("abc");//把bu地址赋值给了bu1    System.out.println(bu);//"abc"    System.out.println(bu1);//"abc"    System.out.println(bu==bu1);//比较的是地址，返回true    //实际上使用append方法无需接受返回值    bu.append(1);    System.out.println(bu);    //链式编程，返回的是对象，可以直接再调用方法    bu.append("China").append("No.").append("1");    System.out.println(bu);    //toSting方法    String str = "hello";    System.out.println("str:"+str);    StringBuilder builder = new StringBuilder(str);    builder.append("world");    System.out.println("builder:"+builder);    String s = builder.toString();    System.out.println("s:"+s);}</code></pre><p>}</p><p>// .var 自动生成变量接收当前对象  new StringBuilder(“abc”).var =&gt;StringBuilder bu2 = new StringBuilder(“abc”);</p><h2 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h2><p>Java 提供了两个类型系统，基本类型和引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用<br>因为对象可以做更多的功能，如果想要基本类型像对象一样操作，就可以使用基本类型对应的包装类<br>基本类型：byte, short, int, long, float, double, char, boolean<br>包装类：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p><p>装箱拆箱<br>装箱：把基本类型的数据，包装到包装类中<br>    构造方法：<br>        Integer(int value) 构造一个新分配的Integer对象，它表示指定的int值<br>        Integer(String s) 构造一个新分配的Integer对象，它表示String参数所指示的int值<br>            传递的字符串，必须是基本类型的字符串，否则抛出异常，‘100’正确，‘a’异常<br>    静态方法：<br>        static Integer valueOf(int i) 返回一个表示指定的int值的Intger实例<br>        static Integer valueOf(String s) 返回保存指定的String 的值的Integer对象</p><p>拆箱：在包装类中取出基本类型的数据，包装到包装类中<br>    成员方法：<br>    int intValue() 以int类型返回该Integer的值</p><p>public class Demo01Integer {<br>    public static void main(String[] args) {<br>        //装箱<br>        Integer in1 = new Integer(1);//1<br>        System.out.println(in1);//重写了toString方法<br>        Integer in2 = new Integer(“1”);<br>        System.out.println(in2);//1</p><pre><code>    //静态方法    Integer in3 = Integer.valueOf("1");    System.out.println(in3);    //拆箱    int i = in1.intValue();    System.out.println(i);    //自动装箱    Integer in = 1;    //自动拆箱    in = in+2;//in是包装类，无法运算，会自动转换成int}</code></pre><p>}</p><p>基本类型与字符串类型之间的互相转换<br>基本类型-&gt;字符串<br>    1. 基本类型的值 +”” 最简单的方法<br>    2. 包装类的静态方法toString(参数)，不是Obeject类的toString()重载<br>    3. String类的静态方法valueOf(参数)<br>        static String valueOf(int i) </p><p>字符串-&gt;基本类型<br>        使用包装类的静态方法parseXXX(“数值类型的字符串”)<br>        Integer类：static int parseInt(String s)<br>        Double类：static double parseDouble(String s)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaBasics5&#39;</title>
      <link href="/2020/03/12/java-ji-chu/javabasics5/"/>
      <url>/2020/03/12/java-ji-chu/javabasics5/</url>
      
        <content type="html"><![CDATA[<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个事物的内部包含另一个事物，一个类内部包含另一个类</p><a id="more"></a><ol><li>成员内部类<br>修饰符 class 外部类名称{<br> 修饰符 class内部类名称{<br> }<br>}<br>内用外随意，外用内一定要内部对象</li></ol><p>public class Body {<br>    //外部类的成员变量<br>    private String name;</p><pre><code>public void methodBody(){    sout("外部类方法");}//成员内部类public class Heart{     public void beat(){        sout("心脏跳动");        sout(name);    }}</code></pre><p>}</p><p>//如何使用成员内部类？</p><ol><li>间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法。</li><li>直接方式： 公式<pre><code>      类名称 对象名 = new 类名称();      外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();</code></pre></li></ol><p>重名问题：<br>public class Outer{<br>    int num = 10; //外部类成员变量<br>    public class Inner {<br>        int num = 20; //内部类成员变量<br>        public void methodInner(){<br>            int num = 30; //内部类方法的局部变量<br>            sout(num);//局部变量就近 30<br>            sout(this.num); //内部类成员变量 20<br>            sout(Outer.this.num); //外部类成员变量 10<br>        }<br>    }<br>}</p><ol start="2"><li>局部内部类<br>如果一个类是定义在一个方法内部的，那么这就是一个局部内部类<br>只有当前所属的方法才能使用他，出了这个方法就不能使用了</li></ol><p>public class Outer{<br>    public void methodOuter(){<br>        //局部内部类<br>        class Inner{<br>            int num = 10;<br>            public void methodInner(){<br>                sout(num);<br>            }<br>        }<br>        Inner inner = new Inner();<br>        inner.methodInner();<br>    }<br>}</p><p>通过调用外部类方法 methodOuter()调用局部内部类</p><p>小结： 1. 外部类： public/(default)<br>       2. 成员内部类：public/protected/(default)/private<br>       3. 局部内部类：什么都不能写</p><p>局部内部类如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的<br>从Java8开始，只要局部变量事实不变，final可省略<br>原因：1. new出来的对象在堆内存中<br>      2. 局部变量是跟着方法走的，在栈内存中<br>      3. 方法运行结束后，立刻出栈，局部变量就会立刻消失<br>      4. 但是new出来的对象会在堆中持续存在，直到回收消失，因此局部内部类对象访问的局部变量不能发生改变</p><ol start="3"><li>匿名内部类<br>如果接口的实现类(或者父类的子类)只需要使用一次<br>那么可省略定义，改用匿名内部类<br>格式:<br>接口名称 对象名 = new 接口名称(){<br> //覆盖重写方法<br>}</li></ol><p>原本： 一个接口 -&gt; 建一个实现类 -&gt; new一个对象 -&gt; 使用<br>现在：使用匿名内部类<br>    MyInterface obj = new MyInterface(){<br>        @override<br>        //重写抽象方法<br>    }</p><p>注：</p><ol><li>匿名内部类，在创建对象的时候，只能使用唯一一次，<br>如果希望多次创建对象，且类内容一样的话，那就要用单独定义的实现类</li><li>匿名对象是在调用方法时只能调用一次，若想要调用多个方法，就需要创建对象</li><li>匿名内部类是省略了实现[实现类/子类名称],但是匿名对象省略了对象名称</li></ol><p>成员变量也可以是一个类<br>实际上任一个类型都可以作为成员变量,接口也可以<br>接口也可以作为方法的参数或返回值</p><h2 id="发红包案例"><a href="#发红包案例" class="headerlink" title="发红包案例"></a>发红包案例</h2><p>package Redpackage;</p><p>import java.util.ArrayList;</p><p>public class Manager extends User {<br>    public Manager() {</p><pre><code>}public Manager(String name, int money) {    super(name, money);}public ArrayList&lt;Integer&gt; send(int totalmoney,int count){    //首先需要一个集合，用来存储若干个红包金额    ArrayList&lt;Integer&gt; redList = new ArrayList&lt;Integer&gt;();    //看一下群主有多少钱    int leftMoney = super.getMoney();    if (totalmoney &gt; leftMoney ){        System.out.println("余额不足");        return redList;    }    //扣钱,其实就是重新设置余额    super.setMoney(leftMoney - totalmoney);    //发红包需要平均拆分为count份    int avg = totalmoney/count;    //余下的零头塞最后一个红包里    int mod = totalmoney % count;    int last = avg + mod;    //塞红包    for (int i = 0; i &lt; count-1; i++) {        redList.add(avg);    }    redList.add(last);    return redList;}</code></pre><p>}</p><hr><p>package Redpackage;</p><p>import java.util.ArrayList;<br>import java.util.Random;</p><p>public class Member extends User {<br>    public Member() {<br>    }</p><pre><code>public Member(String name, int money) {    super(name, money);}public void receive(ArrayList&lt;Integer&gt; list){    //从多个红包当中随便抽取一个给自己    //随机获得一个集合当中的索引编号    int index = new Random().nextInt(list.size());    //根据索引从集合中删除，并且得到被删除的红包给自己    int delta = list.remove(index);    int money = super.getMoney();    super.setMoney(money + delta);}</code></pre><p>}</p><hr><p>package Redpackage;</p><p>public class User {<br>    private String name; //用户姓名<br>    private int money; //账户余额</p><pre><code>public User() {}public User(String name, int money) {    this.name = name;    this.money = money;}//展示一下当前用户有多少钱public void show(){    System.out.println(name + '有' + money + '元');}public String getName() {    return name;}public void setName(String name) {    this.name = name;}public int getMoney() {    return money;}public void setMoney(int money) {    this.money = money;}</code></pre><p>}</p><hr><p>package Redpackage;</p><p>import java.util.ArrayList;</p><p>public class MainRed {<br>    public static void main(String[] args) {<br>        Manager manager = new Manager(“群主”,100);<br>        Member member1 = new Member(“群员1”,0);<br>        Member member2 = new Member(“群员2”,0);<br>        Member member3 = new Member(“群员3”,0);</p><pre><code>    manager.show();    member1.show();    member2.show();    member3.show();    System.out.println("=========================");    ArrayList&lt;Integer&gt; redlist = manager.send(10,3);    member1.receive(redlist);    member1.show();    member2.receive(redlist);    member2.show();    member3.receive(redlist);    member3.show();}</code></pre><p>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaBasic4&#39;</title>
      <link href="/2020/03/12/java-ji-chu/javabasics4/"/>
      <url>/2020/03/12/java-ji-chu/javabasics4/</url>
      
        <content type="html"><![CDATA[<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>一个对象具有多态<br>实现：父类引用指向子类对象，左父右子<br>   父类名称 对象名 = new 子类对象()<br>或 接口名称 对象名 = new 实现类名称()<br>子类当父类使用，猫是动物，作为动物类使用</p><p>访问成员变量：1. 等号左边是谁，就优先用谁，没有则向上找<br>              2. 间接通过成员方法访问<br>        口诀：编译看左边，运行还看左边<br>成员方法：子类覆盖重写了就用子类方法，没有重写就用父类<br>    口诀：编译看左边，运行看右边</p><a id="more"></a><p>多态的好处：<br>员工：work();//抽象<br>讲师类extends员工：work(){讲课}<br>助教类extends员工：work(){辅导}<br>如果不用多态：<br>Teacher one = new Teacher();<br>one.work(); //讲课<br>Assistant two = new Assistant();<br>two.work(); //辅导<br>我现在唯一要做的是调用work方法，并不关心哪一类员工工作<br>使用多态：<br>Employee one = new Teacher();<br>one.work();<br>Employee two = new Assistant();<br>two.work();<br>好处：无论右边new的时候换成哪个子类对象，等号左边调用方法不会变化。</p><p>对象的向上转型：</p><ol><li>对象的向上转型，其实就是多态写法<br>Animal animal = new Cat();<br>创建了一只猫，当作动物看待，没有问题<br>向上转型一定是安全的</li></ol><p>向下转型：<br>其实是一个[还原]的动作<br>对象一旦上转型为父类，那么就无法调用子类原本特有的内容<br>用向下转型还原<br>格式：子类名称 对象名 = (子类名称)父类对象;<br>      Cat cat = (Cat)animal;<br>      必须保证对象本来创建时就是猫，否则报错</p><p>//instanceof 关键字：先判断再向下转型<br>Animal animal = new Cat(); //本来是一只猫<br>animal.eat(); //猫吃鱼<br>// instance of 返回 boolean值，判断前面对象能不能当作后面类的实例<br>if(animal instanceof Dog){<br>    Dog dog = (Dog)animal;<br>    dog.watchHouse();}<br>if(animal instanceof Cat){<br>    Cat cat = (Cat)animal;<br>    cat.catchMouse();}</p><h2 id="笔记本USB接口案例"><a href="#笔记本USB接口案例" class="headerlink" title="笔记本USB接口案例"></a>笔记本USB接口案例</h2><p>package CmoputerUsb;</p><p>public class Computer {<br>    public void powerOn(){<br>        System.out.println(“笔记本开机”);<br>    }</p><pre><code>public void powerOff(){    System.out.println("笔记本关机");}//使用USB设备，使用USB接口作为参数public void useDevice(USB usb){    usb.open();    if(usb instanceof Mouse){        Mouse mouse = (Mouse) usb; //向下转型        mouse.click();    }else if(usb instanceof Keyboard){        Keyboard keyboard = (Keyboard) usb;        keyboard.type();    }else if(usb instanceof Upan){        Upan u = (Upan) usb;        u.copy();    }    usb.close();}</code></pre><p>}</p><hr><p>package CmoputerUsb;</p><p>public interface USB {<br>    public abstract void open();//打开设备</p><pre><code>public abstract void close();//关闭设备</code></pre><p>}</p><hr><p>package CmoputerUsb;</p><p>//键盘是一种USB设备<br>public class Keyboard implements USB {<br>    @Override<br>    public void open() {<br>        System.out.println(“open the keyboard”);<br>    }</p><pre><code>@Overridepublic void close() {    System.out.println("close the keyboard");}public void type() {    System.out.println("type the keyboard,kakaka");}</code></pre><p>}</p><hr><p>package CmoputerUsb;</p><p>import java.sql.SQLOutput;</p><p>//鼠标是一种USB设备<br>public class Mouse implements USB {<br>    @Override<br>    public void open() {<br>        System.out.println(“open the mouse”);<br>    }</p><pre><code>@Overridepublic void close() {    System.out.println("close the mouse");}public void click() {    System.out.println("click the mouse,kikiki");}</code></pre><p>}</p><hr><p>package CmoputerUsb;</p><p>public class Upan implements USB{</p><pre><code>@Overridepublic void open() {    System.out.println("插入U盘");}@Overridepublic void close() {    System.out.println("拔出U盘");}public void copy(){    System.out.println("U盘拷贝资料");}</code></pre><p>}</p><hr><p>package CmoputerUsb;</p><p>public class CpuMain {<br>    public static void main(String[] args) {<br>        //首先创建一个电脑<br>        Computer computer = new Computer();<br>        computer.powerOn();</p><pre><code>    //准备一个鼠标    Mouse mouse = new Mouse();    //向上转型    USB usb1 = mouse;    //使用鼠标    computer.useDevice(usb1);    //使用键盘    USB usb2 = new Keyboard();    computer.useDevice(usb2);    //使用U盘    computer.useDevice(new Upan());    computer.powerOff();}</code></pre><p>}</p><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>代表最终，不可改变的<br>常见四种用法：</p><ol><li><p>可以用来修饰一个类</p></li><li><p>可以用来修饰一个方法</p></li><li><p>修饰一个局部变量</p></li><li><p>修饰一个成员变量</p></li><li><p>final修饰一个类时<br>当前这个类不能有任何子类，从而所有成员方法都无法重写(因为没有儿子)<br>public final class 类名称{<br>}</p></li><li><p>final修饰一个方法时<br>这个方法就是最终方法，也就不能覆盖重写<br>修饰符 final 返回值类型 方法名称{<br>}<br>final 与 abstract 不能同时使用，矛盾</p></li><li><p>局部变量<br>final String lover = “呈呈”;<br>一次赋值，终生不变<br>如果是基本类型<br>final int num = 200；<br>如果是引用类型<br>final Student stu = new Student(“name1”)<br>地址不会改变，但内容可由set方法改变<br>stu.setName(“name2”);</p></li><li><p>对于成员变量，若使用final关键字修饰，必须手动赋值<br>要么直接赋值：private final String name = “name1”;<br>要么通过构造方法赋值，且保证类中所有构造方法都对final成员变量赋值<br>private final String name;<br>public Person(){<br> name = “…”;<br>}<br>public Person(String name){<br> this.name = name;<br>}</p></li></ol><p>四种权限修饰符：<br>                    public &gt; protected &gt; (default)不是关键字，指什么都不写 &gt; private<br>同一个类（自己）    Yes      Yes         Yes                                 Yes    同一个类都能访问<br>同一个包（妻子）    Yes      Yes         Yes                                 No     同一个包下无法访问另一个类的private<br>不同包子类（儿子）  Yes      Yes         No                                  No     不同包的子类只能访问protect以上的父类方法<br>不同包非子类（生人）Yes      No          No                                  No     只能访问Public</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaBasics3&#39;</title>
      <link href="/2020/03/11/java-ji-chu/javabasics3/"/>
      <url>/2020/03/11/java-ji-chu/javabasics3/</url>
      
        <content type="html"><![CDATA[<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>继承主要解决的问题就是共性抽取</p><a id="more"></a><p>如果成员变量父子重名，则创建子对象时，有两种访问方式</p><ol><li><p>直接通过子类对象访问，等号左边是谁，就优先用谁<br>Person p = new Student();  =&gt;用左边父类Person的成员变量</p></li><li><p>间接通过成员方法访问，方法属于谁就用谁</p></li></ol><p>三个重名变量：<br>直接写：就近<br>this：本类<br>super：父类</p><p>如果成员方法父子重名，创建的是什么类对象，优先用其成员方法，没有则向上找，不会向下寻找</p><p>//继承方法中的覆盖重写：override</p><ol><li><p>在继承关系中，方法名称一样，参数列表一样<br>@override 写在方法前，注解，检测重写是否有效</p></li><li><p>子类方法的返回值必须小于等于父类方法的返回值范围<br>Object是所有类的父类</p></li><li><p>子类方法的权限必须大于等于父类方法的权限修饰符<br>public &gt; protected &gt; 留空 &gt; private<br>设计原则：对于已经投入使用的类尽量不要进行修改，定义一个新类继承</p></li></ol><p>子类构造方法：</p><ol><li>子类构造方法当中有一个默认隐含的super() 调用父类构造方法</li><li>可以通过super关键字调用父类的重载方法</li><li>super的父类构造调用，必须是子类构造方法的第一个语句，不能调用多次super构造</li></ol><p>super：访问父类内容 1. 父类成员变量 super.name 2. 父类成员方法 super.methord() 3. 父类构造方法 super()<br>this: 访问本类内容 1. 本类成员 this.name 2. 本类成员方法 this.methord() 3. 本类改造 this()<br>this()也必须是第一个，this()与super()不能在一个构造方法中同时使用</p><p>继承的三个特点：1. 单继承 2. 可以多级继承 3. 一个父类可以有多个子类</p><p>//抽象方法<br>加上abstract关键字<br>public abstract void eat();<br>抽象方法所在的类必须是抽象类<br>public abstract class Animal{<br>}  </p><ol><li>不能直接创建抽象类对象</li><li>必须用一个子类来继承抽象父类</li><li>子类必须覆盖重写抽象方法</li><li>抽象类可以有构造方法，供子类创造对象时初始化父类成员使用</li><li>抽象类不一定有抽象方法，抽象方法一定要在抽象类中</li></ol><p>子类override父类抽象方法没有全写，也是抽象类</p><p>//接口<br>就是一种公共的规范标准<br>多个类的公共规范<br>是一种引用数据类型，最重要的内容是其中的抽象方法<br>定义<br>public interface 接口名称{<br>    //内容<br>}<br>可以包含：<br>Java7 1. 常量 2. 抽象方法<br>Java8 3. 默认方法 4. 静态方法<br>Java9 5. 私有方法<br>接口中的抽象方法，修饰符是两个固定关键字：public abstract</p><p>使用步骤</p><ol><li>接口不能直接使用，必须有一个“实现类”来实现接口<br>public class 实现类名称 implements 接口名称{<br>}</li><li>实现类必须覆盖重写抽象方法</li><li>创建实现类的对象</li></ol><p>Java8之后可定义默认方法<br>public default 返回值类型 方法名称(){<br>}<br>主要用于接口升级<br>接口中加默认方法，实现类可以不用改，后面对象直接调用</p><p>不能通过接口实现类的对象来调用接口当中的静态方法<br>正确用法：通过接口名称直接调用接口中的静态方法，<br>          接口名称.静态方法(参数)</p><p>Java9允许私有方法<br>    需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题<br>    但这个共有方法不应该让实现类使用，应该是私有化的<br>    解决：1. 普通私有方法，解决多个默认方法之间重复代码的问题<br>          2. 静态私有方法，解决多个静态方法之间重复代码问题</p><p>接口中也可以定义“成员变量”，但必须使用public static final 修饰符<br>效果上看是接口的常量，一旦赋值，不可修改<br>public static final interesting NUM_OF_CLASS = 12；<br>接口常量名称用全大写，下划线连接<br>接口不能有静态代码块，或者构造方法</p><ol start="2"><li>一个类可以实现多个接口<br>public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{</li></ol><p>}</p><ol start="3"><li>如果实现类的多个接口抽象方法重复了，只要发覆盖重写一次</li><li>如果实现类没有覆盖重写所有接口当中的抽象方法，那么实现类必须是一个抽象类</li><li>如果实现类所实现的多个接口当中，存在重复的默认方法，则必须对多个接口冲突的方法覆盖重写</li><li>如果实现类父类的方法与接口的默认方法一样，优先用父类的方法</li></ol><p>接口之间是可以多继承的<br>public interface MyInterface extends MyInterfaceA,MyInterfaceB{<br>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaBasics2&#39;</title>
      <link href="/2020/03/11/java-ji-chu/javabasics2/"/>
      <url>/2020/03/11/java-ji-chu/javabasics2/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象三大特征：封装，继承，多态"><a href="#面向对象三大特征：封装，继承，多态" class="headerlink" title="面向对象三大特征：封装，继承，多态"></a>面向对象三大特征：封装，继承，多态</h2><p>封装：</p><ol><li>方法就是一种封装</li><li>关键字private也是一种封装</li></ol><a id="more"></a><p>问题描述：定义person的年龄时，无法阻止不合理的数值被设置进来。<br>解决方案：用private关键字将需要保护的成员变量进行修饰。一旦使用了private进行修饰，<br>那么本类当中仍然可以随意访问，但超出了本类范围之外就不能直接再访问<br>间接访问：定义一对get/set方法<br>public class Person {<br>    private int age;<br>    public void setAge(int age) {<br>        if(age&gt;0 &amp;&amp; age &lt;= 100) {<br>            this.age = age;<br>        }else{<br>            System.out.println(“input the real age,please”);<br>        }<br>    }</p><pre><code>public int getAge() {    return age;}</code></pre><p>}</p><p>对于基本类型中的布尔值，Getter方法一定要写成isXXX形式</p><p>当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量<br>要访问本类的成员变量，使用this.成员变量名，this一定是在方法内部<br>通过谁调用的方法，this就是谁</p><p>//构造方法<br>专门用来构造对象的方法，当我们通过new创建对象时，其实就是在调用构造方法<br>格式：<br>public 类名称(参数类型 参数名称){<br>    方法体<br>}</p><ol><li>构造方法的名称必须和所在类名称完全一样(包括大小写)</li><li>构造方法不用返回值类型，连void都不写</li><li>不能return一个具体返回值</li><li>如果没有编写构造方法，编译器默认赠送一个构造方法，没有参数，方法什么都不做 public Person(){}</li></ol><p>public class Person {<br>    private String name;<br>    private int age;<br>    private int weight;<br>    private int height;<br>    //无参构造<br>    public Person() {<br>    }<br>    //有参构造<br>    public Person(String name, int age, int weight, int height) {<br>        this.name = name;<br>        this.age = age;<br>        this.weight = weight;<br>        this.height = height;<br>    }<br>}</p><p>一个标准的类通常拥有下面四个部分</p><ol><li>所有成员变量要使用private类关键字修饰</li><li>为每一个成员编写一对Getter/Setter方法</li><li>编写一个无参构造方法</li><li>编写一个全参构造方法</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>应用程序编程接口，JDK提供使用的类<br>Scanner类:<br>功能：实现键盘输入数据到程序当中<br>Scanner sc = new Scanner(System.in);<br>使用：获取键盘输入的int：int num = sc.nextInt();<br>      获取键盘输入的字符串：String str = sc.next();</p><p>匿名对象：new person().name = “cc”;</p><p>只想输入一次时，使用Scanner匿名对象<br>    int num = new Scanner(System.in).nextInt();</p><p>使用一般写法作为参数传入<br>Scanner sc = new Scanner(System.in);<br>method(sc);<br>使用匿名对象传入<br>method(new Scanner(System.in));</p><p>Random类：<br>用来生成随机数字<br>Random r = new Random();<br>int num = r.nextInt();<br>int num = r.nextInt(10);//[0,10)范围</p><p>对象数组<br>    Person[] array = new Person[3];<br>    Person one = new Person();<br>    Person two = new Person();<br>    Person three = new Person();<br>    array[0] = one;<br>    array[1] = two;<br>    array[2] = three;</p><pre><code>array[0].getName();</code></pre><p>ArrayList<e><br><e>代表泛型 装什么类型，只能放引用类型,不能放基本类型<br>数组长度不可以改变<br>但ArrayList可以改变<br>ArrayList<string> list = new ArrayList&lt;&gt;();<br>ArrayList直接打印得到的不是地址值，而是内容<br>增加：list.add();<br>获取：list.get(i);<br>删除：list.remove(i);//返回删除的值<br>尺寸：int size = list.size();</string></e></e></p><p>想放基本类型，必须使用“包装类”<br>ArrayList<integer> listc  = new ArrayList&lt;&gt;();</integer></p><p>//字符串</p><ol><li>字符串内容永不可变</li><li>因此，字符串可以共享使用</li><li>字符串效果上相当于char[]</li></ol><p>创建字符串的方法<br>常见3+1<br>public String(); //创建一个空白字符串</p><p>String str = “Hello”;  //直接创建</p><p>public String(char[] array);  //根据字符数组内容创建</p><p>char[] charArray = {‘A’,’B’,’C’};<br>String str1 = new String(charArray);<br>=&gt; ABC</p><p>public String(byte[] array);  //根据字节数组</p><p>byte[] byteArray = {97,98,99};<br>String str2 = new String(byteArray);<br>=&gt; ABC</p><p>字符串常量池：<br>程序当中直接写上的双引号字符串，就在字符串常量池中。<br>对于基本类型来说：==是进行数值的比较<br>对于引用类型来说：==是进行地址值的比较</p><ol><li>任何对象都能用object接收<br>对字符串内容比较：str1.equals(str2);</li><li>equals方法具有对称性<br>a.equals(b)与b.equals(a)相同</li><li>推荐”abc”.equals(str),不推荐str.equals(“abc”);</li></ol><p>equalsIgnoreCase: 忽略大小写的equals方法</p><p>//String中常用方法<br>长度： str.length()<br>拼接： str1.concat(str2) //str1不会变化，字符串是常量，返回全新的字符串<br>        “”+””+””<br>获取指定索引的字符： charAt()<br>               char ch = str.charAt(1);<br>查找参数字符串，第一次出现的索引，没有则返回-1<br>               int index = original.indexOf(“cc”);<br>截取： [ , )<br>public String substring(int index);  //截取指定位置到最后<br>public String substring(int begin,int end);</p><p>转换成字符数组：<br>char[] chars = “Hello”.toCharArray(); //变成数组<br>=&gt; [‘H’,’e’,’l’,’l’,’o’]</p><p>转换成字节数组：<br>byte[] bytes = “abc”.getBytes();<br>=&gt;[97,98,99]</p><p>替换：<br>String lang2 = lang1.replace(charsequence oldstring,charsequence newstring);<br>分割：<br>String str1 = “aaa,bbb,ccc”;<br>String[] a1 = str1.split(“,”);<br>=&gt;a1: [“aaa”,”bbb”,”ccc”]<br>split方法的参数是一个正则表达式，如果想按”.”切分，必须写”//.”转义</p><p>//static 静态<br>多个对象共享一份数据，一旦用了static关键字，则内容属于类，而不是对象自己<br>静态方法<br>public static void methord(){<br>静态方法属于类，可以通过对象名调用，也可以直接类名调用<br>推荐类名调用<br>如果没有static，就必须先创建对象，通过对象调用<br>}<br>注意：</p><ol><li>静态方法不能直接访问非静态变量(先人不知后人，static先产生，非static后产生)</li><li>静态是随类产生的，与对象无关，不能用this</li></ol><p>静态代码块：<br>当第一次用到本类时运行<br>典型用途：用来一次性对静态成员进行赋值<br>public class 类名称{<br>    static{<br>        //静态代码块<br>    }<br>}</p><p>//Arrays 数组工具类：<br>必须是一个数组，非数组可以通过toCharArray()转换<br>提供大量静态方法，用来实现数组常见操作</p><ol><li>将数组变为字符串<br>int [] intArray = {10,20,30};<br>String intStr = Arrays.toString(intArray);<br>=&gt;[10,20,30]</li><li>排序<br>Arrays.sort(array1);//默认升序<br>如果是自定义类型，那么自定义类型要有Comparable或Comparator接口支持</li></ol><p>//Math 数学工具类</p><ol><li>Math.abs():取绝对值</li><li>Math.ceil();向上取整，3.1-&gt;4.0,3.9-&gt;4.0</li><li>Math.floor();向下取整，3.1-&gt;3.0,3.9-&gt;3.0</li><li>Math.round();四舍五入</li><li>Math.PI</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;JavaBasics&#39;</title>
      <link href="/2020/03/11/java-ji-chu/javabasics/"/>
      <url>/2020/03/11/java-ji-chu/javabasics/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><p>//方法定义</p><p>修饰符 返回值类型 方法名称(参数类型 参数名称, …){<br>    方法体<br>    return 返回值<br>}</p><a id="more"></a><p>修饰符：public static<br>返回值类型为void时，无返回值，只能单独调用。<br>调用方式：单独调用，打印调用，赋值调用<br>注：1. 方法应定义在类当中，但不能在方法中再定义方法。<br>    2. 方法顺序武无所谓<br>    3. 通过调用执行<br>    4. return 后的返回值类型必须与方法的返回值类型对应</p><p>//重载 overload</p><p>同一个方法名称，多个类似功能<br>参数个数可以不同<br>参数类型可以不同<br>参数多类型顺序可以不同<br>若参数名称，返回值类型不同，则不可行</p><p>//数组</p><ol><li>一种引用数据类型</li><li>当中多个数据，类型必须统一</li><li>数组长度再程序运行期间不可改变</li></ol><p>数组的初始化</p><ol><li><p>动态初始化（指定长度）<br> 格式：<br> 数据类型 [] 数组名称 = new 数据类型[数组长度]<br> int [] arrayA = new int[5];</p></li><li><p>静态初始化（指定内容）<br> 格式：<br> 数据类型 [] 数组名称 = new 数据类型[]{元素一，元素二，元素三，….}<br> String [] arrayB = new String[]{“A”,”B”,”C”,….};<br> 省略格式 数据类型[] 名称 = {元素1，元素2，….}</p></li></ol><p>直接打印数组名称，得到的是对应内存地址<br>访问数组：数组名称[索引值]<br>获取数组长度：arrayA.length<br>数组一旦创建，程序运行期间，长度不可改变<br>数组遍历快捷键：arrayA.fori<br>想返回多个值时，需要用数组</p><p>//内存</p><p>JAVA内存划分为5个部分</p><ol><li><p>栈(stack)：存放的都是方法中的局部变量，方法运行一定要在栈中运行<br> 局部变量：方法的参数，或者是方法内部的变量<br> 作用域： 一旦超出作用域，立刻从栈内存当中消失</p></li><li><p>堆(heap)：凡是new出来的对象都在堆当中<br> 堆内存中的数据都有默认值<br> 整数 默认为0<br> 浮点数 0.0<br> 字符 ‘\u0000’<br> 布尔 false<br> 引用类型 null</p></li><li><p>方法区(Method Area)：存储 class 相关信息，包含方法的信息</p></li><li><p>本地方法栈</p></li><li><p>寄存器</p></li></ol><p>//类和对象</p><p>类：属性和行为的集合，属性：参数，成员变量。行为：方法，成员方法。<br>类是一类事物的描述，实例化为对象<br>public class ClassName{<br>    //成员变量<br>    String name;<br>    int age;</p><pre><code>//成员方法public void eat(){}public void study(){}</code></pre><p>}</p><p>创建一个对象</p><ol><li>导包：import 包名称.类名称<br> 若与当前类属于同一个包，可省略导包</li><li>创建<br> 类名称 对象名 = new 类名称();</li><li>使用<br> 使用成员变量：对象名.成员变量<br> 使用成员方法：对象名.成员方法名()</li></ol><p>//局部变量和成员变量</p><ol><li>定义的位置不一样<br> 局部变量：在方法的内部<br> 成员变量：在方法的外部，直接写在类当中</li><li>作用的范围不一样<br> 局部变量：只有方法当中才可以使用，出了方法就不能再使用<br> 成员变量：整个类都可以用</li><li>默认值不一样<br> 局部变量：没有默认值，如果要使用，必须手动赋值<br> 成员变量：若没有赋值，会有默认值</li><li>内存位置不一样<br> 局部变量：位于栈内存<br> 成员变量：位于堆内存</li><li>生命周期不一样<br> 局部变量：随着方法进栈而诞生，出栈而消失<br> 成员变量：随着对象创建而诞生，对象回收而消失</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;Database&#39;</title>
      <link href="/2020/02/26/database/"/>
      <url>/2020/02/26/database/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>三范式：列不可拆分<br>       唯一标识<br>       引用主键</p><a id="more"></a><p>E-R模型<br>关系及存储：<br>        1对1：一个对象A对应着一个对象B，一个对象B对应着一个对象A，<br>        关系可以存入A也可以存入B<br>        1对多：一个对象对应着n个对象B，一个对象B对应着一个对象A，<br>        关系存入B对象中<br>        多对多： 一个对象A对应着n个对象B，一个对象B也对应着n个对象A，<br>        关系存入新建的一个关系表中</p><p>– 查询<br>– select * from hero<br>– 创建表<br>CREATE TABLE students3 (<br>id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,<br>NAME VARCHAR (10), age INT UNSIGNED) ；<br>SELECT </p><ul><li><p>FROM<br>students3 ；</p><p>– 删除表</p><p>DROP TABLE IF EXISTS students2；<br>DROP TABLE students；</p><p>– 插入</p></li></ul><p>INSERT INTO students3 VALUES(0,’cc’,18)<br>主键默认写0，</p><p>插入多条<br>INSERT INTO students3 VALUES(0,’cc’,18),(0，’tt’，18),(0,’yy’,18);</p><p>给指定字段插入<br>INSERT INTO students3(id,name,age) VALUES(0,’cc’,18),(0，’tt’，18),(0,’yy’,18);</p><p>– 修改</p><p>updata students3 set name = ‘ll’,age = 18 where id = 2;</p><p>– 删除</p><p>delete from students3 where id = 3;</p><p>– 逻辑删除（还可以恢复）</p><ol><li>设计表，给表添加一个字段isdelete，1代表删除，0代表没有删除</li><li>给所有数据的isdelete都改为0</li><li>要删除某一条数据时，更新isdelete为1</li><li>查询数据时，只查询isdelete为0的数据</li></ol><p>alter table student add isdelete int</p><p>updata student set isdelete where id =1;</p><p>– 显示没有标记删除的数据<br>select * from student where isdelete=0;</p><p>– 查询 *代表所有列<br>select name,sex,hometown from students; </p><p>– 查询时显示字段别名 （as 可以省略）<br>select name as 姓名,sex as 性别,hometown 家乡from students; </p><p>– 给表起别名（查询多个表时使用）<br>select s.name,s.sex,s.hometown from students as s;</p><p>– 去重<br>查询学生性别有几种<br>select distinct sex from students;</p><p>select distinct sex,class from students;</p><p>– 查询小乔的年龄</p><p>select age from students where name = ‘小乔’；</p><p>where 后面过滤行，select 后面过滤列</p><p>– 查询20岁以下的学生</p><p>select * from students where age &lt; 20;</p><p>– 查询家乡不在北京</p><p>select * from students where hometown != ‘北京’；</p><p>–练习</p><ol><li><p>查询学号007的学生的身份证号码<br>select card from students where studentNo = ‘007’;</p></li><li><p>查询1班以外的学生信息<br>select * from students where calss != ‘1班’;</p></li></ol><p>3。 查询年龄大于20的学生的姓名和性别<br>select name,sex from students where age &gt; 20;</p><p>–逻辑运算<br>and or not </p><ol><li><p>查询年龄小于20的女同学<br>select * from students where age &lt; 20 and sex = ‘女’;</p></li><li><p>查询女学生或一班学生<br>select * from students where sex = ‘女’ or class = ‘1班’;</p></li></ol><p>– 查询家乡不在北京</p><p>select * from students where not hometown = ‘北京’；</p><h2 id="各种查询"><a href="#各种查询" class="headerlink" title="各种查询"></a>各种查询</h2><p>– 模糊查询<br>like<br>% 表示任意多个字符<br>_ 表示一个字符</p><p>查询姓田的学生<br>select * from students where name like ‘田%’;</p><p>查询姓田且名字是一个字<br>select * from students where name like ‘田_’;</p><p>查询名字是呈呈的学生<br>select * from students where name like ‘%呈呈’;</p><p>查询名字含庆的学生<br>select * from students where name like ‘%庆%’;</p><p>查询姓名为两个字的学生<br>select * from students where name like ‘__’;</p><p>– 范围查询<br>查询家乡是北京上海深圳的学生<br>select * from students where hometown in (‘北京’,’上海’,’深圳’);</p><p>查询年龄在18到20之间的学生<br>select * from students where age between 18 and 20;</p><p>– 空判断<br>is null</p><p>select * from students where card is null;<br>与空字符串不同<br>select * from students where card = ‘ ‘;</p><p>– 排序<br>asc 升序(可省略) desc 降序<br>select * from 表名 order by 列1 asc|desc,列2 asc|desc;</p><p>select * from students order by age asc;</p><p>年龄相同时再按学号从小到大排<br>select * from students order by age, studentNo；</p><p>中文排序需要把utf转成国标<br>select * from students order by convert(name using gbk);</p><p>– 聚合函数</p><p>– 查询学生总数<br>select count(<em>) from students;<br>select count(</em>) from students where class = ‘1班’;</p><p>– 查询女生最大年龄<br>select max(age) from students where sex = ‘女’;</p><p>– 一班最小年龄<br>select min(age) from students where class = ‘一班’;</p><p>– sum() 求此列的和<br>– 查询北京学生年龄总和<br>select sum(age) from students where hometown = ‘北京’;</p><p>– 查询女生平均年龄<br>select avg(age) from students where sex = ‘女’;</p><p>– 取别名<br>select max(age) 最大年龄, min(age) 最小年龄, avg(age) 平均年龄 from students </p><p>– 分组</p><p>查询各种性别的人数<br>select sex, count(*) from students group by sex;</p><p>查询各种年龄的人数<br>select age, count(*) from students group by age;</p><p>查询各个班级的最大年龄，最小年龄，平均年龄<br>select class,max(age),min(age),avg(age) from students group by class;</p><p>多字段分组<br>select class,sex,count(*) from students group by class,sex;</p><p>分组后再过滤<br>having 必须用在group by 后面<br>select sex, count(*) from students group by sex having sex = ‘男’;</p><p>查询一班以外的其他班学生最大年龄。最小年龄，平均年龄<br>select class, max(age), min(age),avg(age)from students where class != ‘1班’ group by class;</p><p>select class, max(age), min(age),avg(age)from students group by class not having class = ‘1班’;</p><p>– 分页， 获取部分行<br>查询前三行学生信息<br>0是起始位置，3是获取个数，从0 起始时0可以省略<br>select * from students limit 0,3; </p><p>每页显示三条，分页<br>先获取总数N，获取总页数N/3<br>第L页<br>select count(<em>) from students limit 3</em>(L-1),3</p><p>– 连接查询<br>把两个表连起来显示</p><p>先连接起来再用where过滤，会产生临时表占内存<br>select * from students,scores where students.studentNo = scores.studentNo;</p><p>select * from students as stu,scores as sc where stu.studentNo = sc.studentNo;</p><p>– 内连接<br>连接时先判断，等于则连接(节约内存)，交集</p><p>select * from students inner join scores on students.studentNo = scores.studentNo;</p><p>三个表连接<br>select * from students，courses, scores where students.studentNo = scores.studentNo and scores.courseNo  =courses.courseNo;</p><p>select * from students<br>inner join scores on students.studentNo = scores.studentNo<br>inner join courses on scores.courseNo = course.courseNo</p><p>查询西门吹雪的单杀成绩，要求显示姓名，课程号，成绩<br>select<br>students.name as 姓名, courses.courseNo as 课程号, scores.score as 成绩<br>from students<br>inner join scores on students.studentNo = scores.studentNo<br>inner join courses on scores.courseNo = courses.courseNo<br>where students.name = ‘西门吹雪’ and courses.name = ‘单杀’;</p><p>查询所有学生成绩，包括没有成绩的学生<br>left join 左表全显示出来<br>左连接 join 左边的表称为左表<br>select * from students<br>left join scores on students.studentNo = scores.studentNo</p><p>select * from students<br>left join scores on students.studentNo = scores.studentNo<br>left join courses on scores.courseNo = course.courseNo</p><p>right join 右表全显示出来</p><p>自关联<br>存在上下级关系，如地址</p><p>编号，区域，上级编号用一个表存储<br>aid，atitle，pid</p><p>查询河南省所有城市</p><p>select * from areas,areas_copy where areas.aid = areas_copy.pid and areas.atitle = ‘河南省’;</p><p>实际上并不要copy<br>select * from areas as sheng,areas as shi where sheng.aid = shi.pid and sheng.atitle = ‘河南省’;</p><p>查询郑州市下所有区<br>select * from areas as sheng,areas as shi where sheng.aid = shi.pid and sheng.atitle = ‘郑州市’;</p><p>三级查询<br>查询 河南省下所有区县<br>select * from areas as sheng,areas as shi, areas as qu where sheng.aid = shi.pid and shi.aid = qu.pid and sheng.atitle = ‘河南省’;</p><p>– 子查询<br>在一个select里嵌入另一个select</p><p>查询大于平均年龄的学生<br>select avg(age) from students;<br>select * from students where age &gt; 21.5833;</p><p>嵌入<br>select * from students where age &gt;(select avg(age) from students);</p><p>查询最小年龄的人<br>select * from students where age =(select min(age) from students);</p><p>–<br>标量子查询，子查询返回的结果是一个值<br>查询王昭君的成绩<br>select studentNo from students where name = ‘王昭君’;<br>select score from courses where studentNo = ‘001’;</p><p>嵌入</p><p>select score from courses where studentNo = (select studentNo from students where name = ‘王昭君’);</p><p>查询西门吹雪的数据库成绩，要求返回成绩<br>select score from courses where studentNo = (select studentNo from students where name = ‘西门吹雪’)<br>and courseNo = (select courseNo from courses where name = ‘数据库’);</p><p>– 列级子查询<br>子查询返回的是一列多行</p><p>查询十八岁学生的成绩，要求显示成绩<br>select studentNo from students where age = 18;<br>select score from scores in (‘002’,’006’)</p><p>嵌入<br>select score from scores in (select studentNo from students where age = 18);</p><p>– 行级子查询<br>子查询返回一行多列</p><p>查询男生中年龄最大的学生信息<br>select * from students where sex = ‘男’ and age = 26;</p><p>select * from students where (sex,age) = (‘男’,26);</p><p>select * from students where （sex,age) = (select sex,age from students where sex = ‘男’ order by age desc limit 1);</p><p>– 表级子查询</p><p>查询数据库和系统测试的课程成绩<br>先连接再筛选<br>select * from scores<br>inner join courses on scores.courseNo = courses.courseNo<br>where course.name in (‘数据库’,’系统测试’);</p><p>先筛选再连接<br>把查询出来的结果当成数据源,一定要取别名</p><p>select * from scores<br>inner join (select * from courses where name in (‘数据库’,’系统测试’)) as c on scores.courseNo = c.courseNo </p><p>any，some<br>=any 相当于 in</p><blockquote><p>any 大于其中任意一个都行，即大于最小值<br>&lt;any 小于其中任意一个都行，即小于最大值<br>!=any 没有意义</p></blockquote><p>all<br>!=all 除去这些</p><blockquote><p>all 大于所有，即大于最大值<br>&lt;all 小于所有，即小于最小值<br>=all 没有意义</p></blockquote><p>商品表练习<br>id name cate brand_name price is_show is_saleoff</p><ol><li><p>求所有产品的平均价格，保留两位小数<br>select round(avg(price),2) as avg_price from goods;</p></li><li><p>查询所有价格大于平均价格（保留两位小数）的商品，并且按价格降序排序<br>select * from goods where price &gt; (select round(avg(price),2) from goods) order by price desc;</p></li><li><p>查询价格大于等于超极本的商品，并且价格降序<br>select * from goods where price &gt;= any(select price from goods where cate = ‘超极本’) order by price desc;</p></li></ol><p>– 数据分表<br>分出一个类型表，把重复的数据单独存起来<br>create table good_cates(<br>id int unsigned primary key auto_increment,<br>cate_name varchar(10)<br>);</p><p>select distinct cate from goods;</p><p>把一个表查询出来的数据插入到另一个表<br>insert into good_cates(cate_name) select distinct cate from goods;</p><p>创建品牌表<br>create table goods_brands(<br>id int unsigned primary key auto_increment,<br>brand_name varchar(10)<br>) select distinct brand_name from goods;</p><p>update goods<br>inner join goods_cates on goods.cate = goods_cates.cate_name<br>set goods.cate = goods_cates.id</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>字符串函数<br>拼接字符串concat（str1,str2…)</p><p>select concat(123,’abc’)</p><p>长度<br>select length()<br>中文长度是3</p><p>截取字符串<br>left(str,len) 从左边截，返回字符串str的左端len个字符<br>right(str,len) 返回字符串str的右端len个字符<br>substring(str,pos,len) 返回字符串str的位置pos起len个字符，pos从1开始，不是从0开始</p><p>select name, sex,concat(left(name,1),’某某’) from students;</p><p>去除空格<br>ltrim(str) 返回删除了左空格的字符串<br>rtrim(str) 返回删除了右空格的字符串</p><p>大小写<br>select upper()<br>select lower()</p><p>四舍五入<br>select round(1.6,1) 1表示小数点后几位</p><p>当前日期时间<br>now()</p><p>日期格式化 data_format(data,format)<br>参数format %Y %y %m 等等</p><p>– 流程控制<br>case语法<br>select<br>case 1<br>when 1 then ‘one’<br>when 2 then ‘two’<br>else ‘zero’</p><p>end as result;</p><p>select name,sex from students<br>case sex<br>when ‘男‘ then concat(left(name,1),’先生’)<br>when ‘女’ then concat(left(name,1),’女士’)<br>else concat(left(name,1),’公公’)</p><p>end as result;</p><p>– 自定义函数<br>delimiter $$<br>creat function 函数名称(参数列表) returns 返回类型<br>begin<br>sql语句;<br>end</p><p>$$<br>命令行运行时遇到分号会直接运行，delimiter将运行标志改成$$</p><p>– 存储过程<br>delimiter $$<br>creat procedure 过程名称()<br>begin<br>sql语句;<br>end</p><p>$$ </p><p>call 过程名称;</p><p>– 视图<br>create view v_stu as<br>select * from students<br>…..</p><p>调用时<br>select * from v_stu<br>直接调用view中查询的表</p><p>– 事务<br>开启事务<br>begin；<br>所有操作都成功<br>…..<br>commit;</p><p>begin；<br>如果有任意一步失败<br>rollback；</p><p>– 索引<br>优化查询速度，但降低了更新效率<br>创建<br>create index title_index on test_index(title(10));</p><p>建表时创建<br>create table create_index(<br>id int primary key,<br>name varchar(10) unique,<br>age int;<br>key(age)<br>);<br>只要是主键，建表时自动附带索引<br>带有unique的自动建索引<br>手动给字段加索引 key()</p><p>表已经存在时添加索引<br>create index 索引名称 on 表名(字段名称(长度))</p><p>– 外键<br>根据一个表约束另一个表，但会降低更新效率<br>alter table 从表名 add foreign key (从表字段) references 主表名(主表字段);</p><p>alter table stu add foreign key (class_id) references class(id);<br>用class的id约束stu的班级号</p><p>删除约束<br>alter table 从表名 drop foreign key 外键名称</p><p>– 修改密码</p><p>use mysql;<br>update user set password=password(‘新密码’) where user = ‘用户名’;</p><p>flush privileges;</p><p>– 忘记密码<br>MySQL\MySQL Sever\my.ini<br>找到mysqld<br>添加一行 skip-grant-tables<br>重启免密登录，修改密码后删除此行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>myfirstblog</title>
      <link href="/2020/02/07/myfirstblog/"/>
      <url>/2020/02/07/myfirstblog/</url>
      
        <content type="html"><![CDATA[<p>搭建hexo并部署到github</p><a id="more"></a><h2 id="搭建hexo记录"><a href="#搭建hexo记录" class="headerlink" title="搭建hexo记录"></a>搭建hexo记录</h2><p>Windows：下载并安装 Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)<br>                   Git<br>root shift+ctrl+enter进入 管理员模式cmd</p><p>全局安装cnpm<br>npm install -g cnpm –registry-<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> </p><p>cnpm安装hexo<br>cnpm install -g hexo-cli</p><p>mkdir blog<br>C:\Windows\System32\blog</p><p>新建hexo<br>hexo init<br>启动hexo<br>hexo s</p><p>ctrl +c 退出</p><p>创建第一篇博客<br>hexo n ‘myfirstblog’</p><p>hexo clean<br>hexo g</p><h2 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h2><p>github Create a new repository  sqtian-hhu.github.io</p><p>blog路径下安装<br>C:\Windows\System32\blog&gt;cnpm install hexo-deployer-git–save</p><p>打开 _config.yml 进行设置<br>notepad _config.yml<br>对# Deployment做如下修改<br>deploy:<br>  type:’git’<br>  repo: <a href="https://github.com/sqtian-hhu/sqtian-hhu.github.io.git" target="_blank" rel="noopener">https://github.com/sqtian-hhu/sqtian-hhu.github.io.git</a><br>  branch: master</p><p>部署<br>hexo d</p><h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><p>神海4<br>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p><p>notepad _config.yml<br>将Extensions下theme：后改为 yilia</p><p>hexo clean<br>hexo g<br>hexo s</p><p>hexo d</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
