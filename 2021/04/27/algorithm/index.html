<!DOCTYPE HTML>
<html lang="zh-CN">
    <!-- shw2018 洪卫  modify 2019.08.15-->



<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Algorithm, 深度学习 故障诊断 Java">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY">
    <meta name="description" content="五大常用算法一、分治分治策略：    1、将原始问题划分或归结为规模较小的子问题。
2、递归或者迭代求解每个子问题

3、将子问题的解综合得到原问题的解

注意：
1、子问题与原问题的性质完全一样

2、子问题之间可以彼此独立求解

3、递">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Algorithm | 世庆的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/materialize/1.0.0/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/aos/3.0.0-beta.6/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/lightgallery/1.6.12/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <style type="text/css">
        
            
            code[class*="language-"],
            pre[class*="language-"] {
                white-space: pre !important;
            }

        
    </style>

    <script src="https://libs.baidu.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

    <body>

        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">世庆的博客</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/AV" class="waves-effect waves-light">
            
            <i class="fa fa-music"></i>
            
            <span>视听</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/galleries" class="waves-effect waves-light">
            
            <i class="fa fa-photo"></i>
            
            <span>相册</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于我</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-envelope"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性 洪卫 shw2018 modify 2019.09.17  -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/" class="waves-effect waves-light">
              
                <i class="fa fa-home"></i>
              
              <span>首页</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/tags" class="waves-effect waves-light">
              
                <i class="fa fa-tags"></i>
              
              <span>标签</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/categories" class="waves-effect waves-light">
              
                <i class="fa fa-bookmark"></i>
              
              <span>分类</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/archives" class="waves-effect waves-light">
              
                <i class="fa fa-archive"></i>
              
              <span>归档</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/AV" class="waves-effect waves-light">
              
                <i class="fa fa-music"></i>
              
              <span>视听</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/galleries" class="waves-effect waves-light">
              
                <i class="fa fa-photo"></i>
              
              <span>相册</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/about" class="waves-effect waves-light">
              
                <i class="fa fa-user-circle-o"></i>
              
              <span>关于我</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/contact" class="waves-effect waves-light">
              
                <i class="fa fa-envelope"></i>
              
              <span>留言板</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/friends" class="waves-effect waves-light">
              
                <i class="fa fa-address-book"></i>
              
              <span>友情链接</span>
            </a>

            
      </li>
    

    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">世庆的博客</div>
        <div class="logo-desc">
            
            河海大学 | 计算机与信息学院 | 信号与信息处理
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/AV" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-music"></i>
                
                视听
            </a>
        </li>
        
        <li>
            <a href="/galleries" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-photo"></i>
                
                相册
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于我
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-envelope"></i>
                
                留言板
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/sqtian-hhu/" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

   
   
<!-- 支持二级菜单特性 洪卫 shw2018 modify 2019.09.17  -->
<!-- <ul class="menu-list mobile-menu-list">
    
        <li class="m-nav-item">
                
                    <a href="/" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/tags" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-tags"></i>
                        
                        标签
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/categories" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/archives" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/AV" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-music"></i>
                        
                        视听
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/galleries" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-photo"></i>
                        
                        相册
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/about" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-user-circle-o"></i>
                        
                        关于我
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/contact" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-envelope"></i>
                        
                        留言板
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/friends" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-address-book"></i>
                        
                        友情链接
                    </a>
              
            </li>
        

        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/sqtian-hhu/" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul> -->

</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/sqtian-hhu/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

        
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Algorithm
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- shw2018 洪卫  modify 2019.08.15-->
<!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/算法/" target="_blank">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/算法/" class="post-category" target="_blank">
                                算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>
            
            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-04-27
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                        世庆
                    
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        6.6k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        28 分
                    </div>
                    
                
                
                
                        <span id="busuanzi_container_site_pv" style='display:none'></span>
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv" ></span>
    
                

            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="五大常用算法"><a href="#五大常用算法" class="headerlink" title="五大常用算法"></a>五大常用算法</h3><h2 id="一、分治"><a href="#一、分治" class="headerlink" title="一、分治"></a>一、分治</h2><p>分治策略：<br>    1、将原始问题划分或归结为规模较小的子问题。</p>
<pre><code>2、递归或者迭代求解每个子问题

3、将子问题的解综合得到原问题的解

注意：
1、子问题与原问题的性质完全一样

2、子问题之间可以彼此独立求解

3、递归停止时，子问题可以直接求解。

经典问题：Hanoi塔，归并排序，二分检索，芯片测试</code></pre><p>#案例1. Hanoi塔<br>设a,b,c是3个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，<br>由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将塔座a上的圆盘移到塔座c上，<br>并仍按同样顺序叠置。在移动圆盘时应遵守以下移动规则：<br>规则1：每次只能移动1个圆盘；<br>规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；<br>规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一塔座上。<br>思路<br>如果只有 1 个圆盘，a –&gt; c<br>如果圆盘数大于1<br>将 n - 1 个圆盘，从 a 借助 c 移动到 b<br>将剩下 1 个圆盘从 a 移动到 c<br>将 n - 1 个圆盘，从 b 借助 a 移动到 c</p>
<pre><code>@param n 要移动多少个圆盘
@param a 出发地点
@param b 借助地点
@param c 目标地点
public static void move(int n,char a,char b,char c){
    if (n&lt;1){
        System.out.println("请输入正整数");
    } else if (n == 1) {
        System.out.println(a+"--&gt;"+c);
    }else {
        //先将n-1个盘从a借助c移动到b
        move(n-1,a,c,b);
        //此时,b有n-1个盘,a还剩一个盘,将此盘直接移到c
        move(1,a,b,c);

        //下一个子问题,如何将b的所有盘借助a移动到c
        move(n-1,b,a,c);
    }
}</code></pre><p>#案例2. 芯片测试<br>有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。<br>　　每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。<br>    而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。<br>　　给出所有芯片的测试结果，问哪些芯片是好芯片。</p>
<p>输入格式<br>　　输入数据第一行为一个整数n，表示芯片个数。<br>　　第二行到第n+1行为n*n的一张表，每行n个数据。<br>    表中的每个数据为0或1，在这n行中的第i行第j列（1≤i, j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，<br>    1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。</p>
<p>输出格式<br>　　按从小到大的顺序输出所有好芯片的编号</p>
<p>样例输入<br>3<br>1 0 1<br>0 1 0<br>1 0 1</p>
<p>样例输出<br>1 3</p>
<pre><code>public static ArrayList&lt;Integer&gt; crip(int n, int[][] matrix){
    /*
     * 要点
     * 本题要点：题目中说：已知好芯片比坏芯片多。
     * 统计矩阵的每一列1的个数，也就是每个芯片被测试为好的次数（包括自己）
     * 如果某芯片被测试为好的次数小于被测试为坏的次数，
     * 如果该芯片为好的，则表示将它测试为坏的那些芯片其实都是坏的
     * 这样坏芯片就比好芯片多，不符合题意
     *
     * 因此,如果被测试为坏的次数多于好,那此芯片指定是坏的
     * 反之,如果测试为好的次数大于坏,那他指定不能是坏的.
     */
    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();

    //测试为好的次数
    //j列表示芯片对第j个的测试,从j列开始循环读第i个芯片对j的测试
    for (int j = 0;j&lt;n;j++){
        int tmp = 0;
        for (int i = 0;i&lt;n;i++){
            if (matrix[i][j] == 1){
                tmp++;
            }
        }
        if (tmp&gt;n-tmp){
            res.add(j+1);
        }
    }

    return res;
}</code></pre><h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><p>用于解决具有重复子问题和最优子结构的最优化问题。<br>基本思想也是将待求解的问题分解成若干子问题，先求解子问题然后从这些子问题的解得到原问题的解<br>与分治法不同的是，动态规划分解得到的子问题往往不是相互独立的，<br>即上一个子问题的解可能为下一个子问题的条件(通常将结果填入表格)</p>
<p>经典问题：投资问题、背包问题、最长公共子序列</p>
<p>#案例1. 投资问题<br>问题：有m元钱，n项投资，fi(x)：将x元投入第i个项目的效益。求使得的总效益最大的投资方案。<br>建模：问题的解是向量&lt;x1,x2,…,xn&gt;<br>    xi是投给项目i的钱数,i=1,2,3,….,n<br>    目标函数F=max{f1(x1)+f2(x2)+…+fn(xn)}<br>    约束条件 x1+x2+…+xn=m,xi∈N</p>
<p>子问题界定:由参数k和x界定<br>k: 考虑对项目1,2,…,k的投资<br>x: 投资总钱数不超过x</p>
<p>原始输入: k=n,x=m<br>子问题计算顺序:<br>    k=1,2,…,n<br>    对于给定的k,x=1,2,…m</p>
<p>递推方程和边界条件<br>    Fk(x) = max{fk(xk)+Fk-1(x-xk)}<br>    F1(x) = f1(x)</p>
<pre><code>@param m m-1元钱
@param n n个项目
@param tempF 存放投资效益最大值 tempF[i][j]表示j个项目一共投资i元的最高效益
@param d 存放标记解, d[i][j] 表示j个项目一共投i元时,第j个项目投多少元
@param business 效益表 business[i][j] 表示第j个项目投i元的收益
@return 最大利润

public static int investBusiness(int m,int n,int[][] tempF,int[][] d,int[][] business){
    int sum = 0;

    //先考虑1个项目的情况（1个项目在0到m-1费用之间的效益）
    for (int i = 0;i&lt;m;i++){
        //只有一个项目时,最高效益表就等于输入效益表的第一列
        tempF[i][0] = business[i][0];
        //第一个项目投资i元
        d[i][0] = i;
    }

    //考虑多个(&gt;=2)项目的情况（多个项目在0到m-1费用之间的效益）
    for (int j = 1;j&lt;n;j++){ //从第二个项目开始
        for (int i = 0;i&lt;m;i++){
            //最后一个项目投0-i元钱求出最优解
            for (int k = 0;k&lt;i;k++){
                //Fk(x)=max{fk(xk)+Fk-1(x-xk)}
                sum = business[k][j]+tempF[i-k][j-1];
                if (sum&gt;tempF[i][j]){
                    tempF[i][j] = sum;
                    //j+1个项目一共i元的情况下,记下第j+1个项目应投资k元
                    d[i][j] = k;

                }
            }
        }
    }
    return tempF[m-1][n-1];
}

//解的追踪
public static int[] tracingSolution(int m,int n,int[][] d){
    //将解寄存在数组里
    int tracing[] = new int[n];
    int s = m-1;

    //最后一个项目应该投资的钱数
    tracing[n-1] = d[m-1][n-1];

    for (int j = n-2;j&gt;=0;j--){
        //后一个项目的钱投完后剩余的钱
        s -= tracing[j+1];
        //追踪前0-j个项目投s元的分配
        tracing[j] = d[s][j];
    }

    return tracing;
}</code></pre><p>#案例2. 背包问题<br>一个旅行者随身携带一个背包,可以放入背包的物品有n种,每种物品的重量和价值分别为wi,vi<br>如果背包的最大重量限制是b,每种物品可以放多个.<br>怎样选择使背包物品价值最大?<br>建模:<br>解是&lt;x1,x2,…xn&gt;, 其中xi是装入背包的第i种物品个数<br>目标函数: maxΣvixi<br>约束条件: Σwixi&lt;=b</p>
<p>子问题界定: 由参数k和y界定 dp[k][y]<br>k: 考虑对物品1,2,…,k的选择<br>y: 背包总重量不超过y</p>
<p>原始输入: k=n,y=b<br>子问题计算顺序: k = 1,2,…,n<br>                对于给定的k,y=1,2,…,b</p>
<p>Fk(y): 装前k种物品,总重不超过y,背包达到的最大价值  dp[k][y]<br>Fk(y) = max{Fk-1(y),Fk(y-wk)+vk}   dp[k][y] = max(dp[k-1][y],dp[k][y-wk])<br>(Fk(y-wk)递归,式子含义是不装第k种的最大价值和第k种至少装一件的最大价值比<br>初值: F0(y) = 0, 0&lt;=y&lt;=b, Fk(0) = 0,0&lt;=k&lt;=n<br>F1(y)=[y/w1]*v1,Fk(y) = -∞ y&lt;0</p>
<p>*第二种写法:<br>与投资问题类似,但时间复杂度比第一种高<br>Fk(y) = max{Fk-1(y-xkwk)+xkvk}, 0&lt;=xk&lt;=[y/wk]</p>
<p>*背包问题的推广:</p>
<ol>
<li><p>物品数受限的背包,0-1背包</p>
</li>
<li><p>多背包问题: m个背包,背包j装入最大重量为Bj,j = 1,2,…,m</p>
</li>
<li><p>二维背包问题: 每件物品有重量wi和体积ti,背包总重量不超过b,体积不超过V</p>
<p>  static class Materia{</p>
<pre><code> public int weight;
 public int value;
 public Materia(int weight, int value) {
     this.weight = weight;
     this.value = value;
 }</code></pre><p> }</p>
<p> @param materia 材料数组<br> @param maxWeight 背包最大承重<br> @param tempF 存放装包价值最大值 tempF[i][j]表示i种材料一共限制j重的最高价值<br> @param d 追踪结果表<br> @return<br> public static int maxLoadingValue(Materia[] materia,int maxWeight,int[][] tempF,int[][] d){</p>
<pre><code> int sum = 0,tempValue,num=d[0][0];

 if (materia.length == 0 || maxWeight == 0){
     return tempF[materia.length-1][maxWeight];
 }

 //初始化
 //只装第一个物品的装包情况,包的容量至少是1,
 //j 1~maxWeight
 for (int j=1;j&lt;=maxWeight;j++){
     tempValue = (j/materia[0].weight)*materia[0].value;
     if (tempValue&gt;sum){
         num = 1;
         sum = tempValue;
     }
     //最大价值表记下只有第一种材料的情况下,不同载重的最大价值
     tempF[0][j] = sum;
     //追踪表记下载重j只有第一种材料时,上一个放入的都是第一个材料
     d[0][j] = num;
 }</code></pre></li>
</ol>
<pre><code>    //装2号之后的材料
    //从i=1开始
    for(int i=1;i&lt;materia.length;i++){
        //装1~maxWeight重量
        for (int j =1;j&lt;=maxWeight;j++){
            //先把num赋为d[i-1][j], 表示目前先拿的材料和只有0~i-1种时相同
            num=d[i-1][j];
            //如果放不下新增的第i+1个材料,临时价值量=0
            //临时价值量存的是至少装一个新材料的总价值
            if (j-materia[i].weight&lt;0){
                tempValue = 0;
            }else {
                //Fk(y):装前k种物品,总重不超过y,背包达到的最大价值
                //Fk(y)=max{Fk-1(y),Fk(y-wk)+vk}
                //装得下第i+1种材料,则要比较至少装一个和不装的价值
                //Fk(y-wk)+vk
                tempValue=tempF[i][j-materia[i].weight]+materia[i].value;
            }
            //和不装第i种材料的总价值比较
            if (tempValue&gt;=tempF[i-1][j]){
                if (j-materia[i].weight&gt;=0){
                    //最新一步装第i+1种材料
                    num = i+1;</code></pre><p>//                        num++;<br>                    }<br>                    //如果装第i+1种材料比不装的价值高,将tempF[i][j]赋成tempValue<br>                    tempF[i][j] = tem<br>                    pValue;<br>                } else{<br>                    //否则,最大价值依然是只用0~i-1种材料的最优解<br>                  tempF[i][j] = tempF[i-1][j];<br>                }<br>                //记录i+1种材料,背包载重j的情况下,最先放入的材料是第num号材料<br>                d[i][j] = num;<br>            }<br>        }<br>        //返回最大价值<br>        return tempF[materia.length-1][maxWeight];<br>    }</p>
<pre><code>public static int[] tracingSolution(int maxWeight,int[][] d,Materia[] materia){
    //将解寄存在数组里
    //一个k种材料,解的长度为k
    int k = materia.length,count=0,y=maxWeight;
    int[] tracing = new int[k];

    int index = k-1;
    while (y&gt;0&amp;&amp;k&gt;0){
        //拿到解数组中的最后一个值,表示从最后一种材料开始,先取哪一种材料

        k=d[k-1][y];
        //若是能取到该物品，则对应数组下标中的值+1,表示放该材料的数目+1
        tracing[k-1] = ++count;
        y=y-materia[k-1].weight;

        //如果要取的依然是第k种材料,先把k种材料的解遍历再找d[k-1][y]的解
        while(y&gt;0&amp;&amp;d[k-1][y]==k) {
            tracing[k-1]=++count;
            y=y-materia[k-1].weight;
        }
        count=0;
    }
    return tracing;
}


设序列X,Z
X = &lt;x1,x2,...,xm&gt;
Z = &lt;z1,z2,...,zm&gt;
若存在X的元素构成的严格递增序列使得
zj = xij,j=1,2,...,k
则称Z是X的子序列
即: Z中的元素都是从X中选出来的,且前后次序一样,可以间隔着选

问题: 最长公共子序列
实例: X: A B C B D A B
    Y: B D C A B A
    最长公共子序列: B C B A, 长度4

递推方程:
    Xi = &lt;x1,x2,...,xi&gt;, Yj=&lt;y1,y2,...,yj&gt;
    C[i,j]: Xi与Yj的LCS的长度

C[i,j]= 0, 若 i=0 或 j=0
    = C[i-1,j-1]+1, 若i,j&gt;0,xi = yj
    = max{C[i,j-1],C[i-1,j]}, 若i,j&gt;0,xi != yj</code></pre><p>public class 最长公共子序列 {<br>    public static void main(String[] args) {<br>        //随机生成指定长度的字符串<br>        int size = 20;<br>        String x  = generateRandomStr(size);<br>        String y  = generateRandomStr(size);</p>
<pre><code>    int m = x.length();
    int n = y.length();
    //创建二维数组，也就是填表的过程
    int[][] c = new int[m+1][n+1];

    //初始化二维数组
    for (int i = 0; i &lt; m+1; i++) {
        c[i][0] = 0;
    }
    for (int i = 0; i &lt; n+1; i++) {
        c[0][i] = 0;
    }

    //实现公式逻辑
    int[][] path = new int[m+1][n+1];//记录通过哪个子问题解决的，也就是递推的路径
    for (int i = 1; i &lt; m+1; i++) {
        for (int j = 1; j &lt; n+1; j++) {
            if(x.charAt(i-1) == y.charAt(j-1)){
                c[i][j] = c[i-1][j-1] + 1;
            }else if(c[i-1][j] &gt;= c[i][j-1]){
                c[i][j] = c[i-1][j];
                path[i][j] = 1;
            }else{
                c[i][j] = c[i][j-1];
                path[i][j] = -1;
            }
        }
    }
    //输出查看c
    System.out.println("c:");
    for (int i = 0; i &lt; m+1; i++) {
        for (int j = 0; j &lt; n+1; j++) {
            System.out.print(c[i][j]+"\t");
        }
        System.out.println();
    }
    //输出查看path
    System.out.println("path:");
    for (int i = 0; i &lt; m+1; i++) {
        for (int j = 0; j &lt; n+1; j++) {
            System.out.print(path[i][j]+"\t");
        }
        System.out.println();
    }

    System.out.printf("%s与%s的最长公共子序列为：\n",x,y);
    PrintLCS(path,x,m,n);


}

public static String generateRandomStr(int length) {
    String base = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    Random random = new Random();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; length; i++) {
        int number = random.nextInt(base.length());
        sb.append(base.charAt(number));
    }
    return sb.toString();
}


public static void PrintLCS(int[][]b,String x,int i,int j){
    if(i == 0 || j == 0){
        return;
    }

    if(b[i][j] == 0){
        PrintLCS(b,x,i-1,j-1);
        System.out.printf("%c",x.charAt(i-1));
    }else if(b[i][j] == 1){
        PrintLCS(b,x,i-1,j);
    }else{
        PrintLCS(b,x,i,j-1);
    }
}</code></pre><h2 id="三、贪心"><a href="#三、贪心" class="headerlink" title="三、贪心"></a>三、贪心</h2><p>贪心算法可以获取到问题的局部最优解，不一定能获取到全局最优解<br>同时获取最优解的好坏要看贪心策略的选择<br>特点就是简单，能获取到局部最优解</p>
<p>经典问题：单源最短路径、最小生成树、哈夫曼算法、找零钱问题、最优装载问题、最小延迟调度、活动选择问题</p>
<p>#案例1. 单源最短路径(Dijkstra算法)</p>
<p>给定带权有向网络 G=(V,E,W),每条边 e=&lt;i,j&gt;的权w(e)为非负实数<br>表示从i到j的距离<br>求从s出发到达其它结点的最短路径</p>
<p>算法思想的简单描述：<br>要找出源到其他顶点的最短距离，首先将所有顶点划分成两个集合，S是已经到达的顶点，V是没有到达的顶点，显然S+V就是所有顶点。<br>初始，S集合中只包含源顶点（本例中是1号顶点），然后找出V中距离S集合最近的一个顶点<br>（即贪心选择，至于为什么是S集合，请务必理解该问题的最优子结构性质）。<br>那么显然，需要有个对象来记录每个顶点到源顶点的距离，这就是代码中的dist数组。<br>dist[2]=x就表示，顶点2到源顶点的最短距离是x。找到后，记录下路径。<br>如何记录，同样需要一个对象，即代码中的prev数组。prev[2]=y就表示，顶点2到源顶点的最短路径中，顶点2的前一个顶点是顶点y。<br>记录下路径的同时还需要将该顶点加入到S集合中,它就是s数组了。</p>
<p>初始: S={s},S=V时算法结束<br>从s到u相对于S的最短路径: 从s到u且仅经过S中顶点的最短路径<br>dist[u]: 从s到u相对于S最短路径的长度<br>short[u]: 从s到u的最短路径的长度<br>dist[u]&gt;=short[u]</p>
<p>
输入:有向图
输出:从s到每个顶点的最短路径

</p><pre><code>static float max = Float.MAX_VALUE;
@param v    源
@param a    图
@param dist 路径长度
@param prev 路径

public static void dijkstra(int v, float[][] a, float[] dist, int[] prev) {
    // v是源，dist[i]表示当前从源到顶点i的最短特殊路径长度,prev[i]=j：最短路径中顶点i的前一个顶点是j，类似于链表
    int n = dist.length - 1;// 节点个数
    //如果出发源不在节点范围
    if (v &lt; 0 || v &gt; n) {
        return;
    }

    //S集合标记ture的在S中，false的不在
    boolean[] s = new boolean[n + 1];

    // 初始化
    for (int i = 0; i &lt;= n; i++) {
        //a[v][i] 从v到i的路径，没有边则是max
        dist[i] = a[v][i];
        //初始时节点不在集合S中
        s[i] = false;
        if (dist[i] == Float.MAX_VALUE)
            //没有边相连时路径链表初始化为0
            prev[i] = 0;
        else
            //有边直接相连的路径链表初始化为v
            prev[i] = v;
    }

    dist[v] = 0;
    //v点初始在S集合中
    s[v] = true;

    // 循环n+1次,直到所有点加进了S集合
    for (int i = 0; i &lt;= n; i++) {
        float temp = Float.MAX_VALUE;
        int u = v;

        //第一次循环找出距离集合最近的节点u
        for (int j = 0; j &lt;= n; j++) {
            // 寻找不在集合内且距离集合最近的节点j
            if ((!s[j]) &amp;&amp; (dist[j] &lt; temp)) {
                u = j;// 记录节点
                temp = dist[j];// 记录最短特殊路径长度
            }
        }

        s[u] = true;// 将节点u放入集合

        //第二次循环找出经由u能够到达的节点
        for (int j = 0; j &lt;= n; j++) {// 重新设置dist[]和prev[]的值
            if ((!s[j]) &amp;&amp; (a[u][j] &lt; max)) {// 寻找不在集合内，且可达的节点

                //新的距离等于从v到u的最短距离+从u到j的距离
                float newdist = dist[u] + a[u][j];
                if (newdist &lt; dist[j]) { // 与旧值进行比较，保留小的值
                    dist[j] = newdist;
                    prev[j] = u;
                }
            }
        }
    }
}</code></pre><p></p><p>#案例2. 最小生成树<br>G的一棵生成树T是包含了G的所有顶点的树，树中各边的权之和W(T)称为树的权,具有最小权的生成树称为G的最小生成树</p>
<pre><code>#kruskal算法</code></pre><p> 设计思想:</p>
<ol>
<li><p>按照长度从小到大对边排序</p>
</li>
<li><p>依次考察当前最短边e,如果e与T的边不构成回路,则把e加入树T,否则跳过e.直到选择了n-1条边为止</p>
<p>算法实现:<br>建立FIND数组,FIND[i]是结点i的连通分支标记</p>
</li>
<li><p>初始FIND[i] = i</p>
</li>
<li><p>连通分支合并,较小分支标记更新为较大分支标记</p>
<p>应用:数据分组问题<br>一组数据要把它们按照相关性进行分类 单链聚类</p>
<p>具体步骤</p>
</li>
<li><p>将图的所有连接线去掉，只剩顶点</p>
</li>
<li><p>从图的边集数组中找到权值最小的边，将边的两个顶点连接起来</p>
</li>
<li><p>继续寻找权值最小的边，将两个顶点之间连接起来，如果选择的边使得最小生成树出现了环路，则放弃该边，选择权值次小的边</p>
</li>
<li><p>直到所有的顶点都被连接在一起并且没有环路，最小生成树就生成了。</p>
<p>使用并查集思路</p>
</li>
</ol>
<p>public class 最小生成树Kruskal算法 {<br>    public static void main(String[] args) {<br>        int[][] edges = {<br>//              begin, end, weight<br>                {0, 1, 6},<br>                {0, 2, 1},<br>                {0, 3, 5},<br>                {2, 1, 5},<br>                {2, 3, 5},<br>                {2, 4, 5},<br>                {2, 5, 4},<br>                {1, 4, 3},<br>                {4, 5, 6},<br>                {5, 3, 2}<br>        };</p>
<pre><code>    int n = 6;
    int[][] mstEdges = kruskal(n, edges);

    int totalCost = 0;
    System.out.println("Edges of MST: [node1, node2, cost]");
    //输出构树的边集
    for (int i = 0; i &lt; mstEdges.length; i++) {
        int[] edge = mstEdges[i];
        for (int j = 0; j &lt; edge.length; j++) {
            System.out.print(edge[j] + " ");
        }
        totalCost += edge[2];
        System.out.println();
    }

    System.out.println("Total cost of MST: " + totalCost);
}

public static int[][] kruskal(int n, int[][] edges) {
    /**
     * @Description: 克鲁斯卡尔算法求最小生成树
     * @Param: [n, edges] ==&gt; [结点个数， 边集]
     * @return: int[] 构成最小生成树的边集
     */
    int[] pres = new int[n]; //并查集
    int[] ranks = new int[n]; //结点的秩,树的层数?

    // 初始化：pres一开始设置每个元素的上一级是自己，ranks一开始设置每个元素的秩为0
    for (int i = 0; i &lt; n; i++) {
        pres[i] = i;
        ranks[i] = 0;
    }

    //用自己定义的MyEdge类里面的compareTo排序，按边权排序
    ArrayList&lt;MyEdge&gt; edgesList = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; edges.length; i++) {
        edgesList.add(new MyEdge(edges[i]));
    }
    // 边集从小到大排序
    Collections.sort(edgesList);

    //最小生成树的边
    int[][] mstEdges = new int[n - 1][3];
    int count = 0;
    for (int i = 0; i &lt; edgesList.size(); i++) {
        int[] arr = edgesList.get(i).array;
        int a = arr[0], b = arr[1], c = arr[2];
        //边的两个节点不在同一个集合里,合并
        if (find(a, pres) != find(b, pres)) {
            unionSet(a, b, pres, ranks);
            //添加到结果集合中
            mstEdges[count] = arr;
            count++;
        }
        //如果两个节点的根节点相同,说明已经划在了结果集合里,这条边会构成闭环,不添加

        //连接好了所有节点, 所有节点都在一个集合了
        if (count == n) {
            break;
        }
    }
    //返回结果
    return mstEdges;
}


//并查集

//并：合并两个集合，按秩合并
public static void unionSet(int n1, int n2, int[] pres, int[] ranks) {
    int root1 = find(n1, pres);
    int root2 = find(n2, pres);
    //当两个元素不是同一组的时候才合并
    //两个节点的连接根节点不同
    if (root1 != root2) {
        //把节点数少的一组划归大的一组
        if (ranks[root1] &lt; ranks[root2]) {
            pres[root1] = root2;
        } else {
            pres[root2] = root1;
            //如果两组个数相等,结点层数+1
            if (ranks[root1] == ranks[root2])
                ranks[root1]++;
        }
    }
}

//查：查找元素的根节点
public static int find(int x, int[] pres) {
    int root = x;
    //如果此结点上级结点不是自己,继续向上搜索
    while (pres[root] != root)
        root = pres[root];

    //循环后,找到根节点为root

    //路径压缩
    int p = x;
    while (pres[p] != p) {
        //把所有结点的上级节点都设置成root
        int t = pres[p];
        pres[p] = root;
        p = t;
    }
    return root;
}</code></pre><p>}</p>
<p>// 边的排序类<br>class MyEdge implements Comparable {<br>    int[] array;</p>
<pre><code>MyEdge(int[] array) {
    this.array = array;
}

@Override
public int compareTo(Object o) {
    o = (MyEdge) o;
    int[] arr = ((MyEdge) o).array;
    if (array[2] &gt; arr[2]) {
        return 1;
    } else if (array[2] == arr[2]) {
        return 0;
    } else {
        return -1;
    }
}</code></pre><p>}</p>
<pre><code>#prim算法</code></pre><p>prim设计思想<br>输入: 图G=(V,E,W),V 节点,E 边,W 权值, V={1,2,…,n}<br>输出: 最小生成树T<br>初始S = {1}<br>选择连接S与V-S集合的最短边e={i,j},其中i∈S,j∈V-S.将e加入树T,j加入S<br>继续执行上述过程,直到S=V</p>
<p>prim以点出发, kruskal以边出发</p>
<p>public class 最小生成树Prim算法 {<br>    public static void main(String[] args) {<br>//交互输入图的邻接矩阵表示，为方便测试，直接给定了邻接矩阵值<br>//        System.out.println(“请输入图定点个数： “);<br>//        Scanner sc = new Scanner(System.in);<br>//        String line = sc.nextLine();<br>//        int n = Integer.parseInt(line);<br>//        System.out.println(“请输入图的路径长度: “);<br>//        int[][] c = new int[n+1][n+1];<br>//        for(int i = 0; i &lt; n; i++) {<br>//            line = sc.nextLine();<br>//            String[] ds = line.split(“,”);<br>//            for(int j = 0;j &lt; ds.length; j++) {<br>//                c[i+1][i+1] = Integer.parseInt(ds[j]);<br>//<br>//            }<br>//        }<br>//        System.out.println(“一次构成树的边为： “);<br>        int n = 6;<br>        //c[i][j]表示从i到j的权，为了方便对应索引，ｃ[0][j]和c[i][0]都设置成0</p>
<p>//        自己到自己的权，以及不能直接到的值置-1，方便后面处理<br>        int[][] c = {<br>                {0,0,0,0,0,0},<br>                {0,-1,6,1,5,-1,-1},<br>                {0,6,-1,5,-1,3,-1},<br>                {0,1,5,-1,5,6,4},<br>                {0,5,-1,5,-1,-1,2},<br>                {0,-1,3,6,-1,-1,6},<br>                {0,-1,-1,4,2,6,-1}<br>        };<br>        prim(n,c);</p>
<pre><code>}
public static void prim(int n, int[][] c) {
    //lowcost[i] 表示 从1到i的最短权值
    int[] lowcost = new int[n+1];
    //closest[i]的表示：</code></pre><p>//        将整个节点空间定为V，已选的空间从S=1（只有第一个点）开始，<br>//        j在V-S中，找到S里离j最近的节点i ，就记录在closest[j]。<br>        int[] closest = new int[n+1];<br>        //哪些节点已经进入S空间<br>        boolean[] s = new boolean[n+1];<br>        //节点1进入S中，此为初始化<br>        s[1] = true;<br>        //初始化<br>        for(int i = 2; i &lt;= n; i++) {<br>            //初始化第一个节点到每个节点权值<br>            lowcost[i] = c[1][i];<br>            //初始化，因为S中只有1，所以每个V-S中的节点最近的S中的节点一定是1<br>            closest[i] = 1;<br>            //这些节点都初始化为不在S中的状态<br>            s[i] = false;<br>        }</p>
<pre><code>    //n-1次遍历，把S空间扩充成V
    for(int i = 1;i &lt; n; i++) {
        //记录一个当前最小权值，不断比较最终变为整个1次遍历过程的最小权值
        int min = Integer.MAX_VALUE;
        //初始化j，j其实代表的是V-S空间中被选进S的节点
        //它的特征是，它到S（任何节点）的权值比其他节点到S（同样随便哪个节点）都小
        //这里的思想就是贪心的概念，通过局部最优可以得到全局最优
        int j = 1;
        //遍历除了直接初始化在S中的1节点外的其他所有节点
        for(int k = 2; k &lt;= n; k++) {
            //不等于-1即，直接有权值，然后迭代出最小的lowcost，同时更新一些值。
            //这里举例更容易说明，如lowcost[k]其实代表的是目前的S空间到k的最小权值，
            // 迭代找到了这个k，那么 显然 j就应该是k
            if(lowcost[k] != -1 &amp;&amp; lowcost[k] &lt; min &amp;&amp; !s[k]) {
                min = lowcost[k];
                j = k;
            }
        }
        //输出这对连接，closest[j]记录的其实就是达成lowcost[k]这一最小权值时，S中具体是哪个节点
        System.out.println(closest[j] + "-" + j);
        //如此，把j纳入S空间
        s[j] = true;
        //j进入S空间后，更新除1节点外所有节点的状态，他们到S的最小权值还得看看他们到 新进入的j是否更小
        for(int k = 2; k &lt;= n; k++) {
            if(!s[k] &amp;&amp; c[j][k] != -1) {
                //这里注意，如果lowcost[k]本来是-1
                //说明本来都不相连直接可以更新了
                //这里的逻辑要搞清楚，先判断有必要更新么？（c[j][k]!= -1),
                // 然后判断 要么c[j][k]比之前的权值更小，
                // 要么原来都不相连（c[j][k] &lt; lowcost[k] || lowcost[k] == -1) 此时进行更新！
                if(c[j][k] &lt; lowcost[k] || lowcost[k] == -1) {
                    //更新该节点最小的权值
                    lowcost[k] = c[j][k];
                    //更新该节点在S中最近的点
                    closest[k] = j;
                }
            }
        }

    }
}</code></pre><p>}</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力!</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.bmp" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.bmp" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            
            
            
            <div class="reprint1">
                <p>
                    <span class="reprint1-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="https://sqtian-hhu.github.io" class="b-link-green">世庆的博客</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2021/04/27/algorithm/" class="b-link-green">Algorithm</a>
                </p>
            </div>

        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXX',
        clientSecret: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
        repo: 'shw2018.github.io',
        owner: 'shw2018',
        admin: ["shw2018"],
        id: '2021/04/27/algorithm/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }
    /* valine 评论框增加背景图片 */
    #vcomments textarea {
        box-sizing: border-box;
        background: url("") 100% 100% no-repeat;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
    padding-top: 2.5em !important ;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <link rel="stylesheet" type="text/css" href="/libs//libs/jQuery-emoji/dist/css/jquery.emoji.css">
<script src="/libs//libs/jQuery-emoji/dist/js/jquery.emoji.min.js"></script>
<script src="/libs//libs/jQuery-emoji/dist/js/emoji.list.js"></script> -->
<script>
    new Valine({
        el: '#vcomments',
        appId: 'XXXXXXXXXXXXXXXXXXXXXXXX',
        appKey: 'XXXXXXXXXXXXXXXXXXXXXX',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go',

    });

//     function parse_emoji() {
//     jQuery(".vcontent").emojiParse({
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists   // 注：详见 js/emoji.list.js
//     });
//   }
  
//   setTimeout(function() {
//     // jQuery emoji 解析
//     parse_emoji();
//     // jquery emoji 初始化
//     jQuery(".veditor").emoji({
//       showTab: true,
//       animation: 'slide',
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists  // 注：详见 js/emoji.list.js
//     });
//     jQuery(".vmore").on("click", function() {
//       setTimeout(function() {
//         parse_emoji();
//       }, 500);
//     });
//   }, 800)

</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2021/04/27/algorithm/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="Algorithm">
                        
                        <span class="card-title">Algorithm</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            五大常用算法一、分治分治策略：    1、将原始问题划分或归结为规模较小的子问题。
2、递归或者迭代求解每个子问题

3、将子问题的解综合得到原问题的解

注意：
1、子问题与原问题的性质完全一样

2、子问题之间可以彼此独立求解

3、递
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/算法/" class="post-category" target="_blank">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/算法/" target="_blank">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/04/26/sortsollutions/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="SortSollutions.md">
                        
                        <span class="card-title">SortSollutions.md</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            八大排序1. 冒泡排序冒泡排序原理：相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处public class 冒泡排序 {
public void maoPaoSort(ArrayList&lt;Integer&gt; a
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-04-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/算法/" class="post-category" target="_blank">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/排序算法/" target="_blank">
                        <span class="chip bg-color">排序算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 世庆的博客<br />'
            + '作者: ShiQing<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


        <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&copy; 2019 田世庆. 

            <br>
            <span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span>
            <br>

            

            
                    
                        <span id="busuanzi_container_site_pv" style='display:none'></span>
                        总访问量: <span id="busuanzi_value_site_pv" class="white-color"></span>
                    
        
                    
                        <span id="busuanzi_container_site_uv" style='display:none'></span>
                        人次&nbsp; | &nbsp;访客人数: <span id="busuanzi_value_site_uv" class="white-color"></span> 人
                    
    
            

            
                &nbsp; | &nbsp;字数统计:&nbsp;
                <span class="white-color">135.2k</span> 字
            

            
            <br>

        </div>

        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/sqtian-hhu" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>


 
    <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=2528393970@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>






    <a href="http://wpa.qq.com/msgrd?v=3&uin=2528393970&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>

    </div>
</footer>

<div class="progress-bar"></div>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2020, 02, 01, 00, 00, 00); //北京时间2019-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已勉强运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>






        <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


        <script src="https://cdn.bootcss.com/materialize/1.0.0/js/materialize.min.js"></script>
        <script src="https://cdn.bootcss.com/masonry/4.2.2/masonry.pkgd.min.js"></script>
        <script src="https://cdn.bootcss.com/aos/3.0.0-beta.6/aos.js"></script>
        <script src="https://cdn.bootcss.com/scrollprogress/3.0.2/scrollProgress.min.js"></script>
        <script src="https://cdn.bootcss.com/lightgallery/1.6.12/js/lightgallery-all.min.js"></script>
        <script src="/js/matery.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->



        
            <script src="/libs/others/clicklove.js"></script>
        

        
            <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        

        <!-- 洪卫 shw2018 add 2019.08.28 -->
        <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = "看不见我~看不见我~", clearTimeout(st)) : (document.title =
                    "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script>

        <!-- 鼠标点击烟花爆炸效果  洪卫 shw2018 add 2019.09.09 -->
        

        <!-- 背景雪花飘落特效 -->
        
            <script type="text/javascript">
            //只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
            }
            </script>
        

        <!-- 鼠标点击文字特效 -->
        
            <script src="/js/wenzi.js" type="text/javascript"></script>
        

        <!-- 背景雪花飘落特效  -->
        
            <script type="text/javascript">
                var windowWidth = $(window).width();
                if (windowWidth > 768) {
                    document.write('<script type="text/javascript" src="/js/xuehuapiaoluo.js"><\/script>');
                }
            </script>
        

        <!-- 在线聊天工具   -->
        
            <script src="//code.tidio.co/xxxxxxxxxxxxxxxxxxxxxxxxxxx.js"></script>
            <!--  在线聊天位置自定义  洪卫 shw2018 add 2019.09.13  -->
            <script> 
                $(document).ready(function () {

                    setInterval(change_Tidio, 50);  
                    function change_Tidio() { 

                        var tidio=$("#tidio-chat iframe");
                        if(tidio.css("display")=="block"&& $(window).width()>977 ){
                            document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"80px":"20px";   
                            document.getElementById("tidio-chat-iframe").style.right="-15px";   
                            document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                            document.getElementById("tidio-chat-iframe").style.zIndex="997";
                        } 
                        else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                            document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                            document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                            document.getElementById("tidio-chat-iframe").style.zIndex="997";
                        }
                        else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                            document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                            document.getElementById("tidio-chat-iframe").style.zIndex="997";
                        }

                        if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                            document.getElementById("tidio-chat-iframe").style.zIndex="998";
                        }
                    } 
                }); 
            </script>
        

        <!-- 背景 canvas-nest  -->
        
            <script type="text/javascript">
            var windowWidth = $(window).width();
            if (windowWidth > 992) {
                document.write('<script type="text/javascript" color="0,0,255" pointColor="0,0,255" opacity= "0.8" zIndex="--1" count="150"src="/libs/background/canvas-nest.js"><\/script>');
            }
            </script>
        

        <!-- 背景静止彩带  -->
        

        <!-- 背景动态彩带 -->
        
            <script type="text/javascript">
            var windowWidth = $(window).width();
            if (windowWidth > 992) {
                document.write('<script type="text/javascript" src="/libs/background/ribbon-dynamic.js"><\/script>');
            }
            </script>
        

    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":200},"mobile":{"show":false},"react":{"opacity":0.7}});</script><script>!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c<r.length;c++)t=r[c],void 0,0<=(n=t.getBoundingClientRect()).top&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=r[c];t=o,n=function(){r=r.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}t(),e.addEventListener("scroll",function(){!function(t,n){clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)}(t,e)})}(this);</script></body>
</html>